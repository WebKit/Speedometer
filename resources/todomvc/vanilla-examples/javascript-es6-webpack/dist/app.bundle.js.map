{"version":3,"file":"app.bundle.js","mappings":";;;;;AAAoD;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;;;AC7DA;AAC6D;;AAE7D;AACA;;AAEA;AACA,IAAI,EAAE;AACN,IAAI,EAAE,sBAAsB,YAAY;AACxC;;AAEA;AACA,qBAAqB,EAAE,cAAc,GAAG;;AAExC;AACA;AACA;;AAEA;;AAEA;AACA,IAAI,EAAE;AACN;;AAEA;AACA,qBAAqB,EAAE,cAAc,GAAG;;AAExC;AACA;AACA;;AAEA,4BAA4B,oBAAoB;;AAEhD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,EAAE,cAAc,GAAG;;AAEtC;AACA;AACA;;AAEA,gBAAgB,EAAE;AAClB;;AAEA;;AAEA,IAAI,GAAG;AACP;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,iBAAiB,EAAE,cAAc,GAAG;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;;AAEA,yBAAyB,EAAE;AAC3B,gCAAgC,EAAE;AAClC,+BAA+B,EAAE;AACjC,qBAAqB,EAAE;AACvB,uBAAuB,EAAE;AACzB,0BAA0B,EAAE;AAC5B,wBAAwB,EAAE;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,GAAG;AACnB;AACA;AACA,gBAAgB,GAAG;AACnB;AACA;AACA,gBAAgB,GAAG,4CAA4C,6BAA6B;AAC5F;AACA;AACA,gBAAgB,SAAS,0DAA0D,uBAAuB;AAC1G;AACA;AACA,gBAAgB,SAAS,uDAAuD,uBAAuB;AACvG;AACA;AACA,gBAAgB,SAAS,sDAAsD,oDAAoD;AACnI;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;AC1LA,iDAAe,UAAU,EAAC;;AAE1B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC,+CAA+C,WAAW;AAC1D,SAAS;AACT,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,wCAAwC,0CAA0C;AAClF,qDAAqD,0BAA0B;AAC/E,KAAK;AACL;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;ACtQA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC,WAAW;AAC3C,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,4CAAe,KAAK,EAAC;;;ACnHrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ,wCAAwC,WAAW;AAC1E,eAAe,UAAU;AACzB;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,QAAQ;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,QAAQ;;AAExB;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA,gBAAgB,QAAQ;;AAExB,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,uDAAuD,WAAW;;AAElE;AACA;AACA;AACA;AACA;;AAEA,4CAAe,KAAK,EAAC;;;AC7JR;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAM,eAAM;AACZ;;AAEA;AACA;AACA;AACA,2BAA2B,IAAI,WAAW,WAAW;AACrD;AACA,4DAA4D,SAAS;AACrE,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C,IAAI;AAC/C,2CAA2C,OAAO,GAAG,eAAM;AAC3D,2CAA2C,WAAW;AACtD,2CAA2C,SAAS;;AAEpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,0BAA0B,YAAY,gBAAgB,QAAQ;AAC9D;;AAEA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA,+CAAe,QAAQ,EAAC;;;AC9FE;AACY;AACV;AACA;AACM;;AAEC;AAChB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,KAAK;AAC5B,qBAAqB,KAAK;AAC1B,wBAAwB,QAAQ;AAChC,oBAAoB,IAAI;AACxB,0BAA0B,UAAU;AACpC;;AAEA;AACA,IAAI,KAAU,EAAE,EAKf;;AAED;AACA","sources":["webpack://javascript-es6-webpack/./src/helpers.js","webpack://javascript-es6-webpack/./src/view.js","webpack://javascript-es6-webpack/./src/controller.js","webpack://javascript-es6-webpack/./src/model.js","webpack://javascript-es6-webpack/./src/store.js","webpack://javascript-es6-webpack/./src/template.js","webpack://javascript-es6-webpack/./src/app.js"],"sourcesContent":["export { qs, qsa, $on, $delegate, $parent, remove };\n\n// Get element(s) by CSS selector:\nfunction qs(selector, scope) {\n    return (scope || document).querySelector(selector);\n}\n\nfunction qsa(selector, scope) {\n    return (scope || document).querySelectorAll(selector);\n}\n\n// addEventListener wrapper:\nfunction $on(target, type, callback, useCapture) {\n    target.addEventListener(type, callback, !!useCapture);\n}\n\n// Attach a handler to event for all elements that match the selector,\n// now or in the future, based on a root element\nfunction $delegate(target, selector, type, handler) {\n    // https://developer.mozilla.org/en-US/docs/Web/Events/blur\n    var useCapture = type === \"blur\" || type === \"focus\";\n    $on(target, type, dispatchEvent, useCapture);\n\n    function dispatchEvent(event) {\n        var targetElement = event.target;\n        var potentialElements = qsa(selector, target);\n        var hasMatch = Array.prototype.indexOf.call(potentialElements, targetElement) >= 0;\n\n        if (hasMatch) {\n            handler.call(targetElement, event);\n        }\n    }\n}\n\n// Find the element's parent with the given tag name:\n// $parent(qs('a'), 'div');\nfunction $parent(element, tagName) {\n    if (!element.parentNode) {\n        return undefined;\n    }\n    if (element.parentNode.tagName.toLowerCase() === tagName.toLowerCase()) {\n        return element.parentNode;\n    }\n    return $parent(element.parentNode, tagName);\n}\n\n// removes an element from an array\n// const x = [1,2,3]\n// remove(x, 2)\n// x ~== [1,3]\nfunction remove(array, thing) {\n    const index = array.indexOf(thing);\n    if (index === -1) {\n        return array;\n    }\n\n    return array.splice(index, 1);\n}\n\n// Allow for looping on nodes by chaining:\n// qsa('.foo').forEach(function () {})\nNodeList.prototype.forEach = Array.prototype.forEach;\n","/* eslint no-invalid-this: 0, complexity:[2, 9] */\nimport { qs, qsa, $on, $parent, $delegate } from \"./helpers\";\n\nconst ENTER_KEY = 13;\nconst ESCAPE_KEY = 27;\n\nconst _setFilter = (currentPage) => {\n    qs(\".filters .selected\").className = \"\";\n    qs(`.filters [href=\"#/${currentPage}\"]`).className = \"selected\";\n};\n\nconst _elementComplete = (id, completed) => {\n    const listItem = qs(`[data-id=\"${id}\"]`);\n\n    if (!listItem) {\n        return;\n    }\n\n    listItem.className = completed ? \"completed\" : \"\";\n\n    // In case it was toggled from an event and not by clicking the checkbox\n    qs(\"input\", listItem).checked = completed;\n};\n\nconst _editItem = (id, title) => {\n    const listItem = qs(`[data-id=\"${id}\"]`);\n\n    if (!listItem) {\n        return;\n    }\n\n    listItem.className = `${listItem.className} editing`;\n\n    const input = document.createElement(\"input\");\n    input.className = \"edit\";\n\n    listItem.appendChild(input);\n    input.focus();\n    input.value = title;\n};\n\nconst _editItemDone = (id, title) => {\n    let listItem = qs(`[data-id=\"${id}\"]`);\n\n    if (!listItem) {\n        return;\n    }\n\n    let input = qs(\"input.edit\", listItem);\n    listItem.removeChild(input);\n\n    listItem.className = listItem.className.replace(\" editing\", \"\");\n\n    qsa(\"label\", listItem).forEach((label) => {\n        label.textContent = title;\n    });\n};\n\nconst _itemId = (element) => {\n    var li = $parent(element, \"li\");\n    return parseInt(li.dataset.id, 10);\n};\n\nconst _removeItem = (id, list) => {\n    const elem = qs(`[data-id=\"${id}\"]`);\n\n    if (elem) {\n        list.removeChild(elem);\n    }\n};\n\n/**\n * View that abstracts away the browser's DOM completely.\n * It has two simple entry points:\n *\n *   - bind(eventName, handler)\n *     Takes a todo application event and registers the handler\n *   - render(command, parameterObject)\n *     Renders the given command with the options\n */\nexport default class View {\n    constructor(template) {\n        this.template = template;\n\n        this.$todoList = qs(\".todo-list\");\n        this.$todoItemCounter = qs(\".todo-count\");\n        this.$clearCompleted = qs(\".clear-completed\");\n        this.$main = qs(\".main\");\n        this.$footer = qs(\".footer\");\n        this.$toggleAll = qs(\".toggle-all\");\n        this.$newTodo = qs(\".new-todo\");\n\n        this.render = this.render.bind(this);\n        this.bindCallbacks = this.bindCallbacks.bind(this);\n    }\n\n    _clearCompletedButton(completedCount, visible) {\n        this.$clearCompleted.innerHTML = this.template.clearCompletedButton(completedCount);\n        this.$clearCompleted.style.display = visible ? \"block\" : \"none\";\n    }\n\n    // eslint-disable-next-line complexity\n    render(viewCmd, parameter) {\n        switch (viewCmd) {\n            case \"showEntries\":\n                this.$todoList.innerHTML = this.template.show(parameter);\n                break;\n            case \"updateElementCount\":\n                this.$todoItemCounter.innerHTML = this.template.itemCounter(parameter);\n                break;\n            case \"contentBlockVisibility\":\n                this.$main.style.display = this.$footer.style.display = parameter.visible ? \"block\" : \"none\";\n                break;\n            case \"toggleAll\":\n                this.$toggleAll.checked = parameter.checked;\n                break;\n            case \"clearNewTodo\":\n                this.$newTodo.value = \"\";\n                break;\n            case \"removeItem\":\n                _removeItem(parameter, this.$todoList);\n                break;\n            case \"setFilter\":\n                _setFilter(parameter);\n                break;\n            case \"elementComplete\":\n                _elementComplete(parameter.id, parameter.completed);\n                break;\n            case \"editItem\":\n                _editItem(parameter.id, parameter.title);\n                break;\n            case \"editItemDone\":\n                _editItemDone(parameter.id, parameter.title);\n                break;\n            case \"clearCompletedButton\":\n                this._clearCompletedButton(parameter.completed, parameter.visible, this.clearCompletedButton);\n                break;\n        }\n    }\n\n    bindCallbacks(event, handler) {\n        switch (event) {\n            case \"newTodo\":\n                $on(this.$newTodo, \"change\", () => handler(this.$newTodo.value));\n                break;\n            case \"removeCompleted\":\n                $on(this.$clearCompleted, \"click\", handler);\n                break;\n            case \"toggleAll\":\n                $on(this.$toggleAll, \"click\", (e) => handler({ completed: e.target.checked }));\n                break;\n            case \"itemEdit\":\n                $delegate(this.$todoList, \"li label\", \"dblclick\", (e) => handler({ id: _itemId(e.target) }));\n                break;\n            case \"itemRemove\":\n                $delegate(this.$todoList, \".destroy\", \"click\", (e) => handler({ id: _itemId(e.target) }));\n                break;\n            case \"itemToggle\":\n                $delegate(this.$todoList, \".toggle\", \"click\", (e) => handler({ id: _itemId(e.target), completed: e.target.checked }));\n                break;\n            case \"itemEditDone\":\n                $delegate(this.$todoList, \"li .edit\", \"blur\", function (e) {\n                    if (!e.target.dataset.iscanceled) {\n                        handler({\n                            id: _itemId(e.target),\n                            title: e.target.value,\n                        });\n                    }\n                });\n                $delegate(this.$todoList, \"li .edit\", \"keypress\", function (e) {\n                    if (e.keyCode === ENTER_KEY) {\n                        e.target.blur();\n                    }\n                });\n                break;\n            case \"itemEditCancel\":\n                $delegate(this.$todoList, \"li .edit\", \"keyup\", (e) => {\n                    if (e.keyCode === ESCAPE_KEY) {\n                        e.target.dataset.iscanceled = true;\n                        e.target.blur();\n                        handler({ id: _itemId(e.target) });\n                    }\n                });\n                break;\n        }\n    }\n}\n","export default Controller;\n\n/**\n * Takes a model and view and acts as the controller between them\n *\n * @constructor\n * @param {object} model The model instance\n * @param {object} view The view instance\n */\nfunction Controller(model, view) {\n    var that = this;\n    that.model = model;\n    that.view = view;\n\n    that.view.bindCallbacks(\"newTodo\", function (title) {\n        that.addItem(title);\n    });\n\n    that.view.bindCallbacks(\"itemEdit\", function (item) {\n        that.editItem(item.id);\n    });\n\n    that.view.bindCallbacks(\"itemEditDone\", function (item) {\n        that.editItemSave(item.id, item.title);\n    });\n\n    that.view.bindCallbacks(\"itemEditCancel\", function (item) {\n        that.editItemCancel(item.id);\n    });\n\n    that.view.bindCallbacks(\"itemRemove\", function (item) {\n        that.removeItem(item.id);\n    });\n\n    that.view.bindCallbacks(\"itemToggle\", function (item) {\n        that.toggleComplete(item.id, item.completed);\n    });\n\n    that.view.bindCallbacks(\"removeCompleted\", function () {\n        that.removeCompletedItems();\n    });\n\n    that.view.bindCallbacks(\"toggleAll\", function (status) {\n        that.toggleAll(status.completed);\n    });\n}\n\n/**\n * Loads and initialises the view\n *\n * @param {string} '' | 'active' | 'completed'\n */\nController.prototype.setView = function (locationHash) {\n    var route = locationHash.split(\"/\")[1];\n    var page = route || \"\";\n    this._updateFilterState(page);\n};\n\n/**\n * An event to fire on load. Will get all items and display them in the\n * todo-list\n */\nController.prototype.showAll = function () {\n    var that = this;\n    that.model.read(function (data) {\n        that.view.render(\"showEntries\", data);\n    });\n};\n\n/**\n * Renders all active tasks\n */\nController.prototype.showActive = function () {\n    var that = this;\n    that.model.read({ completed: false }, function (data) {\n        that.view.render(\"showEntries\", data);\n    });\n};\n\n/**\n * Renders all completed tasks\n */\nController.prototype.showCompleted = function () {\n    var that = this;\n    that.model.read({ completed: true }, function (data) {\n        that.view.render(\"showEntries\", data);\n    });\n};\n\n/**\n * An event to fire whenever you want to add an item. Simply pass in the event\n * object and it'll handle the DOM insertion and saving of the new item.\n */\nController.prototype.addItem = function (title) {\n    var that = this;\n\n    if (title.trim() === \"\") {\n        return;\n    }\n\n    that.model.create(title, function () {\n        that.view.render(\"clearNewTodo\");\n        that._filter(true);\n    });\n};\n\n/*\n * Triggers the item editing mode.\n */\nController.prototype.editItem = function (id) {\n    var that = this;\n    that.model.read(id, function (data) {\n        that.view.render(\"editItem\", { id, title: data[0].title });\n    });\n};\n\n/*\n * Finishes the item editing mode successfully.\n */\nController.prototype.editItemSave = function (id, title) {\n    var that = this;\n    if (title.trim()) {\n        that.model.update(id, { title }, function () {\n            that.view.render(\"editItemDone\", { id, title });\n        });\n    } else {\n        that.removeItem(id);\n    }\n};\n\n/*\n * Cancels the item editing mode.\n */\nController.prototype.editItemCancel = function (id) {\n    var that = this;\n    that.model.read(id, function (data) {\n        that.view.render(\"editItemDone\", { id, title: data[0].title });\n    });\n};\n\n/**\n * By giving it an ID it'll find the DOM element matching that ID,\n * remove it from the DOM and also remove it from storage.\n *\n * @param {number} id The ID of the item to remove from the DOM and\n * storage\n */\nController.prototype.removeItem = function (id) {\n    var that = this;\n    that.model.remove(id, function () {\n        that.view.render(\"removeItem\", id);\n    });\n\n    that._filter();\n};\n\n/**\n * Will remove all completed items from the DOM and storage.\n */\nController.prototype.removeCompletedItems = function () {\n    var that = this;\n    that.model.read({ completed: true }, function (data) {\n        data.forEach(function (item) {\n            that.removeItem(item.id);\n        });\n    });\n\n    that._filter();\n};\n\n/**\n * Give it an ID of a model and a checkbox and it will update the item\n * in storage based on the checkbox's state.\n *\n * @param {number} id The ID of the element to complete or uncomplete\n * @param {object} checkbox The checkbox to check the state of complete\n *                          or not\n * @param {boolean|undefined} silent Prevent re-filtering the todo items\n */\nController.prototype.toggleComplete = function (id, completed, silent) {\n    var that = this;\n    that.model.update(id, { completed }, function () {\n        that.view.render(\"elementComplete\", {\n            id,\n            completed,\n        });\n    });\n\n    if (!silent) {\n        that._filter();\n    }\n};\n\n/**\n * Will toggle ALL checkboxes' on/off state and completeness of models.\n * Just pass in the event object.\n */\nController.prototype.toggleAll = function (completed) {\n    var that = this;\n    that.model.read({ completed: !completed }, function (data) {\n        data.forEach(function (item) {\n            that.toggleComplete(item.id, completed, true);\n        });\n    });\n\n    that._filter();\n};\n\n/**\n * Updates the pieces of the page which change depending on the remaining\n * number of todos.\n */\nController.prototype._updateCount = function () {\n    var that = this;\n    that.model.getCount(function (todos) {\n        that.view.render(\"updateElementCount\", todos.active);\n        that.view.render(\"clearCompletedButton\", {\n            completed: todos.completed,\n            visible: todos.completed > 0,\n        });\n\n        that.view.render(\"toggleAll\", { checked: todos.completed === todos.total });\n        that.view.render(\"contentBlockVisibility\", { visible: todos.total > 0 });\n    });\n};\n\n/**\n * Re-filters the todo items, based on the active route.\n * @param {boolean|undefined} force  forces a re-painting of todo items.\n */\nController.prototype._filter = function (force) {\n    var activeRoute = this._activeRoute.charAt(0).toUpperCase() + this._activeRoute.substr(1);\n\n    // Update the elements on the page, which change with each completed todo\n    this._updateCount();\n\n    // If the last active route isn't \"All\", or we're switching routes, we\n    // re-create the todo item elements, calling:\n    //   this.show[All|Active|Completed]();\n    if (force || this._lastActiveRoute !== \"All\" || this._lastActiveRoute !== activeRoute) {\n        this[`show${activeRoute}`]();\n    }\n\n    this._lastActiveRoute = activeRoute;\n};\n\n/**\n * Simply updates the filter nav's selected states\n */\nController.prototype._updateFilterState = function (currentPage) {\n    // Store a reference to the active route, allowing us to re-filter todo\n    // items as they are marked complete or incomplete.\n    currentPage = currentPage.split(\"?\")[0];\n    this._activeRoute = currentPage;\n\n    if (currentPage === \"\") {\n        this._activeRoute = \"All\";\n    }\n\n    this._filter();\n\n    this.view.render(\"setFilter\", currentPage);\n};\n","/**\n * Creates a new Model instance and hooks up the storage.\n * @constructor\n * @param {object} storage A reference to the client side storage class\n */\nclass Model {\n    constructor(storage) {\n        this.storage = storage;\n    }\n\n    /**\n     * Creates a new todo model\n     *\n     * @param {string} [title] The title of the task\n     * @param {function} [callback] The callback to fire after the model is created\n     */\n    create(title, callback) {\n        title = title || \"\";\n\n        let newItem = {\n            title: title.trim(),\n            completed: false,\n        };\n\n        this.storage.save(newItem, callback);\n    }\n\n    /**\n     * Finds and returns a model in storage. If no query is given it'll simply\n     * return everything. If you pass in a string or number it'll look that up as\n     * the ID of the model to find. Lastly, you can pass it an object to match\n     * against.\n     *\n     * @param {string|number|object} [query] A query to match models against\n     * @param {function} [callback] The callback to fire after the model is found\n     *\n     * @example\n     * model.read(1, func) // Will find the model with an ID of 1\n     * model.read('1') // Same as above\n     * //Below will find a model with foo equalling bar and hello equalling world.\n     * model.read({ foo: 'bar', hello: 'world' })\n     */\n    read(query, callback) {\n        const queryType = typeof query;\n\n        if (queryType === \"function\") {\n            callback = query;\n            this.storage.findAll(callback);\n        } else if (queryType === \"string\" || queryType === \"number\") {\n            query = parseInt(query, 10);\n            this.storage.find({ id: query }, callback);\n        } else {\n            this.storage.find(query, callback);\n        }\n    }\n\n    /**\n     * Updates a model by giving it an ID, data to update, and a callback to fire when\n     * the update is complete.\n     *\n     * @param {number} id The id of the model to update\n     * @param {object} data The properties to update and their new value\n     * @param {function} callback The callback to fire when the update is complete.\n     */\n    update(id, data, callback) {\n        this.storage.save(data, callback, id);\n    }\n\n    /**\n     * Removes a model from storage\n     *\n     * @param {number} id The ID of the model to remove\n     * @param {function} callback The callback to fire when the removal is complete.\n     */\n    remove(id, callback) {\n        this.storage.remove(id, callback);\n    }\n\n    /**\n     * WARNING: Will remove ALL data from storage.\n     *\n     * @param {function} callback The callback to fire when the storage is wiped.\n     */\n    removeAll(callback) {\n        this.storage.drop(callback);\n    }\n\n    /**\n     * Returns a count of all todos\n     */\n    getCount(callback) {\n        const todos = {\n            active: 0,\n            completed: 0,\n            total: 0,\n        };\n\n        this.storage.findAll((data) => {\n            for (let todo of data) {\n                if (todo.completed) {\n                    todos.completed++;\n                } else {\n                    todos.active++;\n                }\n\n                todos.total++;\n            }\n\n            if (callback) {\n                callback(todos);\n            }\n        });\n    }\n}\n\nexport default Model;\n","let uniqueID = 1;\n/* HOT MODULE SPECIFIC\n * Since hot reload blows away class instances, storage object is\n * moved outside of the class.\n */\nlet memoryStorage = {};\n\n/**\n * Creates a new client side storage object and will create an empty\n * collection if no collection already exists.\n *\n * @param {string} name The name of our DB we want to use\n * @param {function} callback Our fake DB uses callbacks because in\n * real life you probably would be making AJAX calls\n */\nexport class Store {\n    constructor(name, callback) {\n        this._dbName = name;\n\n        if (!memoryStorage[name]) {\n            let data = {\n                todos: [],\n            };\n\n            memoryStorage[name] = JSON.stringify(data);\n        }\n\n        if (callback) {\n            callback.call(this, JSON.parse(memoryStorage[name]));\n        }\n    }\n\n    /**\n     * Finds items based on a query given as a JS object\n     *\n     * @param {object} query The query to match against (i.e. {foo: 'bar'})\n     * @param {function} callback   The callback to fire when the query has\n     * completed running\n     *\n     * @example\n     * db.find({foo: 'bar', hello: 'world'}, function (data) {\n     *   // data will return any items that have foo: bar and\n     *   // hello: world in their properties\n     * })\n     */\n    find(query, callback) {\n        if (!callback) {\n            return;\n        }\n\n        const { todos } = JSON.parse(memoryStorage[this._dbName]);\n\n        callback.call(\n            this,\n            todos.filter((todo) => {\n                for (let q in query) {\n                    if (query[q] !== todo[q]) {\n                        return false;\n                    }\n                }\n                return true;\n            })\n        );\n    }\n\n    /**\n     * Will retrieve all data from the collection\n     *\n     * @param {function} callback The callback to fire upon retrieving data\n     */\n    findAll(callback) {\n        if (!callback) {\n            return;\n        }\n\n        callback.call(this, JSON.parse(memoryStorage[this._dbName]).todos);\n    }\n\n    /**\n     * Will save the given data to the DB. If no item exists it will create a new\n     * item, otherwise it'll simply update an existing item's properties\n     *\n     * @param {object} updateData The data to save back into the DB\n     * @param {function} callback The callback to fire after saving\n     * @param {number} id An optional param to enter an ID of an item to update\n     */\n    save(updateData, callback, id) {\n        const data = JSON.parse(memoryStorage[this._dbName]);\n        const { todos } = data;\n\n        // If an ID was actually given, find the item and update each property\n        if (id) {\n            for (let i = 0; i < todos.length; i++) {\n                if (todos[i].id === id) {\n                    for (let key in updateData) {\n                        todos[i][key] = updateData[key];\n                    }\n                    break;\n                }\n            }\n\n            memoryStorage[this._dbName] = JSON.stringify(data);\n\n            if (callback) {\n                callback.call(this, JSON.parse(memoryStorage[this._dbName]).todos);\n            }\n        } else {\n            // Generate an ID\n            updateData.id = uniqueID++;\n\n            todos.push(updateData);\n            memoryStorage[this._dbName] = JSON.stringify(data);\n\n            if (callback) {\n                callback.call(this, [updateData]);\n            }\n        }\n    }\n\n    /**\n     * Will remove an item from the Store based on its ID\n     *\n     * @param {number} id The ID of the item you want to remove\n     * @param {function} callback The callback to fire after saving\n     */\n    remove(id, callback) {\n        const data = JSON.parse(memoryStorage[this._dbName]);\n        const { todos } = data;\n\n        for (let i = 0; i < todos.length; i++) {\n            if (todos[i].id === id) {\n                todos.splice(i, 1);\n                break;\n            }\n        }\n\n        memoryStorage[this._dbName] = JSON.stringify(data);\n\n        if (callback) {\n            callback.call(this, JSON.parse(memoryStorage[this._dbName]).todos);\n        }\n    }\n\n    /**\n     * Will drop all storage and start fresh\n     *\n     * @param {function} callback The callback to fire after dropping the data\n     */\n    drop(callback) {\n        memoryStorage[this._dbName] = JSON.stringify({ todos: [] });\n\n        if (callback) {\n            callback.call(this, JSON.parse(memoryStorage[this._dbName]).todos);\n        }\n    }\n}\n\nexport default Store;\n","\"use strict\";\n\nconst htmlEscapes = {\n    \"&\": \"&amp\",\n    \"<\": \"&lt\",\n    \">\": \"&gt\",\n    '\"': \"&quot\",\n    \"'\": \"&#x27\",\n    \"`\": \"&#x60\",\n};\n\nconst reUnescapedHtml = /[&<>\"'`]/g;\nconst reHasUnescapedHtml = new RegExp(reUnescapedHtml.source);\n\nconst escape = (str) => str && reHasUnescapedHtml.test(str) ? str.replace(reUnescapedHtml, escapeHtmlChar) : str;\nconst escapeHtmlChar = (chr) => htmlEscapes[chr];\n\nclass Template {\n    constructor() {\n        this.defaultTemplate = `\n            <li data-id=\"{{id}}\" class=\"{{completed}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\" {{checked}}>\n                    <label>{{title}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n            </li>\n        `;\n    }\n\n    /**\n     * Creates an <li> HTML string and returns it for placement in your app.\n     *\n     * NOTE: In real life you should be using a templating engine such as Mustache\n     * or Handlebars, however, this is a vanilla JS example.\n     *\n     * @param {object} data The object containing keys you want to find in the\n     *                      template to replace.\n     * @returns {string} HTML String of an <li> element\n     *\n     * @example\n     * view.show({\n     *  id: 1,\n     *  title: \"Hello World\",\n     *  completed: 0,\n     * })\n     */\n    show(data) {\n        let view = \"\";\n        const len = data.length;\n\n        for (let i = 0; i < len; i++) {\n            let completed = \"\";\n            let checked = \"\";\n            let template = this.defaultTemplate;\n\n            if (data[i].completed) {\n                completed = \"completed\";\n                checked = \"checked\";\n            }\n\n            template = template.replace(\"{{id}}\", data[i].id);\n            template = template.replace(\"{{title}}\", escape(data[i].title));\n            template = template.replace(\"{{completed}}\", completed);\n            template = template.replace(\"{{checked}}\", checked);\n\n            view += template;\n        }\n\n        return view;\n    }\n\n    /**\n     * Displays a counter of how many to dos are left to complete\n     *\n     * @param {number} activeTodos The number of active todos.\n     * @returns {string} String containing the count\n     */\n    itemCounter(activeTodos) {\n        const plural = activeTodos === 1 ? \"\" : \"s\";\n        return `<strong>${activeTodos}</strong> item${plural} left`;\n    }\n\n    /**\n     * Updates the text within the \"Clear completed\" button\n     *\n     * @param  {[type]} completedTodos The number of completed todos.\n     * @returns {string} String containing the count\n     */\n    clearCompletedButton(completedTodos) {\n        return completedTodos > 0 ? \"Clear completed\" : \"\";\n    }\n}\n\nexport default Template;\n","import View from \"./view\";\nimport Controller from \"./controller\";\nimport Model from \"./model\";\nimport Store from \"./store\";\nimport Template from \"./template\";\n\nimport \"todomvc-app-css/index.css\";\nimport \"./app.css\";\n\nlet todo;\nconst onChange = () => {\n    todo.controller.setView(document.location.hash);\n};\n\nconst onLoad = () => {\n    todo = new Todo(\"javascript-es6-webpack\");\n    onChange();\n};\n\nfunction Todo(name) {\n    this.storage = new Store(name);\n    this.model = new Model(this.storage);\n    this.template = new Template();\n    this.view = new View(this.template);\n    this.controller = new Controller(this.model, this.view);\n}\n\n/* HOT MODULE SPECIFIC */\nif (module.hot) {\n    module.hot.accept(function (err) {});\n    if (document.readyState === \"complete\") {\n        onLoad();\n    }\n}\n\nwindow.addEventListener(\"load\", onLoad);\nwindow.addEventListener(\"hashchange\", onChange);\n"],"names":[],"sourceRoot":""}