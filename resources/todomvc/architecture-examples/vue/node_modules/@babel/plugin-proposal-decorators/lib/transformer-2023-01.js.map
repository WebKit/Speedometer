{"version":3,"names":["incrementId","id","idx","length","unshift","current","createPrivateUidGeneratorForClass","classPath","currentPrivateId","privateNames","Set","traverse","PrivateName","path","add","node","name","reifiedId","String","fromCharCode","has","t","privateName","identifier","createLazyPrivateUidGeneratorForClass","generator","replaceClassWithVar","type","varId","scope","generateUidIdentifierBasedOnNode","classId","rename","insertBefore","variableDeclaration","variableDeclarator","get","replaceWith","cloneNode","className","parent","generateDeclaredUidIdentifier","parentPath","newClassExpr","classExpression","superClass","body","newPath","sequenceExpression","generateClassProperty","key","value","isStatic","classPrivateProperty","undefined","classProperty","addProxyAccessorsFor","element","originalKey","targetKey","isComputed","static","getterBody","blockStatement","returnStatement","memberExpression","thisExpression","setterBody","expressionStatement","assignmentExpression","getter","setter","classPrivateMethod","classMethod","insertAfter","extractProxyAccessorsFor","version","template","expression","ast","FIELD","ACCESSOR","METHOD","GETTER","SETTER","STATIC","getElementKind","kind","isDecoratorInfo","info","filteredOrderedDecoratorInfo","filtered","filter","el","generateDecorationExprs","arrayExpression","map","decs","decorators","numericLiteral","privateMethods","extractElementLocalAssignments","decorationInfo","localIds","locals","Array","isArray","push","addCallAccessorsFor","getId","setId","callExpression","isNotTsParameter","movePrivateAccessor","methodLocalVar","params","block","isClassDecoratableElementPath","staticBlockToIIFE","arrowFunctionExpression","maybeSequenceExpression","exprs","unaryExpression","transformClass","state","constantSuper","classDecorators","hasElementDecorators","generateClassPrivateUid","computed","newId","valueNode","newField","elementDecoratorInfo","firstFieldPath","constructorPath","requiresProtoInit","requiresStaticInit","decoratedPrivateMethods","protoInitLocal","staticInitLocal","classInitLocal","classIdLocal","assignments","scopeParent","memoiseExpression","hint","localEvaluatedId","classDecorator","generateUidIdentifier","lastInstancePrivateName","needsInstancePrivateBrandCheck","hasDecorators","decoratorPath","isPrivate","isClassPrivateProperty","isClassMethod","newFieldInitId","newValue","initId","valuePath","v","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","file","refToPreserve","replace","async","isAsync","functionExpression","remove","nameExpr","stringLiteral","d","elementDecorations","classDecorations","elementLocals","protoInitCall","CallExpression","exit","isSuper","skip","super","spreadElement","restElement","size","parentParentPath","left","buildCodeFrameError","classLocals","classInitInjected","classInitCall","originalClass","statics","staticBlocks","forEach","isStaticBlock","isProperty","isClassProperty","isClassPrivateMethod","allValues","staticsClass","addHelper","staticBlock","toStatement","constructorBody","newExpr","newExpression","arguments","createLocalsAssignment","Boolean","expr","crawl","maybePrivateBranName","lhs","rhs","args","availableHelper","arrayPattern","objectPattern","objectProperty","assertVersion","assumption","loose","VISITED","WeakSet","inherits","syntaxDecorators","visitor","declaration","splitExportDeclaration","Class"],"sources":["../src/transformer-2023-01.ts"],"sourcesContent":["import type { NodePath, Scope } from \"@babel/traverse\";\nimport { types as t, template } from \"@babel/core\";\nimport syntaxDecorators from \"@babel/plugin-syntax-decorators\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport * as charCodes from \"charcodes\";\nimport type { PluginAPI, PluginObject, PluginPass } from \"@babel/core\";\nimport type { Options } from \"./index\";\n\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty;\n\ntype ClassElement =\n  | ClassDecoratableElement\n  | t.TSDeclareMethod\n  | t.TSIndexSignature\n  | t.StaticBlock;\n\ntype DecoratorVersionKind = \"2023-01\" | \"2022-03\" | \"2021-12\";\n\nfunction incrementId(id: number[], idx = id.length - 1): void {\n  // If index is -1, id needs an additional character, unshift A\n  if (idx === -1) {\n    id.unshift(charCodes.uppercaseA);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === charCodes.uppercaseZ) {\n    // if current is Z, skip to a\n    id[idx] = charCodes.lowercaseA;\n  } else if (current === charCodes.lowercaseZ) {\n    // if current is z, reset to A and carry the 1\n    id[idx] = charCodes.uppercaseA;\n    incrementId(id, idx - 1);\n  } else {\n    // else, increment by one\n    id[idx] = current + 1;\n  }\n}\n\n/**\n * Generates a new private name that is unique to the given class. This can be\n * used to create extra class fields and methods for the implementation, while\n * keeping the length of those names as small as possible. This is important for\n * minification purposes (though private names can generally be minified,\n * transpilations and polyfills cannot yet).\n */\nfunction createPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  const currentPrivateId: number[] = [];\n  const privateNames = new Set<string>();\n\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    },\n  });\n\n  return (): t.PrivateName => {\n    let reifiedId;\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return t.privateName(t.identifier(reifiedId));\n  };\n}\n\n/**\n * Wraps the above generator function so that it's run lazily the first time\n * it's actually required. Several types of decoration do not require this, so it\n * saves iterating the class elements an additional time and allocating the space\n * for the Sets of element names.\n */\nfunction createLazyPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  let generator: () => t.PrivateName;\n\n  return (): t.PrivateName => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\n/**\n * Takes a class definition and replaces it with an equivalent class declaration\n * which is then assigned to a local variable. This allows us to reassign the\n * local variable with the decorated version of the class. The class definition\n * retains its original name so that `toString` is not affected, other\n * references to the class are renamed instead.\n */\nfunction replaceClassWithVar(\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): [t.Identifier, NodePath<t.ClassDeclaration | t.ClassExpression>] {\n  if (path.type === \"ClassDeclaration\") {\n    const varId = path.scope.generateUidIdentifierBasedOnNode(path.node.id);\n    const classId = t.identifier(path.node.id.name);\n\n    path.scope.rename(classId.name, varId.name);\n\n    path.insertBefore(\n      t.variableDeclaration(\"let\", [t.variableDeclarator(varId)]),\n    );\n    path.get(\"id\").replaceWith(classId);\n\n    return [t.cloneNode(varId), path];\n  } else {\n    let className: string;\n    let varId: t.Identifier;\n\n    if (path.node.id) {\n      className = path.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n      path.scope.rename(className, varId.name);\n    } else if (\n      path.parentPath.node.type === \"VariableDeclarator\" &&\n      path.parentPath.node.id.type === \"Identifier\"\n    ) {\n      className = path.parentPath.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n    } else {\n      varId =\n        path.scope.parent.generateDeclaredUidIdentifier(\"decorated_class\");\n    }\n\n    const newClassExpr = t.classExpression(\n      className && t.identifier(className),\n      path.node.superClass,\n      path.node.body,\n    );\n\n    const [newPath] = path.replaceWith(\n      t.sequenceExpression([newClassExpr, varId]),\n    );\n\n    return [\n      t.cloneNode(varId),\n      newPath.get(\"expressions.0\") as NodePath<t.ClassExpression>,\n    ];\n  }\n}\n\nfunction generateClassProperty(\n  key: t.PrivateName | t.Identifier,\n  value: t.Expression | undefined,\n  isStatic: boolean,\n): t.ClassPrivateProperty | t.ClassProperty {\n  if (key.type === \"PrivateName\") {\n    return t.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return t.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction addProxyAccessorsFor(\n  element: NodePath<ClassDecoratableElement>,\n  originalKey: t.PrivateName | t.Expression,\n  targetKey: t.PrivateName,\n  isComputed = false,\n): void {\n  const { static: isStatic } = element.node;\n\n  const getterBody = t.blockStatement([\n    t.returnStatement(\n      t.memberExpression(t.thisExpression(), t.cloneNode(targetKey)),\n    ),\n  ]);\n\n  const setterBody = t.blockStatement([\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(t.thisExpression(), t.cloneNode(targetKey)),\n        t.identifier(\"v\"),\n      ),\n    ),\n  ]);\n\n  let getter: t.ClassMethod | t.ClassPrivateMethod,\n    setter: t.ClassMethod | t.ClassPrivateMethod;\n\n  if (originalKey.type === \"PrivateName\") {\n    getter = t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(originalKey),\n      [],\n      getterBody,\n      isStatic,\n    );\n    setter = t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(originalKey),\n      [t.identifier(\"v\")],\n      setterBody,\n      isStatic,\n    );\n  } else {\n    getter = t.classMethod(\n      \"get\",\n      t.cloneNode(originalKey),\n      [],\n      getterBody,\n      isComputed,\n      isStatic,\n    );\n    setter = t.classMethod(\n      \"set\",\n      t.cloneNode(originalKey),\n      [t.identifier(\"v\")],\n      setterBody,\n      isComputed,\n      isStatic,\n    );\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(\n  targetKey: t.PrivateName,\n  version: DecoratorVersionKind,\n): (t.FunctionExpression | t.ArrowFunctionExpression)[] {\n  if (version !== \"2023-01\") {\n    return [\n      template.expression.ast`\n        function () {\n          return this.${t.cloneNode(targetKey)};\n        }\n      ` as t.FunctionExpression,\n      template.expression.ast`\n        function (value) {\n          this.${t.cloneNode(targetKey)} = value;\n        }\n      ` as t.FunctionExpression,\n    ];\n  }\n  return [\n    template.expression.ast`\n      o => o.${t.cloneNode(targetKey)}\n    ` as t.ArrowFunctionExpression,\n    template.expression.ast`\n      (o, v) => o.${t.cloneNode(targetKey)} = v\n    ` as t.ArrowFunctionExpression,\n  ];\n}\n\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\n\nconst STATIC = 5;\n\nfunction getElementKind(element: NodePath<ClassDecoratableElement>): number {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n  }\n}\n\n// Information about the decorators applied to an element\ninterface DecoratorInfo {\n  // The expressions of the decorators themselves\n  decorators: t.Expression[];\n\n  // The kind of the decorated value, matches the kind value passed to applyDecs\n  kind: number;\n\n  // whether or not the field is static\n  isStatic: boolean;\n\n  // The name of the decorator\n  name: t.StringLiteral | t.Expression;\n\n  privateMethods:\n    | (t.FunctionExpression | t.ArrowFunctionExpression)[]\n    | undefined;\n\n  // The names of local variables that will be used/returned from the decoration\n  locals: t.Identifier | t.Identifier[] | undefined;\n}\n\n// Information about a computed property key. These must be evaluated\n// interspersed with decorator expressions, which is why they get added to the\n// array of DecoratorInfos later on.\ninterface ComputedPropInfo {\n  localComputedNameId: t.Identifier;\n  keyNode: t.Expression;\n}\n\nfunction isDecoratorInfo(\n  info: DecoratorInfo | ComputedPropInfo,\n): info is DecoratorInfo {\n  return \"decorators\" in info;\n}\n\nfunction filteredOrderedDecoratorInfo(\n  info: (DecoratorInfo | ComputedPropInfo)[],\n): DecoratorInfo[] {\n  const filtered = info.filter(isDecoratorInfo);\n\n  return [\n    ...filtered.filter(\n      el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...filtered.filter(\n      el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...filtered.filter(el => el.isStatic && el.kind === FIELD),\n    ...filtered.filter(el => !el.isStatic && el.kind === FIELD),\n  ];\n}\n\nfunction generateDecorationExprs(\n  info: (DecoratorInfo | ComputedPropInfo)[],\n): t.ArrayExpression {\n  return t.arrayExpression(\n    filteredOrderedDecoratorInfo(info).map(el => {\n      const decs =\n        el.decorators.length > 1\n          ? t.arrayExpression(el.decorators)\n          : el.decorators[0];\n\n      const kind = el.isStatic ? el.kind + STATIC : el.kind;\n\n      return t.arrayExpression([\n        decs,\n        t.numericLiteral(kind),\n        el.name,\n        ...(el.privateMethods || []),\n      ]);\n    }),\n  );\n}\n\nfunction extractElementLocalAssignments(\n  decorationInfo: (DecoratorInfo | ComputedPropInfo)[],\n) {\n  const localIds: t.Identifier[] = [];\n\n  for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {\n    const { locals } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(\n  element: NodePath,\n  key: t.PrivateName,\n  getId: t.Identifier,\n  setId: t.Identifier,\n) {\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(key),\n      [],\n      t.blockStatement([\n        t.returnStatement(\n          t.callExpression(t.cloneNode(getId), [t.thisExpression()]),\n        ),\n      ]),\n    ),\n  );\n\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(key),\n      [t.identifier(\"v\")],\n      t.blockStatement([\n        t.expressionStatement(\n          t.callExpression(t.cloneNode(setId), [\n            t.thisExpression(),\n            t.identifier(\"v\"),\n          ]),\n        ),\n      ]),\n    ),\n  );\n}\n\nfunction isNotTsParameter(\n  node: t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty,\n): node is t.Identifier | t.Pattern | t.RestElement {\n  return node.type !== \"TSParameterProperty\";\n}\n\nfunction movePrivateAccessor(\n  element: NodePath<t.ClassPrivateMethod>,\n  key: t.PrivateName,\n  methodLocalVar: t.Identifier,\n  isStatic: boolean,\n) {\n  let params: (t.Identifier | t.RestElement)[];\n  let block: t.Statement[];\n\n  if (element.node.kind === \"set\") {\n    params = [t.identifier(\"v\")];\n    block = [\n      t.expressionStatement(\n        t.callExpression(methodLocalVar, [\n          t.thisExpression(),\n          t.identifier(\"v\"),\n        ]),\n      ),\n    ];\n  } else {\n    params = [];\n    block = [\n      t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),\n    ];\n  }\n\n  element.replaceWith(\n    t.classPrivateMethod(\n      element.node.kind,\n      t.cloneNode(key),\n      params,\n      t.blockStatement(block),\n      isStatic,\n    ),\n  );\n}\n\nfunction isClassDecoratableElementPath(\n  path: NodePath<ClassElement>,\n): path is NodePath<ClassDecoratableElement> {\n  const { type } = path;\n\n  return (\n    type !== \"TSDeclareMethod\" &&\n    type !== \"TSIndexSignature\" &&\n    type !== \"StaticBlock\"\n  );\n}\n\nfunction staticBlockToIIFE(block: t.StaticBlock) {\n  return t.callExpression(\n    t.arrowFunctionExpression([], t.blockStatement(block.body)),\n    [],\n  );\n}\n\nfunction maybeSequenceExpression(exprs: t.Expression[]) {\n  if (exprs.length === 0) return t.unaryExpression(\"void\", t.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return t.sequenceExpression(exprs);\n}\n\nfunction transformClass(\n  path: NodePath<t.ClassExpression | t.ClassDeclaration>,\n  state: PluginPass,\n  constantSuper: boolean,\n  version: DecoratorVersionKind,\n): NodePath {\n  const body = path.get(\"body.body\");\n\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  // Iterate over the class to see if we need to decorate it, and also to\n  // transform simple auto accessors which are not decorated\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    if (element.node.decorators && element.node.decorators.length > 0) {\n      hasElementDecorators = true;\n    } else if (element.node.type === \"ClassAccessorProperty\") {\n      const { key, value, static: isStatic, computed } = element.node;\n\n      const newId = generateClassPrivateUid();\n\n      const valueNode = value ? t.cloneNode(value) : undefined;\n\n      const newField = generateClassProperty(newId, valueNode, isStatic);\n\n      const [newPath] = element.replaceWith(newField);\n      addProxyAccessorsFor(newPath, key, newId, computed);\n    }\n  }\n\n  // If nothing is decorated, return\n  if (!classDecorators && !hasElementDecorators) return;\n\n  const elementDecoratorInfo: (DecoratorInfo | ComputedPropInfo)[] = [];\n\n  // The initializer of the first non-static field will be injected with the protoInit call\n  let firstFieldPath:\n    | NodePath<t.ClassProperty | t.ClassPrivateProperty>\n    | undefined;\n  let constructorPath: NodePath<t.ClassMethod> | undefined;\n  let requiresProtoInit = false;\n  let requiresStaticInit = false;\n  const decoratedPrivateMethods = new Set<string>();\n\n  let protoInitLocal: t.Identifier,\n    staticInitLocal: t.Identifier,\n    classInitLocal: t.Identifier,\n    classIdLocal: t.Identifier;\n  const assignments: t.AssignmentExpression[] = [];\n  const scopeParent: Scope = path.scope.parent;\n\n  const memoiseExpression = (expression: t.Expression, hint: string) => {\n    const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);\n    assignments.push(t.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return t.cloneNode(localEvaluatedId);\n  };\n\n  if (classDecorators) {\n    classInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initClass\");\n\n    const [classId, classPath] = replaceClassWithVar(path);\n    path = classPath;\n    classIdLocal = classId;\n\n    path.node.decorators = null;\n\n    for (const classDecorator of classDecorators) {\n      if (!scopeParent.isStatic(classDecorator.expression)) {\n        classDecorator.expression = memoiseExpression(\n          classDecorator.expression,\n          \"dec\",\n        );\n      }\n    }\n  } else {\n    if (!path.node.id) {\n      path.node.id = path.scope.generateUidIdentifier(\"Class\");\n    }\n    classIdLocal = t.cloneNode(path.node.id);\n  }\n\n  let lastInstancePrivateName: t.PrivateName;\n  let needsInstancePrivateBrandCheck = false;\n\n  if (hasElementDecorators) {\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        continue;\n      }\n\n      const { node } = element;\n      const decorators = element.get(\"decorators\");\n\n      const hasDecorators = Array.isArray(decorators) && decorators.length > 0;\n\n      if (hasDecorators) {\n        for (const decoratorPath of decorators) {\n          if (!scopeParent.isStatic(decoratorPath.node.expression)) {\n            decoratorPath.node.expression = memoiseExpression(\n              decoratorPath.node.expression,\n              \"dec\",\n            );\n          }\n        }\n      }\n\n      const isComputed =\n        \"computed\" in element.node && element.node.computed === true;\n      if (isComputed) {\n        if (!scopeParent.isStatic(node.key)) {\n          node.key = memoiseExpression(node.key as t.Expression, \"computedKey\");\n        }\n      }\n\n      const kind = getElementKind(element);\n      const { key } = node;\n\n      const isPrivate = key.type === \"PrivateName\";\n\n      const isStatic = !!element.node.static;\n\n      let name = \"computedKey\";\n\n      if (isPrivate) {\n        name = key.id.name;\n      } else if (!isComputed && key.type === \"Identifier\") {\n        name = key.name;\n      }\n\n      if (isPrivate && !isStatic) {\n        if (hasDecorators) {\n          needsInstancePrivateBrandCheck = true;\n        }\n        if (t.isClassPrivateProperty(node) || !lastInstancePrivateName) {\n          lastInstancePrivateName = key;\n        }\n      }\n\n      if (element.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = element;\n      }\n\n      if (hasDecorators) {\n        let locals: t.Identifier | t.Identifier[];\n        let privateMethods: Array<\n          t.FunctionExpression | t.ArrowFunctionExpression\n        >;\n\n        if (kind === ACCESSOR) {\n          const { value } = element.node as t.ClassAccessorProperty;\n\n          const params: t.Expression[] = [t.thisExpression()];\n\n          if (value) {\n            params.push(t.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId =\n            element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n          const newValue = t.callExpression(\n            t.cloneNode(newFieldInitId),\n            params,\n          );\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId, version);\n\n            const getId = newPath.scope.parent.generateDeclaredUidIdentifier(\n              `get_${name}`,\n            );\n            const setId = newPath.scope.parent.generateDeclaredUidIdentifier(\n              `set_${name}`,\n            );\n\n            addCallAccessorsFor(newPath, key, getId, setId);\n\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            addProxyAccessorsFor(newPath, key, newId, isComputed);\n            locals = newFieldInitId;\n          }\n        } else if (kind === FIELD) {\n          const initId = element.scope.parent.generateDeclaredUidIdentifier(\n            `init_${name}`,\n          );\n          const valuePath = (\n            element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n          ).get(\"value\");\n\n          valuePath.replaceWith(\n            t.callExpression(\n              t.cloneNode(initId),\n              [t.thisExpression(), valuePath.node].filter(v => v),\n            ),\n          );\n\n          locals = initId;\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key, version);\n          }\n        } else if (isPrivate) {\n          locals = element.scope.parent.generateDeclaredUidIdentifier(\n            `call_${name}`,\n          );\n\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element as NodePath<t.ClassPrivateMethod>,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal,\n          });\n\n          replaceSupers.replace();\n\n          const {\n            params,\n            body,\n            async: isAsync,\n          } = element.node as t.ClassPrivateMethod;\n\n          privateMethods = [\n            t.functionExpression(\n              undefined,\n              params.filter(isNotTsParameter),\n              body,\n              isAsync,\n            ),\n          ];\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(\n              element as NodePath<t.ClassPrivateMethod>,\n              t.cloneNode(key),\n              t.cloneNode(locals),\n              isStatic,\n            );\n          } else {\n            const node = element.node as t.ClassPrivateMethod;\n\n            // Unshift\n            path.node.body.body.unshift(\n              t.classPrivateProperty(key, t.cloneNode(locals), [], node.static),\n            );\n\n            decoratedPrivateMethods.add(key.id.name);\n\n            element.remove();\n          }\n        }\n\n        let nameExpr: t.Expression;\n\n        if (isComputed) {\n          nameExpr = t.cloneNode(key as t.Expression);\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = t.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = t.stringLiteral(key.name);\n        } else {\n          nameExpr = t.cloneNode(key as t.Expression);\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decorators: decorators.map(d => d.node.expression),\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals,\n        });\n\n        if (kind !== FIELD) {\n          if (isStatic) {\n            requiresStaticInit = true;\n          } else {\n            requiresProtoInit = true;\n          }\n        }\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n\n        if (\n          !firstFieldPath &&\n          !isStatic &&\n          (kind === FIELD || kind === ACCESSOR)\n        ) {\n          firstFieldPath = element as NodePath<\n            t.ClassProperty | t.ClassPrivateProperty\n          >;\n        }\n      }\n    }\n  }\n\n  const elementDecorations = generateDecorationExprs(elementDecoratorInfo);\n  const classDecorations = t.arrayExpression(\n    (classDecorators || []).map(d => d.expression),\n  );\n\n  const elementLocals: t.Identifier[] =\n    extractElementLocalAssignments(elementDecoratorInfo);\n\n  if (requiresProtoInit) {\n    protoInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initProto\");\n    elementLocals.push(protoInitLocal);\n\n    const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [\n      t.thisExpression(),\n    ]);\n\n    if (firstFieldPath) {\n      const value = firstFieldPath.get(\"value\");\n      const body: t.Expression[] = [protoInitCall];\n\n      if (value.node) {\n        body.push(value.node);\n      }\n\n      value.replaceWith(t.sequenceExpression(body));\n    } else if (constructorPath) {\n      if (path.node.superClass) {\n        path.traverse({\n          CallExpression: {\n            exit(path) {\n              if (!path.get(\"callee\").isSuper()) return;\n\n              path.replaceWith(\n                t.callExpression(t.cloneNode(protoInitLocal), [path.node]),\n              );\n\n              path.skip();\n            },\n          },\n        });\n      } else {\n        constructorPath.node.body.body.unshift(\n          t.expressionStatement(protoInitCall),\n        );\n      }\n    } else {\n      const body: t.Statement[] = [t.expressionStatement(protoInitCall)];\n\n      if (path.node.superClass) {\n        body.unshift(\n          t.expressionStatement(\n            t.callExpression(t.super(), [\n              t.spreadElement(t.identifier(\"args\")),\n            ]),\n          ),\n        );\n      }\n\n      path.node.body.body.unshift(\n        t.classMethod(\n          \"constructor\",\n          t.identifier(\"constructor\"),\n          [t.restElement(t.identifier(\"args\"))],\n          t.blockStatement(body),\n        ),\n      );\n    }\n  }\n\n  if (requiresStaticInit) {\n    staticInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initStatic\");\n    elementLocals.push(staticInitLocal);\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    path.traverse({\n      PrivateName(path) {\n        if (!decoratedPrivateMethods.has(path.node.id.name)) return;\n\n        const parentPath = path.parentPath;\n        const parentParentPath = parentPath.parentPath;\n\n        if (\n          // this.bar().#x = 123;\n          (parentParentPath.node.type === \"AssignmentExpression\" &&\n            parentParentPath.node.left === parentPath.node) ||\n          // this.#x++;\n          parentParentPath.node.type === \"UpdateExpression\" ||\n          // ([...this.#x] = foo);\n          parentParentPath.node.type === \"RestElement\" ||\n          // ([this.#x] = foo);\n          parentParentPath.node.type === \"ArrayPattern\" ||\n          // ({ a: this.#x } = bar);\n          (parentParentPath.node.type === \"ObjectProperty\" &&\n            parentParentPath.node.value === parentPath.node &&\n            parentParentPath.parentPath.type === \"ObjectPattern\") ||\n          // for (this.#x of []);\n          (parentParentPath.node.type === \"ForOfStatement\" &&\n            parentParentPath.node.left === parentPath.node)\n        ) {\n          throw path.buildCodeFrameError(\n            `Decorated private methods are not updatable, but \"#${path.node.id.name}\" is updated via this expression.`,\n          );\n        }\n      },\n    });\n  }\n\n  const classLocals: t.Identifier[] = [];\n  let classInitInjected = false;\n  const classInitCall =\n    classInitLocal && t.callExpression(t.cloneNode(classInitLocal), []);\n\n  const originalClass = path.node;\n\n  if (classDecorators) {\n    classLocals.push(classIdLocal, classInitLocal);\n    const statics: (\n      | t.ClassProperty\n      | t.ClassPrivateProperty\n      | t.ClassPrivateMethod\n    )[] = [];\n    let staticBlocks: t.StaticBlock[] = [];\n    path.get(\"body.body\").forEach(element => {\n      // Static blocks cannot be compiled to \"instance blocks\", but we can inline\n      // them as IIFEs in the next property.\n      if (element.isStaticBlock()) {\n        staticBlocks.push(element.node);\n        element.remove();\n        return;\n      }\n\n      const isProperty =\n        element.isClassProperty() || element.isClassPrivateProperty();\n\n      if (\n        (isProperty || element.isClassPrivateMethod()) &&\n        element.node.static\n      ) {\n        if (isProperty && staticBlocks.length > 0) {\n          const allValues: t.Expression[] = staticBlocks.map(staticBlockToIIFE);\n          if (element.node.value) allValues.push(element.node.value);\n          element.node.value = maybeSequenceExpression(allValues);\n          staticBlocks = [];\n        }\n\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticBlocks.length > 0) {\n      const staticsClass = template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      ` as t.ClassExpression;\n      staticsClass.body.body = [\n        t.staticBlock([\n          t.toStatement(originalClass, true) ||\n            // If toStatement returns false, originalClass must be an anonymous ClassExpression,\n            // because `export default @dec ...` has been handled in the export visitor before.\n            t.expressionStatement(originalClass as t.ClassExpression),\n        ]),\n        ...statics,\n      ];\n\n      const constructorBody: t.Expression[] = [];\n\n      const newExpr = t.newExpression(staticsClass, []);\n\n      if (staticBlocks.length > 0) {\n        constructorBody.push(...staticBlocks.map(staticBlockToIIFE));\n      }\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(\n          t.callExpression(t.super(), [t.cloneNode(classIdLocal)]),\n        );\n\n        staticsClass.body.body.push(\n          t.classMethod(\n            \"constructor\",\n            t.identifier(\"constructor\"),\n            [],\n            t.blockStatement([\n              t.expressionStatement(t.sequenceExpression(constructorBody)),\n            ]),\n          ),\n        );\n      } else {\n        newExpr.arguments.push(t.cloneNode(classIdLocal));\n      }\n\n      path.replaceWith(newExpr);\n    }\n  }\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(\n      t.staticBlock([t.expressionStatement(classInitCall)]),\n    );\n  }\n\n  originalClass.body.body.unshift(\n    t.staticBlock(\n      [\n        t.expressionStatement(\n          createLocalsAssignment(\n            elementLocals,\n            classLocals,\n            elementDecorations,\n            classDecorations,\n            needsInstancePrivateBrandCheck ? lastInstancePrivateName : null,\n            state,\n            version,\n          ),\n        ),\n        requiresStaticInit &&\n          t.expressionStatement(\n            t.callExpression(t.cloneNode(staticInitLocal), [\n              t.thisExpression(),\n            ]),\n          ),\n      ].filter(Boolean),\n    ),\n  );\n\n  // When path is a ClassExpression, path.insertBefore will convert `path`\n  // into a SequenceExpression\n  path.insertBefore(assignments.map(expr => t.expressionStatement(expr)));\n\n  // Recrawl the scope to make sure new identifiers are properly synced\n  path.scope.crawl();\n\n  return path;\n}\n\nfunction createLocalsAssignment(\n  elementLocals: t.Identifier[],\n  classLocals: t.Identifier[],\n  elementDecorations: t.ArrayExpression,\n  classDecorations: t.ArrayExpression,\n  maybePrivateBranName: t.PrivateName | null,\n  state: PluginPass,\n  version: DecoratorVersionKind,\n) {\n  let lhs, rhs;\n  const args: t.Expression[] = [\n    t.thisExpression(),\n    elementDecorations,\n    classDecorations,\n  ];\n  // TODO(Babel 8): Only keep the else branch\n  if (\n    version === \"2021-12\" ||\n    (version === \"2022-03\" && !state.availableHelper(\"applyDecs2203R\"))\n  ) {\n    lhs = t.arrayPattern([...elementLocals, ...classLocals]);\n    rhs = t.callExpression(\n      state.addHelper(version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\"),\n      args,\n    );\n  } else {\n    // TODO(Babel 8): Only keep the if branch\n    if (version === \"2023-01\") {\n      if (maybePrivateBranName) {\n        args.push(\n          template.expression.ast`\n            _ => ${t.cloneNode(maybePrivateBranName)} in _\n          ` as t.ArrowFunctionExpression,\n        );\n      }\n      rhs = t.callExpression(state.addHelper(\"applyDecs2301\"), args);\n    } else {\n      rhs = t.callExpression(state.addHelper(\"applyDecs2203R\"), args);\n    }\n    // optimize `{ c: [classLocals] } = applyapplyDecs2203R(...)` to\n    // `[classLocals] = applyapplyDecs2203R(...).c`\n    if (elementLocals.length > 0) {\n      if (classLocals.length > 0) {\n        lhs = t.objectPattern([\n          t.objectProperty(t.identifier(\"e\"), t.arrayPattern(elementLocals)),\n          t.objectProperty(t.identifier(\"c\"), t.arrayPattern(classLocals)),\n        ]);\n      } else {\n        lhs = t.arrayPattern(elementLocals);\n        rhs = t.memberExpression(rhs, t.identifier(\"e\"), false, false);\n      }\n    } else {\n      // invariant: classLocals.length > 0\n      lhs = t.arrayPattern(classLocals);\n      rhs = t.memberExpression(rhs, t.identifier(\"c\"), false, false);\n    }\n  }\n  return t.assignmentExpression(\"=\", lhs, rhs);\n}\n\nexport default function (\n  { assertVersion, assumption }: PluginAPI,\n  { loose }: Options,\n  version: \"2023-01\" | \"2022-03\" | \"2021-12\",\n): PluginObject {\n  if (version === \"2023-01\") {\n    assertVersion(\"^7.21.0\");\n  } else if (version === \"2021-12\") {\n    assertVersion(\"^7.16.0\");\n  } else {\n    assertVersion(\"^7.19.0\");\n  }\n\n  const VISITED = new WeakSet<NodePath>();\n  const constantSuper = assumption(\"constantSuper\") ?? loose;\n\n  return {\n    name: \"proposal-decorators\",\n    inherits: syntaxDecorators,\n\n    visitor: {\n      \"ExportNamedDeclaration|ExportDefaultDeclaration\"(\n        path: NodePath<t.ExportNamedDeclaration | t.ExportDefaultDeclaration>,\n      ) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          declaration.decorators?.length > 0\n        ) {\n          splitExportDeclaration(path);\n        }\n      },\n\n      Class(path, state) {\n        if (VISITED.has(path)) return;\n\n        const newPath = transformClass(path, state, constantSuper, version);\n        if (newPath) VISITED.add(newPath);\n      },\n    },\n  };\n}\n"],"mappings":"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"}