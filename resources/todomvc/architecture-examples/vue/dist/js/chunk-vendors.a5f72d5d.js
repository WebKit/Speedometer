(self.webpackChunktodomvc_vue=self.webpackChunktodomvc_vue||[]).push([[998],{9662:function(module,__unused_webpack_exports,__webpack_require__){eval("var isCallable = __webpack_require__(614);\nvar tryToString = __webpack_require__(6330);\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + ' is not a function');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxHQUEwQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxJQUE0Qjs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzPzQ5YjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9662\n")},9670:function(module,__unused_webpack_exports,__webpack_require__){eval("var isObject = __webpack_require__(111);\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY3MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsR0FBd0I7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanM/MTdjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9670\n")},1318:function(module,__unused_webpack_exports,__webpack_require__){eval("var toIndexedObject = __webpack_require__(5656);\nvar toAbsoluteIndex = __webpack_require__(1400);\nvar lengthOfArrayLike = __webpack_require__(6244);\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFnQztBQUM5RCxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFnQztBQUM5RCx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFtQzs7QUFFbkUsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxnQkFBZ0I7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzPzQ2NzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1318\n")},3658:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\nvar DESCRIPTORS = __webpack_require__(9781);\nvar isArray = __webpack_require__(3157);\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nmodule.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {\n    throw $TypeError('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGtCQUFrQixtQkFBTyxDQUFDLElBQTBCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxJQUF1Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQkFBaUI7QUFDM0QsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zZXQtbGVuZ3RoLmpzPzQ2NjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBTYWZhcmkgPCAxMyBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpbiB0aGlzIGNhc2VcbnZhciBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPSBERVNDUklQVE9SUyAmJiAhZnVuY3Rpb24gKCkge1xuICAvLyBtYWtlcyBubyBzZW5zZSB3aXRob3V0IHByb3BlciBzdHJpY3QgbW9kZSBzdXBwb3J0XG4gIGlmICh0aGlzICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLmxlbmd0aCA9IDE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0lMRU5UX09OX05PTl9XUklUQUJMRV9MRU5HVEhfU0VUID8gZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICBpZiAoaXNBcnJheShPKSAmJiAhZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sICdsZW5ndGgnKS53cml0YWJsZSkge1xuICAgIHRocm93ICRUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgcmVhZCBvbmx5IC5sZW5ndGgnKTtcbiAgfSByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59IDogZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3658\n")},4326:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQzs7QUFFOUQsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcz84ZGJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmcoaXQpLCA4LCAtMSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4326\n")},9920:function(module,__unused_webpack_exports,__webpack_require__){eval("var hasOwn = __webpack_require__(2597);\nvar ownKeys = __webpack_require__(3887);\nvar getOwnPropertyDescriptorModule = __webpack_require__(1236);\nvar definePropertyModule = __webpack_require__(3070);\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkyMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBK0I7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLElBQXVCO0FBQzdDLHFDQUFxQyxtQkFBTyxDQUFDLElBQWlEO0FBQzlGLDJCQUEyQixtQkFBTyxDQUFDLElBQXFDOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcz80NjhhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24oZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9920\n")},8880:function(module,__unused_webpack_exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(9781);\nvar definePropertyModule = __webpack_require__(3070);\nvar createPropertyDescriptor = __webpack_require__(9114);\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRCwyQkFBMkIsbUJBQU8sQ0FBQyxJQUFxQztBQUN4RSwrQkFBK0IsbUJBQU8sQ0FBQyxJQUF5Qzs7QUFFaEY7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzPzllNmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8880\n")},9114:function(module){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTExNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzFjZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9114\n")},8052:function(module,__unused_webpack_exports,__webpack_require__){eval("var isCallable = __webpack_require__(614);\nvar definePropertyModule = __webpack_require__(3070);\nvar makeBuiltIn = __webpack_require__(6339);\nvar defineGlobalProperty = __webpack_require__(3072);\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxHQUEwQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyxJQUFxQztBQUN4RSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUE0QjtBQUN0RCwyQkFBMkIsbUJBQU8sQ0FBQyxJQUFxQzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcz8xMTcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIG1ha2VCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8052\n")},3072:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxrREFBa0Q7QUFDcEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanM/YmI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3072\n")},5117:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\nvar tryToString = __webpack_require__(6330);\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (O, P) {\n  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTExNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGtCQUFrQixtQkFBTyxDQUFDLElBQTRCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVsZXRlLXByb3BlcnR5LW9yLXRocm93LmpzPzliMDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIFApIHtcbiAgaWYgKCFkZWxldGUgT1tQXSkgdGhyb3cgJFR5cGVFcnJvcignQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0eSAnICsgdHJ5VG9TdHJpbmcoUCkgKyAnIG9mICcgKyB0cnlUb1N0cmluZyhPKSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5117\n")},9781:function(module,__unused_webpack_exports,__webpack_require__){eval("var fails = __webpack_require__(7293);\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc4MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBb0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLG1CQUFtQixhQUFhO0FBQ3hFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanM/NzIxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9781\n")},4154:function(module){eval("var documentAll = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\nvar IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;\n\nmodule.exports = {\n  all: documentAll,\n  IS_HTMLDDA: IS_HTMLDDA\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsLmpzPzk3NDEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRvY3VtZW50QWxsID0gdHlwZW9mIGRvY3VtZW50ID09ICdvYmplY3QnICYmIGRvY3VtZW50LmFsbDtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdHlwZW9mLXVuZGVmaW5lZCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIElTX0hUTUxEREEgPSB0eXBlb2YgZG9jdW1lbnRBbGwgPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRBbGwgIT09IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFsbDogZG9jdW1lbnRBbGwsXG4gIElTX0hUTUxEREE6IElTX0hUTUxEREFcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4154\n")},317:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar isObject = __webpack_require__(111);\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE3LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxJQUFxQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsR0FBd0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanM/NTQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///317\n")},7207:function(module){eval("var $TypeError = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nmodule.exports = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcz8zNzZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93ICRUeXBlRXJyb3IoJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCcpO1xuICByZXR1cm4gaXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7207\n")},8113:function(module){eval("module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODExMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcz80YzU0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIG5hdmlnYXRvciAhPSAndW5kZWZpbmVkJyAmJiBTdHJpbmcobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgJyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8113\n")},7392:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar userAgent = __webpack_require__(8113);\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZ0M7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qcz84MWIzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7392\n")},748:function(module){eval("// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanM/NjE1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///748\n")},2109:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar getOwnPropertyDescriptor = (__webpack_require__(1236).f);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar defineBuiltIn = __webpack_require__(8052);\nvar defineGlobalProperty = __webpack_require__(3072);\nvar copyConstructorProperties = __webpack_require__(9920);\nvar isForced = __webpack_require__(4705);\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsK0JBQStCLDZCQUE0RDtBQUMzRixrQ0FBa0MsbUJBQU8sQ0FBQyxJQUE2QztBQUN2RixvQkFBb0IsbUJBQU8sQ0FBQyxJQUE4QjtBQUMxRCwyQkFBMkIsbUJBQU8sQ0FBQyxJQUFxQztBQUN4RSxnQ0FBZ0MsbUJBQU8sQ0FBQyxJQUEwQztBQUNsRixlQUFlLG1CQUFPLENBQUMsSUFBd0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhEQUE4RDtBQUM5RCxJQUFJO0FBQ0osa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanM/YzU1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2109\n")},7293:function(module){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI5My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzPzNjN2EiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7293\n")},4374:function(module,__unused_webpack_exports,__webpack_require__){eval("var fails = __webpack_require__(7293);\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM3NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBb0I7O0FBRXhDO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcz9kNGUxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4374\n")},6916:function(module,__unused_webpack_exports,__webpack_require__){eval("var NATIVE_BIND = __webpack_require__(4374);\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkxNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFtQzs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanM/NjIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6916\n")},6530:function(module,__unused_webpack_exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(9781);\nvar hasOwn = __webpack_require__(2597);\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUzMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsSUFBK0I7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzPzY4MWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6530\n")},1702:function(module,__unused_webpack_exports,__webpack_require__){eval("var NATIVE_BIND = __webpack_require__(4374);\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcwMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFtQzs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzPzEyMTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbnZhciB1bmN1cnJ5VGhpc1dpdGhCaW5kID0gTkFUSVZFX0JJTkQgJiYgRnVuY3Rpb25Qcm90b3R5cGUuYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1702\n")},5005:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar isCallable = __webpack_require__(614);\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsR0FBMEI7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzPzExMWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pIDogZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5005\n")},8173:function(module,__unused_webpack_exports,__webpack_require__){eval("var aCallable = __webpack_require__(9662);\nvar isNullOrUndefined = __webpack_require__(8554);\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE3My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUF5QjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFtQzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanM/YjM2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8173\n")},7854:function(module,__unused_webpack_exports,__webpack_require__){eval("var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFNLGdCQUFnQixxQkFBTTtBQUMzQztBQUNBLGlCQUFpQixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcz8zOWZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7854\n")},2597:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\nvar toObject = __webpack_require__(7908);\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU5Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQztBQUM5RCxlQUFlLG1CQUFPLENBQUMsSUFBd0I7O0FBRS9DLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanM/OTNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2597\n")},3501:function(module){eval("module.exports = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUwMS5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcz9mY2UxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3501\n")},4664:function(module,__unused_webpack_exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(9781);\nvar fails = __webpack_require__(7293);\nvar createElement = __webpack_require__(317);\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRCxZQUFZLG1CQUFPLENBQUMsSUFBb0I7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsR0FBc0M7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzPzU2ZDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4664\n")},8361:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\nvar fails = __webpack_require__(7293);\nvar classof = __webpack_require__(4326);\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQztBQUM5RCxZQUFZLG1CQUFPLENBQUMsSUFBb0I7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLElBQTBCOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzPzdmZmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0KGl0KTtcbn0gOiAkT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8361\n")},2788:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\nvar isCallable = __webpack_require__(614);\nvar store = __webpack_require__(5465);\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc4OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQztBQUM5RCxpQkFBaUIsbUJBQU8sQ0FBQyxHQUEwQjtBQUNuRCxZQUFZLG1CQUFPLENBQUMsSUFBMkI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcz8wODZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2788\n")},9909:function(module,__unused_webpack_exports,__webpack_require__){eval("var NATIVE_WEAK_MAP = __webpack_require__(4811);\nvar global = __webpack_require__(7854);\nvar isObject = __webpack_require__(111);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar hasOwn = __webpack_require__(2597);\nvar shared = __webpack_require__(5465);\nvar sharedKey = __webpack_require__(6200);\nvar hiddenKeys = __webpack_require__(3501);\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsbUJBQU8sQ0FBQyxJQUF1QztBQUNyRSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLEdBQXdCO0FBQy9DLGtDQUFrQyxtQkFBTyxDQUFDLElBQTZDO0FBQ3ZGLGFBQWEsbUJBQU8sQ0FBQyxJQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsSUFBMkI7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsSUFBeUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsSUFBMEI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanM/M2UxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHN0b3JlLmdldCA9IHN0b3JlLmdldDtcbiAgc3RvcmUuaGFzID0gc3RvcmUuaGFzO1xuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHN0b3JlLmhhcyhpdCkpIHRocm93IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9909\n")},3157:function(module,__unused_webpack_exports,__webpack_require__){eval("var classof = __webpack_require__(4326);\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) == 'Array';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBMEI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcz9jYzdkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoYXJndW1lbnQpID09ICdBcnJheSc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3157\n")},614:function(module,__unused_webpack_exports,__webpack_require__){eval("var $documentAll = __webpack_require__(4154);\n\nvar documentAll = $documentAll.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = $documentAll.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE0LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLElBQTJCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzPzU5MmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRkb2N1bWVudEFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1hbGwnKTtcblxudmFyIGRvY3VtZW50QWxsID0gJGRvY3VtZW50QWxsLmFsbDtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudCA9PT0gZG9jdW1lbnRBbGw7XG59IDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///614\n")},4705:function(module,__unused_webpack_exports,__webpack_require__){eval("var fails = __webpack_require__(7293);\nvar isCallable = __webpack_require__(614);\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBb0I7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsR0FBMEI7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzP2MyMWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4705\n")},8554:function(module){eval("// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU1NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzP2RmYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gd2UgY2FuJ3QgdXNlIGp1c3QgYGl0ID09IG51bGxgIHNpbmNlIG9mIGBkb2N1bWVudC5hbGxgIHNwZWNpYWwgY2FzZVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdC1hZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gbnVsbCB8fCBpdCA9PT0gdW5kZWZpbmVkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8554\n")},111:function(module,__unused_webpack_exports,__webpack_require__){eval("var isCallable = __webpack_require__(614);\nvar $documentAll = __webpack_require__(4154);\n\nvar documentAll = $documentAll.all;\n\nmodule.exports = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTExLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLEdBQTBCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLElBQTJCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzPzYxZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciAkZG9jdW1lbnRBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsJyk7XG5cbnZhciBkb2N1bWVudEFsbCA9ICRkb2N1bWVudEFsbC5hbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gJGRvY3VtZW50QWxsLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCkgfHwgaXQgPT09IGRvY3VtZW50QWxsO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///111\n")},1913:function(module){eval("module.exports = false;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkxMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzP2Q4M2YiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1913\n")},2190:function(module,__unused_webpack_exports,__webpack_require__){eval("var getBuiltIn = __webpack_require__(5005);\nvar isCallable = __webpack_require__(614);\nvar isPrototypeOf = __webpack_require__(7976);\nvar USE_SYMBOL_AS_UID = __webpack_require__(3307);\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUEyQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxHQUEwQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFxQztBQUNqRSx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFnQzs7QUFFaEU7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzPzg0MjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QoaXQpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2190\n")},6244:function(module,__unused_webpack_exports,__webpack_require__){eval("var toLength = __webpack_require__(7466);\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI0NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBd0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanM/MWI5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6244\n")},6339:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\nvar fails = __webpack_require__(7293);\nvar isCallable = __webpack_require__(614);\nvar hasOwn = __webpack_require__(2597);\nvar DESCRIPTORS = __webpack_require__(9781);\nvar CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(6530).CONFIGURABLE);\nvar inspectSource = __webpack_require__(2788);\nvar InternalStateModule = __webpack_require__(9909);\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar $String = String;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\nvar stringSlice = uncurryThis(''.slice);\nvar replace = uncurryThis(''.replace);\nvar join = uncurryThis([].join);\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (stringSlice($String(name), 0, 7) === 'Symbol(') {\n    name = '[' + replace($String(name), /^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQztBQUM5RCxZQUFZLG1CQUFPLENBQUMsSUFBb0I7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsR0FBMEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLElBQStCO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLElBQTBCO0FBQ3BELGlDQUFpQyx3Q0FBa0Q7QUFDbkYsb0JBQW9CLG1CQUFPLENBQUMsSUFBNkI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsSUFBNkI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsYUFBYSxjQUFjLFVBQVU7QUFDM0UsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQ0FBaUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0EsTUFBTTtBQUNOLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbi5qcz82NjA0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChzdHJpbmdTbGljZSgkU3RyaW5nKG5hbWUpLCAwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIHJlcGxhY2UoJFN0cmluZyhuYW1lKSwgL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBqb2luKFRFTVBMQVRFLCB0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6339\n")},4758:function(module){eval("var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc1OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanM/ZDNlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4758\n")},3070:function(__unused_webpack_module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(9781);\nvar IE8_DOM_DEFINE = __webpack_require__(4664);\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(3353);\nvar anObject = __webpack_require__(9670);\nvar toPropertyKey = __webpack_require__(4948);\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA3MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQyxJQUE2QjtBQUMxRCw4QkFBOEIsbUJBQU8sQ0FBQyxJQUFzQztBQUM1RSxlQUFlLG1CQUFPLENBQUMsSUFBd0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsSUFBOEI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanM/NmY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3070\n")},1236:function(__unused_webpack_module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(9781);\nvar call = __webpack_require__(6916);\nvar propertyIsEnumerableModule = __webpack_require__(5296);\nvar createPropertyDescriptor = __webpack_require__(9114);\nvar toIndexedObject = __webpack_require__(5656);\nvar toPropertyKey = __webpack_require__(4948);\nvar hasOwn = __webpack_require__(2597);\nvar IE8_DOM_DEFINE = __webpack_require__(4664);\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRCxXQUFXLG1CQUFPLENBQUMsSUFBNEI7QUFDL0MsaUNBQWlDLG1CQUFPLENBQUMsSUFBNEM7QUFDckYsK0JBQStCLG1CQUFPLENBQUMsSUFBeUM7QUFDaEYsc0JBQXNCLG1CQUFPLENBQUMsSUFBZ0M7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMsSUFBOEI7QUFDMUQsYUFBYSxtQkFBTyxDQUFDLElBQStCO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLElBQTZCOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/OTgyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1236\n")},8006:function(__unused_webpack_module,exports,__webpack_require__){eval("var internalObjectKeys = __webpack_require__(6324);\nvar enumBugKeys = __webpack_require__(748);\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAwNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5QkFBeUIsbUJBQU8sQ0FBQyxJQUFtQztBQUNwRSxrQkFBa0IsbUJBQU8sQ0FBQyxHQUE0Qjs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanM/ZWE5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8006\n")},5181:function(__unused_webpack_module,exports){eval("// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE4MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcz82NmUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5181\n")},7976:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQzs7QUFFOUQsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanM/ZTliMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoe30uaXNQcm90b3R5cGVPZik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7976\n")},6324:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\nvar hasOwn = __webpack_require__(2597);\nvar toIndexedObject = __webpack_require__(5656);\nvar indexOf = (__webpack_require__(1318).indexOf);\nvar hiddenKeys = __webpack_require__(3501);\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMyNC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQztBQUM5RCxhQUFhLG1CQUFPLENBQUMsSUFBK0I7QUFDcEQsc0JBQXNCLG1CQUFPLENBQUMsSUFBZ0M7QUFDOUQsY0FBYyxtQ0FBOEM7QUFDNUQsaUJBQWlCLG1CQUFPLENBQUMsSUFBMEI7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcz9iNDZkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6324\n")},5296:function(__unused_webpack_module,exports){"use strict";eval("\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI5Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLE1BQU07O0FBRWxGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanM/M2NhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5296\n")},2140:function(module,__unused_webpack_exports,__webpack_require__){eval("var call = __webpack_require__(6916);\nvar isCallable = __webpack_require__(614);\nvar isObject = __webpack_require__(111);\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError(\"Can't convert object to primitive value\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE0MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBNEI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsR0FBMEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLEdBQXdCOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzP2ZjZTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2140\n")},3887:function(module,__unused_webpack_exports,__webpack_require__){eval("var getBuiltIn = __webpack_require__(5005);\nvar uncurryThis = __webpack_require__(1702);\nvar getOwnPropertyNamesModule = __webpack_require__(8006);\nvar getOwnPropertySymbolsModule = __webpack_require__(5181);\nvar anObject = __webpack_require__(9670);\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUEyQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQztBQUM5RCxnQ0FBZ0MsbUJBQU8sQ0FBQyxJQUE0QztBQUNwRixrQ0FBa0MsbUJBQU8sQ0FBQyxJQUE4QztBQUN4RixlQUFlLG1CQUFPLENBQUMsSUFBd0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcz83ODJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3887\n")},4488:function(module,__unused_webpack_exports,__webpack_require__){eval('var isNullOrUndefined = __webpack_require__(8554);\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw $TypeError("Can\'t call method on " + it);\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ4OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFtQzs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcz8zNThmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKSB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4488\n')},6200:function(module,__unused_webpack_exports,__webpack_require__){eval("var shared = __webpack_require__(2309);\nvar uid = __webpack_require__(9711);\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIwMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsVUFBVSxtQkFBTyxDQUFDLElBQWtCOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcz82ZTI4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6200\n")},5465:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar defineGlobalProperty = __webpack_require__(3072);\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ2NS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsMkJBQTJCLG1CQUFPLENBQUMsSUFBcUM7O0FBRXhFO0FBQ0EsNkRBQTZEOztBQUU3RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanM/YzA4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHknKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5465\n")},2309:function(module,__unused_webpack_exports,__webpack_require__){eval("var IS_PURE = __webpack_require__(1913);\nvar store = __webpack_require__(5465);\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.29.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBc0I7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLElBQTJCOztBQUUvQztBQUNBLHFFQUFxRTtBQUNyRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzPzhiYTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjkuMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIzIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjkuMS9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2309\n")},6293:function(module,__unused_webpack_exports,__webpack_require__){eval("/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(7392);\nvar fails = __webpack_require__(7293);\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI5My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLElBQWdDO0FBQ3pELFlBQVksbUJBQU8sQ0FBQyxJQUFvQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcz84NGRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6293\n")},1400:function(module,__unused_webpack_exports,__webpack_require__){eval("var toIntegerOrInfinity = __webpack_require__(9303);\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQkFBMEIsbUJBQU8sQ0FBQyxJQUFxQzs7QUFFdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzPzAyZDEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1400\n")},5656:function(module,__unused_webpack_exports,__webpack_require__){eval("// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(8361);\nvar requireObjectCoercible = __webpack_require__(4488);\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLElBQTZCO0FBQ3pELDZCQUE2QixtQkFBTyxDQUFDLElBQXVDOztBQUU1RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanM/YjQ1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5656\n")},9303:function(module,__unused_webpack_exports,__webpack_require__){eval("var trunc = __webpack_require__(4758);\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMwMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBeUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanM/Yzk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJ1bmMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWF0aC10cnVuYycpO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9303\n")},7466:function(module,__unused_webpack_exports,__webpack_require__){eval("var toIntegerOrInfinity = __webpack_require__(9303);\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQkFBMEIsbUJBQU8sQ0FBQyxJQUFxQzs7QUFFdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcz81NDFhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7466\n")},7908:function(module,__unused_webpack_exports,__webpack_require__){eval("var requireObjectCoercible = __webpack_require__(4488);\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkwOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkIsbUJBQU8sQ0FBQyxJQUF1Qzs7QUFFNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanM/ODlhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7908\n")},7593:function(module,__unused_webpack_exports,__webpack_require__){eval("var call = __webpack_require__(6916);\nvar isObject = __webpack_require__(111);\nvar isSymbol = __webpack_require__(2190);\nvar getMethod = __webpack_require__(8173);\nvar ordinaryToPrimitive = __webpack_require__(2140);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU5My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBNEI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLEdBQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxJQUF3QjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUF5QjtBQUNqRCwwQkFBMEIsbUJBQU8sQ0FBQyxJQUFvQztBQUN0RSxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFnQzs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzPzMwOGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdChyZXN1bHQpIHx8IGlzU3ltYm9sKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7593\n")},4948:function(module,__unused_webpack_exports,__webpack_require__){eval("var toPrimitive = __webpack_require__(7593);\nvar isSymbol = __webpack_require__(2190);\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEyQjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsSUFBd0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanM/OTcxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4948\n")},6330:function(module){eval("var $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMzMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanM/MmRiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJFN0cmluZyA9IFN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6330\n")},9711:function(module,__unused_webpack_exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(1702);\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcxMS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFvQzs7QUFFOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanM/ZmNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZygrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9711\n")},3307:function(module,__unused_webpack_exports,__webpack_require__){eval("/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(6293);\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLElBQTJDOztBQUV2RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanM/OGI3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3307\n")},3353:function(module,__unused_webpack_exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(9781);\nvar fails = __webpack_require__(7293);\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM1My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRCxZQUFZLG1CQUFPLENBQUMsSUFBb0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzPzViMzYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3353\n")},4811:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar isCallable = __webpack_require__(614);\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgxMS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsR0FBMEI7O0FBRW5EOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcz81NmNjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4811\n")},5112:function(module,__unused_webpack_exports,__webpack_require__){eval("var global = __webpack_require__(7854);\nvar shared = __webpack_require__(2309);\nvar hasOwn = __webpack_require__(2597);\nvar uid = __webpack_require__(9711);\nvar NATIVE_SYMBOL = __webpack_require__(6293);\nvar USE_SYMBOL_AS_UID = __webpack_require__(3307);\n\nvar Symbol = global.Symbol;\nvar WellKnownSymbolsStore = shared('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name)) {\n    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)\n      ? Symbol[name]\n      : createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore[name];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTExMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLElBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxJQUErQjtBQUNwRCxVQUFVLG1CQUFPLENBQUMsSUFBa0I7QUFDcEMsb0JBQW9CLG1CQUFPLENBQUMsSUFBMkM7QUFDdkUsd0JBQXdCLG1CQUFPLENBQUMsSUFBZ0M7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzP2YyNmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbFsnZm9yJ10gfHwgU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093bihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24oU3ltYm9sLCBuYW1lKVxuICAgICAgPyBTeW1ib2xbbmFtZV1cbiAgICAgIDogY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5112\n")},7658:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\nvar $ = __webpack_require__(2109);\nvar toObject = __webpack_require__(7908);\nvar lengthOfArrayLike = __webpack_require__(6244);\nvar setArrayLength = __webpack_require__(3658);\nvar doesNotExceedSafeInteger = __webpack_require__(7207);\nvar fails = __webpack_require__(7293);\n\nvar INCORRECT_TO_LENGTH = fails(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 and Safari <= 15.4, FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength(O, len);\n    return len;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFFBQVEsbUJBQU8sQ0FBQyxJQUFxQjtBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBd0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsSUFBbUM7QUFDbkUscUJBQXFCLG1CQUFPLENBQUMsSUFBK0I7QUFDNUQsK0JBQStCLG1CQUFPLENBQUMsSUFBMkM7QUFDbEYsWUFBWSxtQkFBTyxDQUFDLElBQW9COztBQUV4QztBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0MsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHdEQUF3RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5wdXNoLmpzPzBlYTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBzZXRBcnJheUxlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zZXQtbGVuZ3RoJyk7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvZXMtbm90LWV4Y2VlZC1zYWZlLWludGVnZXInKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgSU5DT1JSRUNUX1RPX0xFTkdUSCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdLnB1c2guY2FsbCh7IGxlbmd0aDogMHgxMDAwMDAwMDAgfSwgMSkgIT09IDQyOTQ5NjcyOTc7XG59KTtcblxuLy8gVjggYW5kIFNhZmFyaSA8PSAxNS40LCBGRiA8IDIzIHRocm93cyBJbnRlcm5hbEVycm9yXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMjY4MVxudmFyIHByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KS5wdXNoKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59O1xuXG52YXIgRk9SQ0VEID0gSU5DT1JSRUNUX1RPX0xFTkdUSCB8fCAhcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoKCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucHVzaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5wdXNoXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgcHVzaDogZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobGVuICsgYXJnQ291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7IGkrKykge1xuICAgICAgT1tsZW5dID0gYXJndW1lbnRzW2ldO1xuICAgICAgbGVuKys7XG4gICAgfVxuICAgIHNldEFycmF5TGVuZ3RoKE8sIGxlbik7XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7658\n")},541:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\nvar $ = __webpack_require__(2109);\nvar toObject = __webpack_require__(7908);\nvar lengthOfArrayLike = __webpack_require__(6244);\nvar setArrayLength = __webpack_require__(3658);\nvar deletePropertyOrThrow = __webpack_require__(5117);\nvar doesNotExceedSafeInteger = __webpack_require__(7207);\n\n// IE8-\nvar INCORRECT_RESULT = [].unshift(0) !== 1;\n\n// V8 ~ Chrome < 71 and Safari <= 15.4, FF < 23 throws InternalError\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).unshift();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();\n\n// `Array.prototype.unshift` method\n// https://tc39.es/ecma262/#sec-array.prototype.unshift\n$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  unshift: function unshift(item) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = arguments.length;\n    if (argCount) {\n      doesNotExceedSafeInteger(len + argCount);\n      var k = len;\n      while (k--) {\n        var to = k + argCount;\n        if (k in O) O[to] = O[k];\n        else deletePropertyOrThrow(O, to);\n      }\n      for (var j = 0; j < argCount; j++) {\n        O[j] = arguments[j];\n      }\n    } return setArrayLength(O, len + argCount);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxtQkFBTyxDQUFDLElBQXFCO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUF3QjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFtQztBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyxJQUErQjtBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQyxJQUF1QztBQUMzRSwrQkFBK0IsbUJBQU8sQ0FBQyxJQUEyQzs7QUFFbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQkFBaUI7QUFDM0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3REFBd0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkudW5zaGlmdC5qcz8wNGU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgc2V0QXJyYXlMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2V0LWxlbmd0aCcpO1xudmFyIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWxldGUtcHJvcGVydHktb3ItdGhyb3cnKTtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlcicpO1xuXG4vLyBJRTgtXG52YXIgSU5DT1JSRUNUX1JFU1VMVCA9IFtdLnVuc2hpZnQoMCkgIT09IDE7XG5cbi8vIFY4IH4gQ2hyb21lIDwgNzEgYW5kIFNhZmFyaSA8PSAxNS40LCBGRiA8IDIzIHRocm93cyBJbnRlcm5hbEVycm9yXG52YXIgcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLnVuc2hpZnQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gIH1cbn07XG5cbnZhciBGT1JDRUQgPSBJTkNPUlJFQ1RfUkVTVUxUIHx8ICFwcm9wZXJFcnJvck9uTm9uV3JpdGFibGVMZW5ndGgoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS51bnNoaWZ0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnVuc2hpZnRcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBhcml0eTogMSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB1bnNoaWZ0OiBmdW5jdGlvbiB1bnNoaWZ0KGl0ZW0pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChhcmdDb3VudCkge1xuICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKGxlbiArIGFyZ0NvdW50KTtcbiAgICAgIHZhciBrID0gbGVuO1xuICAgICAgd2hpbGUgKGstLSkge1xuICAgICAgICB2YXIgdG8gPSBrICsgYXJnQ291bnQ7XG4gICAgICAgIGlmIChrIGluIE8pIE9bdG9dID0gT1trXTtcbiAgICAgICAgZWxzZSBkZWxldGVQcm9wZXJ0eU9yVGhyb3coTywgdG8pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcmdDb3VudDsgaisrKSB7XG4gICAgICAgIE9bal0gPSBhcmd1bWVudHNbal07XG4gICAgICB9XG4gICAgfSByZXR1cm4gc2V0QXJyYXlMZW5ndGgoTywgbGVuICsgYXJnQ291bnQpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///541\n")},4870:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Bj": function() { return /* binding */ EffectScope; },\n/* harmony export */   "Fl": function() { return /* binding */ computed; },\n/* harmony export */   "IU": function() { return /* binding */ toRaw; },\n/* harmony export */   "Jd": function() { return /* binding */ pauseTracking; },\n/* harmony export */   "PG": function() { return /* binding */ isReactive; },\n/* harmony export */   "SU": function() { return /* binding */ unref; },\n/* harmony export */   "Um": function() { return /* binding */ shallowReactive; },\n/* harmony export */   "WL": function() { return /* binding */ proxyRefs; },\n/* harmony export */   "X$": function() { return /* binding */ trigger; },\n/* harmony export */   "X3": function() { return /* binding */ isProxy; },\n/* harmony export */   "XI": function() { return /* binding */ shallowRef; },\n/* harmony export */   "Xl": function() { return /* binding */ markRaw; },\n/* harmony export */   "dq": function() { return /* binding */ isRef; },\n/* harmony export */   "iH": function() { return /* binding */ ref; },\n/* harmony export */   "j": function() { return /* binding */ track; },\n/* harmony export */   "lk": function() { return /* binding */ resetTracking; },\n/* harmony export */   "nZ": function() { return /* binding */ getCurrentScope; },\n/* harmony export */   "qj": function() { return /* binding */ reactive; },\n/* harmony export */   "qq": function() { return /* binding */ ReactiveEffect; },\n/* harmony export */   "yT": function() { return /* binding */ isShallow; }\n/* harmony export */ });\n/* unused harmony exports ITERATE_KEY, customRef, deferredComputed, effect, effectScope, enableTracking, isReadonly, onScopeDispose, readonly, shallowReadonly, stop, toRef, toRefs, triggerRef */\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7139);\n\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (false) {}\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      // nested scope, dereference from parent to avoid memory leaks\n      if (!this.detached && this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = undefined;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (false) {}\n}\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      // clear bits\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol( false ? 0 : \'\');\nconst MAP_KEY_ITERATE_KEY = Symbol( false ? 0 : \'\');\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = undefined;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = undefined;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    // stopped while running itself - defer the cleanup\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect) {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo =  false ? 0 : undefined;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (false) {}\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n  let deps = [];\n  if (type === "clear" /* TriggerOpTypes.CLEAR */) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()];\n  } else if (key === \'length\' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key) => {\n      if (key === \'length\' || key >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case "add" /* TriggerOpTypes.ADD */:\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isIntegerKey */ .S0)(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get(\'length\'));\n        }\n        break;\n      case "delete" /* TriggerOpTypes.DELETE */:\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case "set" /* TriggerOpTypes.SET */:\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo =  false ? 0 : undefined;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (false) {} else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (false) {} else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(dep) ? dep : [...dep];\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    if (false) {}\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\nconst isNonTrackableKeys = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .makeMap */ .fY)(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n// ios10.x Object.getOwnPropertyNames(Symbol) can enumerate \'arguments\' and \'caller\'\n// but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n// function\n.filter(key => key !== \'arguments\' && key !== \'caller\').map(key => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .yk));\nconst get$1 = /*#__PURE__*/createGetter();\nconst shallowGet = /*#__PURE__*/createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\'includes\', \'indexOf\', \'lastIndexOf\'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, "get" /* TrackOpTypes.GET */, i + \'\');\n      }\n      // we run the method using the original args first (which may be reactive)\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        // if that didn\'t work, run it again using raw values.\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\'push\', \'pop\', \'shift\', \'unshift\', \'splice\'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, "has" /* TrackOpTypes.HAS */, key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    if (key === "__v_isReactive" /* ReactiveFlags.IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === "__v_isReadonly" /* ReactiveFlags.IS_READONLY */) {\n      return isReadonly;\n    } else if (key === "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */) {\n      return shallow;\n    } else if (key === "__v_raw" /* ReactiveFlags.RAW */ && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target);\n    if (!isReadonly) {\n      if (targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \'hasOwnProperty\') {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .yk)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, "get" /* TrackOpTypes.GET */, key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      // ref unwrapping - skip unwrap for Array + integer key.\n      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isIntegerKey */ .S0)(key) ? res : res.value;\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /*#__PURE__*/createSetter();\nconst shallowSet = /*#__PURE__*/createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isIntegerKey */ .S0)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    // don\'t trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, "add" /* TriggerOpTypes.ADD */, key, value);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .aU)(value, oldValue)) {\n        trigger(target, "set" /* TriggerOpTypes.SET */, key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, "delete" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .yk)(key) || !builtInSymbols.has(key)) {\n    track(target, "has" /* TrackOpTypes.HAS */, key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, "iterate" /* TrackOpTypes.ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(target) ? \'length\' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (false) {}\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (false) {}\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target["__v_raw" /* ReactiveFlags.RAW */];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, "get" /* TrackOpTypes.GET */, key);\n    }\n    track(rawTarget, "get" /* TrackOpTypes.GET */, rawKey);\n  }\n  const {\n    has\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this["__v_raw" /* ReactiveFlags.RAW */];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, "has" /* TrackOpTypes.HAS */, key);\n    }\n    track(rawTarget, "has" /* TrackOpTypes.HAS */, rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target["__v_raw" /* ReactiveFlags.RAW */];\n  !isReadonly && track(toRaw(target), "iterate" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n  return Reflect.get(target, \'size\', target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, "add" /* TriggerOpTypes.ADD */, value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (false) {}\n  const oldValue = get.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, "add" /* TriggerOpTypes.ADD */, key, value);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .aU)(value, oldValue)) {\n    trigger(target, "set" /* TriggerOpTypes.SET */, key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (false) {}\n  const oldValue = get ? get.call(target, key) : undefined;\n  // forward the operation before queueing reactions\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, "delete" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget =  false ? 0 : undefined;\n  // forward the operation before queueing reactions\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, "clear" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed["__v_raw" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, "iterate" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return target.forEach((value, key) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this["__v_raw" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isMap */ ._N)(rawTarget);\n    const isPair = method === \'entries\' || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \'keys\' && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, "iterate" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (false) {}\n    return type === "delete" /* TriggerOpTypes.DELETE */ ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod("add" /* TriggerOpTypes.ADD */),\n    set: createReadonlyMethod("set" /* TriggerOpTypes.SET */),\n    delete: createReadonlyMethod("delete" /* TriggerOpTypes.DELETE */),\n    clear: createReadonlyMethod("clear" /* TriggerOpTypes.CLEAR */),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod("add" /* TriggerOpTypes.ADD */),\n    set: createReadonlyMethod("set" /* TriggerOpTypes.SET */),\n    delete: createReadonlyMethod("delete" /* TriggerOpTypes.DELETE */),\n    clear: createReadonlyMethod("clear" /* TriggerOpTypes.CLEAR */),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\'keys\', \'values\', \'entries\', Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === "__v_isReactive" /* ReactiveFlags.IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === "__v_isReadonly" /* ReactiveFlags.IS_READONLY */) {\n      return isReadonly;\n    } else if (key === "__v_raw" /* ReactiveFlags.RAW */) {\n      return target;\n    }\n    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .RI)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \'Object\':\n    case \'Array\':\n      return 1 /* TargetType.COMMON */;\n    case \'Map\':\n    case \'Set\':\n    case \'WeakMap\':\n    case \'WeakSet\':\n      return 2 /* TargetType.COLLECTION */;\n    default:\n      return 0 /* TargetType.INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value["__v_skip" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value) ? 0 /* TargetType.INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toRawType */ .W7)(value));\n}\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(target)) {\n    if (false) {}\n    return target;\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (target["__v_raw" /* ReactiveFlags.RAW */] && !(isReadonly && target["__v_isReactive" /* ReactiveFlags.IS_REACTIVE */])) {\n    return target;\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  // only specific value types can be observed.\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* TargetType.INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);\n  }\n  return !!(value && value["__v_isReactive" /* ReactiveFlags.IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n  return !!(value && value["__v_isReadonly" /* ReactiveFlags.IS_READONLY */]);\n}\nfunction isShallow(value) {\n  return !!(value && value["__v_isShallow" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .def */ .Nj)(value, "__v_skip" /* ReactiveFlags.SKIP */, true);\n  return value;\n}\nconst toReactive = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(value) ? reactive(value) : value;\nconst toReadonly = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(value) ? readonly(value) : value;\nfunction trackRefValue(ref) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref);\n    if (false) {} else {\n      trackEffects(ref.dep || (ref.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n  const dep = ref.dep;\n  if (dep) {\n    if (false) {} else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .aU)(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref) {\n  triggerRefValue(ref,  false ? 0 : void 0);\n}\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = undefined;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (false) {}\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === undefined ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nfunction toRef(object, key, defaultValue) {\n  const val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\nvar _a$1;\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this[_a$1] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this["__v_isReadonly" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n  }\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\n_a$1 = "__v_isReadonly" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter =  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .dG;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (false) {}\n  return cRef;\n}\nvar _a;\nconst tick = /*#__PURE__*/(/* unused pure expression or super */ null && (Promise.resolve()));\nconst queue = (/* unused pure expression or super */ null && ([]));\nlet queued = false;\nconst scheduler = fn => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(true /* computedTrigger */);\n          }\n        }\n      }\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    return toRaw(this)._get();\n  }\n}\n_a = "__v_isReadonly" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ3pOLE1BQU0sQ0FBQ2tFLFFBQVEsR0FBRyxJQUFJO0VBQy9CO0VBQ0FxSSxJQUFJQSxDQUFBLEVBQUc7SUFDSCxJQUFJLElBQUksQ0FBQ2tCLE1BQU0sRUFBRTtNQUNiLElBQUksQ0FBQ0EsTUFBTSxHQUFHLEtBQUs7TUFDbkIsT0FBUSxJQUFJLENBQUMzQixNQUFNLEdBQUcsSUFBSSxDQUFDOUwsTUFBTSxDQUFDbEIsR0FBRyxDQUFDLENBQUM7SUFDM0M7SUFDQSxPQUFPLElBQUksQ0FBQ2dOLE1BQU07RUFDdEI7RUFDQSxJQUFJeEYsS0FBS0EsQ0FBQSxFQUFHO0lBQ1I0RSxhQUFhLENBQUMsSUFBSSxDQUFDO0lBQ25CO0lBQ0EsT0FBTzNGLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQ2dILElBQUksQ0FBQyxDQUFDO0VBQzdCO0FBQ0o7QUFDQS9ILEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQztBQUN0QixTQUFTdUssZ0JBQWdCQSxDQUFDekIsTUFBTSxFQUFFO0VBQzlCLE9BQU8sSUFBSWtCLHVCQUF1QixDQUFDbEIsTUFBTSxDQUFDO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanM/ODlkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHRlbmQsIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGhhc093biwgaXNTeW1ib2wsIGlzT2JqZWN0LCBoYXNDaGFuZ2VkLCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9XG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKHRoaXMpIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBydW4oZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdFNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uKCkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBvZmYoKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIHN0b3AoZnJvbVBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICBsZXQgaSwgbDtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZXN0ZWQgc2NvcGUsIGRlcmVmZXJlbmNlIGZyb20gcGFyZW50IHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIHJlY29yZEVmZmVjdFNjb3BlKGVmZmVjdCwgc2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcbiAgICAgICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICAgIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2Fybihgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlYCArXG4gICAgICAgICAgICBgIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gKTtcbiAgICB9XG59XG5cbmNvbnN0IGNyZWF0ZURlcCA9IChlZmZlY3RzKSA9PiB7XG4gICAgY29uc3QgZGVwID0gbmV3IFNldChlZmZlY3RzKTtcbiAgICBkZXAudyA9IDA7XG4gICAgZGVwLm4gPSAwO1xuICAgIHJldHVybiBkZXA7XG59O1xuY29uc3Qgd2FzVHJhY2tlZCA9IChkZXApID0+IChkZXAudyAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IG5ld1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLm4gJiB0cmFja09wQml0KSA+IDA7XG5jb25zdCBpbml0RGVwTWFya2VycyA9ICh7IGRlcHMgfSkgPT4ge1xuICAgIGlmIChkZXBzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlcHNbaV0udyB8PSB0cmFja09wQml0OyAvLyBzZXQgd2FzIHRyYWNrZWRcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBmaW5hbGl6ZURlcE1hcmtlcnMgPSAoZWZmZWN0KSA9PiB7XG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwdHIgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcCA9IGRlcHNbaV07XG4gICAgICAgICAgICBpZiAod2FzVHJhY2tlZChkZXApICYmICFuZXdUcmFja2VkKGRlcCkpIHtcbiAgICAgICAgICAgICAgICBkZXAuZGVsZXRlKGVmZmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXBzW3B0cisrXSA9IGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIGJpdHNcbiAgICAgICAgICAgIGRlcC53ICY9IH50cmFja09wQml0O1xuICAgICAgICAgICAgZGVwLm4gJj0gfnRyYWNrT3BCaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVwcy5sZW5ndGggPSBwdHI7XG4gICAgfVxufTtcblxuY29uc3QgdGFyZ2V0TWFwID0gbmV3IFdlYWtNYXAoKTtcbi8vIFRoZSBudW1iZXIgb2YgZWZmZWN0cyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZCByZWN1cnNpdmVseS5cbmxldCBlZmZlY3RUcmFja0RlcHRoID0gMDtcbmxldCB0cmFja09wQml0ID0gMTtcbi8qKlxuICogVGhlIGJpdHdpc2UgdHJhY2sgbWFya2VycyBzdXBwb3J0IGF0IG1vc3QgMzAgbGV2ZWxzIG9mIHJlY3Vyc2lvbi5cbiAqIFRoaXMgdmFsdWUgaXMgY2hvc2VuIHRvIGVuYWJsZSBtb2Rlcm4gSlMgZW5naW5lcyB0byB1c2UgYSBTTUkgb24gYWxsIHBsYXRmb3Jtcy5cbiAqIFdoZW4gcmVjdXJzaW9uIGRlcHRoIGlzIGdyZWF0ZXIsIGZhbGwgYmFjayB0byB1c2luZyBhIGZ1bGwgY2xlYW51cC5cbiAqL1xuY29uc3QgbWF4TWFya2VyQml0cyA9IDMwO1xubGV0IGFjdGl2ZUVmZmVjdDtcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdpdGVyYXRlJyA6ICcnKTtcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoZm4sIHNjaGVkdWxlciA9IG51bGwsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZXBzID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBzY29wZSk7XG4gICAgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgICAgICBsZXQgbGFzdFNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXM7XG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gICAgICAgICAgICB0cmFja09wQml0ID0gMSA8PCArK2VmZmVjdFRyYWNrRGVwdGg7XG4gICAgICAgICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XG4gICAgICAgICAgICAgICAgaW5pdERlcE1hcmtlcnModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZURlcE1hcmtlcnModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFja09wQml0ID0gMSA8PCAtLWVmZmVjdFRyYWNrRGVwdGg7XG4gICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gbGFzdFNob3VsZFRyYWNrO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWZlclN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICAvLyBzdG9wcGVkIHdoaWxlIHJ1bm5pbmcgaXRzZWxmIC0gZGVmZXIgdGhlIGNsZWFudXBcbiAgICAgICAgaWYgKGFjdGl2ZUVmZmVjdCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5kZWZlclN0b3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25TdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGVmZmVjdCkge1xuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xuICAgIGlmIChkZXBzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVwcy5sZW5ndGggPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xuICAgIGlmIChmbi5lZmZlY3QpIHtcbiAgICAgICAgZm4gPSBmbi5lZmZlY3QuZm47XG4gICAgfVxuICAgIGNvbnN0IF9lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChfZWZmZWN0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpXG4gICAgICAgICAgICByZWNvcmRFZmZlY3RTY29wZShfZWZmZWN0LCBvcHRpb25zLnNjb3BlKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmxhenkpIHtcbiAgICAgICAgX2VmZmVjdC5ydW4oKTtcbiAgICB9XG4gICAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcbiAgICBydW5uZXIuZWZmZWN0ID0gX2VmZmVjdDtcbiAgICByZXR1cm4gcnVubmVyO1xufVxuZnVuY3Rpb24gc3RvcChydW5uZXIpIHtcbiAgICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XG4gICAgICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgICAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCAoZGVwc01hcCA9IG5ldyBNYXAoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWRlcCkge1xuICAgICAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gY3JlYXRlRGVwKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRyYWNrRWZmZWN0cyhkZXAsIGV2ZW50SW5mbyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICAgIGxldCBzaG91bGRUcmFjayA9IGZhbHNlO1xuICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgaWYgKCFuZXdUcmFja2VkKGRlcCkpIHtcbiAgICAgICAgICAgIGRlcC5uIHw9IHRyYWNrT3BCaXQ7IC8vIHNldCBuZXdseSB0cmFja2VkXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9ICF3YXNUcmFja2VkKGRlcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZ1bGwgY2xlYW51cCBtb2RlLlxuICAgICAgICBzaG91bGRUcmFjayA9ICFkZXAuaGFzKGFjdGl2ZUVmZmVjdCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhY3RpdmVFZmZlY3Qub25UcmFjaykge1xuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soT2JqZWN0LmFzc2lnbih7IGVmZmVjdDogYWN0aXZlRWZmZWN0IH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gICAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlcHMgPSBbXTtcbiAgICBpZiAodHlwZSA9PT0gXCJjbGVhclwiIC8qIFRyaWdnZXJPcFR5cGVzLkNMRUFSICovKSB7XG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxuICAgICAgICAvLyB0cmlnZ2VyIGFsbCBlZmZlY3RzIGZvciB0YXJnZXRcbiAgICAgICAgZGVwcyA9IFsuLi5kZXBzTWFwLnZhbHVlcygpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gTnVtYmVyKG5ld1ZhbHVlKTtcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcgfHwga2V5ID49IG5ld0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNjaGVkdWxlIHJ1bnMgZm9yIFNFVCB8IEFERCB8IERFTEVURVxuICAgICAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHNvIHJ1biBmb3IgaXRlcmF0aW9uIGtleSBvbiBBREQgfCBERUxFVEUgfCBNYXAuU0VUXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGluZGV4IGFkZGVkIHRvIGFycmF5IC0+IGxlbmd0aCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldCgnbGVuZ3RoJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi86XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXZlbnRJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgID8geyB0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZGVwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGRlcHNbMF0pIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdLCBldmVudEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaCguLi5kZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSwgZXZlbnRJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgICAvLyBzcHJlYWQgaW50byBhcnJheSBmb3Igc3RhYmlsaXphdGlvblxuICAgIGNvbnN0IGVmZmVjdHMgPSBpc0FycmF5KGRlcCkgPyBkZXAgOiBbLi4uZGVwXTtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgIGlmIChlZmZlY3QuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgIGlmICghZWZmZWN0LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0KGVmZmVjdCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICAgIGlmIChlZmZlY3QgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QuYWxsb3dSZWN1cnNlKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9uVHJpZ2dlcikge1xuICAgICAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlcihleHRlbmQoeyBlZmZlY3QgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3Quc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICBlZmZlY3Quc2NoZWR1bGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3QucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRhcmdldE1hcC5nZXQob2JqZWN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuLyojX19QVVJFX18qL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKVxuICAgIC8vIGlvczEwLnggT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKSBjYW4gZW51bWVyYXRlICdhcmd1bWVudHMnIGFuZCAnY2FsbGVyJ1xuICAgIC8vIGJ1dCBhY2Nlc3NpbmcgdGhlbSBvbiBTeW1ib2wgbGVhZHMgdG8gVHlwZUVycm9yIGJlY2F1c2UgU3ltYm9sIGlzIGEgc3RyaWN0IG1vZGVcbiAgICAvLyBmdW5jdGlvblxuICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ2FyZ3VtZW50cycgJiYga2V5ICE9PSAnY2FsbGVyJylcbiAgICAubWFwKGtleSA9PiBTeW1ib2xba2V5XSlcbiAgICAuZmlsdGVyKGlzU3ltYm9sKSk7XG5jb25zdCBnZXQkMSA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKCk7XG5jb25zdCBzaGFsbG93R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xuY29uc3QgcmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyojX19QVVJFX18qLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpIHtcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge307XG4gICAgWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2soYXJyLCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sIGkgKyAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXJyW2tleV0oLi4uYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycltrZXldKC4uLmFyZ3MubWFwKHRvUmF3KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9ucztcbn1cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KGtleSkge1xuICAgIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICAgIHRyYWNrKG9iaiwgXCJoYXNcIiAvKiBUcmFja09wVHlwZXMuSEFTICovLCBrZXkpO1xuICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5ID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQUNUSVZFICovKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi8gJiZcbiAgICAgICAgICAgIHJlY2VpdmVyID09PVxuICAgICAgICAgICAgICAgIChpc1JlYWRvbmx5XG4gICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhZG9ubHlNYXBcbiAgICAgICAgICAgICAgICAgICAgOiBzaGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFjdGl2ZU1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnaGFzT3duUHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIHNraXAgdW53cmFwIGZvciBBcnJheSArIGludGVnZXIga2V5LlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyByZXMgOiByZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xuICAgICAgICAgICAgLy8gaGVyZSB0byBhdm9pZCBpbnZhbGlkIHZhbHVlIHdhcm5pbmcuIEFsc28gbmVlZCB0byBsYXp5IGFjY2VzcyByZWFkb25seVxuICAgICAgICAgICAgLy8gYW5kIHJlYWN0aXZlIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuY29uc3Qgc2V0JDEgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcigpO1xuY29uc3Qgc2hhbGxvd1NldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKGlzUmVhZG9ubHkob2xkVmFsdWUpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpXG4gICAgICAgICAgICA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aFxuICAgICAgICAgICAgOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHVwIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb2Ygb3JpZ2luYWxcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoYXMkMSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiAvKiBUcmFja09wVHlwZXMuSEFTICovLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiIC8qIFRyYWNrT3BUeXBlcy5JVEVSQVRFICovLCBpc0FycmF5KHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBnZXQkMSxcbiAgICBzZXQ6IHNldCQxLFxuICAgIGRlbGV0ZVByb3BlcnR5LFxuICAgIGhhczogaGFzJDEsXG4gICAgb3duS2V5c1xufTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSB7XG4gICAgZ2V0OiByZWFkb25seUdldCxcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XG4gICAgZ2V0OiBzaGFsbG93R2V0LFxuICAgIHNldDogc2hhbGxvd1NldFxufSk7XG4vLyBQcm9wcyBoYW5kbGVycyBhcmUgc3BlY2lhbCBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBzaG91bGQgbm90IHVud3JhcCB0b3AtbGV2ZWxcbi8vIHJlZnMgKGluIG9yZGVyIHRvIGFsbG93IHJlZnMgdG8gYmUgZXhwbGljaXRseSBwYXNzZWQgZG93biksIGJ1dCBzaG91bGRcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxufSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgLy8gIzE3NzI6IHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpIHNob3VsZCByZXR1cm4gcmVhZG9ubHkgKyByZWFjdGl2ZSB2ZXJzaW9uXG4gICAgLy8gb2YgdGhlIHZhbHVlXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sIHJhd0tleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcbiAgICAgICAgLy8gIzM2MDIgcmVhZG9ubHkocmVhY3RpdmUoTWFwKSlcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG5lc3RlZCByZWFjdGl2ZSBgTWFwYCBjYW4gZG8gdHJhY2tpbmcgZm9yIGl0c2VsZlxuICAgICAgICB0YXJnZXQuZ2V0KGtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgIGlmICghaXNSZWFkb25seSkge1xuICAgICAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBUcmFja09wVHlwZXMuSEFTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBUcmFja09wVHlwZXMuSEFTICovLCByYXdLZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5ID09PSByYXdLZXlcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xufVxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLywgdmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8sIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldCA/IGdldC5jYWxsKHRhcmdldCwga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICBpZiAoaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgID8gaXNNYXAodGFyZ2V0KVxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gICAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogVHJpZ2dlck9wVHlwZXMuQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBUcmFja09wVHlwZXMuSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXG4gICAgICAgICAgICAvLyAyLiB0aGUgdmFsdWUgcmVjZWl2ZWQgc2hvdWxkIGJlIGEgY29ycmVzcG9uZGluZyByZWFjdGl2ZS9yZWFkb25seS5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gJ2VudHJpZXMnIHx8IChtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcCk7XG4gICAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gJ2tleXMnICYmIHRhcmdldElzTWFwO1xuICAgICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAgICFpc1JlYWRvbmx5ICYmXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIFRyYWNrT3BUeXBlcy5JVEVSQVRFICovLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xuICAgICAgICAvLyByZXR1cm4gYSB3cmFwcGVkIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgb2JzZXJ2ZWQgdmVyc2lvbnMgb2YgdGhlXG4gICAgICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXG4gICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZSwgZG9uZSB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLyA/IGZhbHNlIDogdGhpcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpIHtcbiAgICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMsXG4gICAgICAgIGFkZCxcbiAgICAgICAgc2V0LFxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgICAgICBjbGVhcixcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXG4gICAgfTtcbiAgICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzLFxuICAgICAgICBhZGQsXG4gICAgICAgIHNldCxcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXG4gICAgfTtcbiAgICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8pLFxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovKSxcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLyksXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogVHJpZ2dlck9wVHlwZXMuQ0xFQVIgKi8pLFxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxuICAgIH07XG4gICAgY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyksXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8pLFxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovKSxcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBUcmlnZ2VyT3BUeXBlcy5DTEVBUiAqLyksXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgICB9O1xuICAgIGNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcycsIFN5bWJvbC5pdGVyYXRvcl07XG4gICAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIHRydWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMsXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG4gICAgXTtcbn1cbmNvbnN0IFttdXRhYmxlSW5zdHJ1bWVudGF0aW9ucywgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc10gPSAvKiAjX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93XG4gICAgICAgID8gaXNSZWFkb25seVxuICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG4gICAgICAgICAgICA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXG4gICAgICAgIDogaXNSZWFkb25seVxuICAgICAgICAgICAgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnNcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICB9O1xufVxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXG59O1xuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxufTtcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xuICAgICAgICBjb25zb2xlLndhcm4oYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSBgICtcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcbiAgICAgICAgICAgIGBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBgICtcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xuICAgIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVGFyZ2V0VHlwZS5DT01NT04gKi87XG4gICAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFRhcmdldFR5cGUuQ09MTEVDVElPTiAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFRhcmdldFR5cGUuSU5WQUxJRCAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi9dIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKVxuICAgICAgICA/IDAgLyogVGFyZ2V0VHlwZS5JTlZBTElEICovXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcbiAqIHJvb3QgbGV2ZWwpLlxuICovXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhY3RpdmVNYXApO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seU1hcCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cbiAgICAvLyBleGNlcHRpb246IGNhbGxpbmcgcmVhZG9ubHkoKSBvbiBhIHJlYWN0aXZlIG9iamVjdFxuICAgIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dICYmXG4gICAgICAgICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi9dKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyB0YXJnZXQgYWxyZWFkeSBoYXMgY29ycmVzcG9uZGluZyBQcm94eVxuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgICB9XG4gICAgLy8gb25seSBzcGVjaWZpYyB2YWx1ZSB0eXBlcyBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBUYXJnZXRUeXBlLklOVkFMSUQgKi8pIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIFRhcmdldFR5cGUuQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dKTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQUNUSVZFICovXSk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8sIHRydWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmKSB7XG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgICAgICByZWYgPSB0b1JhdyhyZWYpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZlZhbHVlKHJlZiwgbmV3VmFsKSB7XG4gICAgcmVmID0gdG9SYXcocmVmKTtcbiAgICBjb25zdCBkZXAgPSByZWYuZGVwO1xuICAgIGlmIChkZXApIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcbn1cbmNsYXNzIFJlZkltcGwge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBfX3ZfaXNTaGFsbG93KSB7XG4gICAgICAgIHRoaXMuX192X2lzU2hhbGxvdyA9IF9fdl9pc1NoYWxsb3c7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICBjb25zdCB1c2VEaXJlY3RWYWx1ZSA9IHRoaXMuX192X2lzU2hhbGxvdyB8fCBpc1NoYWxsb3cobmV3VmFsKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbCk7XG4gICAgICAgIG5ld1ZhbCA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SYXcobmV3VmFsKTtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsLCB0aGlzLl9yYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbCA6IHRvUmVhY3RpdmUobmV3VmFsKTtcbiAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzLCBuZXdWYWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcbiAgICB0cmlnZ2VyUmVmVmFsdWUocmVmLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyByZWYudmFsdWUgOiB2b2lkIDApO1xufVxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XG59XG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKVxuICAgICAgICA/IG9iamVjdFdpdGhSZWZzXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHRyYWNrUmVmVmFsdWUodGhpcyksICgpID0+IHRyaWdnZXJSZWZWYWx1ZSh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2dldCA9IGdldDtcbiAgICAgICAgdGhpcy5fc2V0ID0gc2V0O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQoKTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLl9zZXQobmV3VmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcbiAgICB9XG4gICAgZ2V0IGRlcCgpIHtcbiAgICAgICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcbiAgICByZXR1cm4gaXNSZWYodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IG5ldyBPYmplY3RSZWZJbXBsKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpO1xufVxuXG52YXIgX2EkMTtcbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgICB0aGlzW19hJDFdID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcztcbiAgICAgICAgdGhpcy5lZmZlY3QuYWN0aXZlID0gdGhpcy5fY2FjaGVhYmxlID0gIWlzU1NSO1xuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRvUmF3KHRoaXMpO1xuICAgICAgICB0cmFja1JlZlZhbHVlKHNlbGYpO1xuICAgICAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gc2VsZi5lZmZlY3QucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcbiAgICB9XG59XG5fYSQxID0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi87XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICAgIGxldCBnZXR0ZXI7XG4gICAgbGV0IHNldHRlcjtcbiAgICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xuICAgIGlmIChvbmx5R2V0dGVyKSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IE5PT1A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICAgIH1cbiAgICBjb25zdCBjUmVmID0gbmV3IENvbXB1dGVkUmVmSW1wbChnZXR0ZXIsIHNldHRlciwgb25seUdldHRlciB8fCAhc2V0dGVyLCBpc1NTUik7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XG4gICAgICAgIGNSZWYuZWZmZWN0Lm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgICB9XG4gICAgcmV0dXJuIGNSZWY7XG59XG5cbnZhciBfYTtcbmNvbnN0IHRpY2sgPSAvKiNfX1BVUkVfXyovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBxdWV1ZWQgPSBmYWxzZTtcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xuICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgIGlmICghcXVldWVkKSB7XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRpY2sudGhlbihmbHVzaCk7XG4gICAgfVxufTtcbmNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0oKTtcbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBxdWV1ZWQgPSBmYWxzZTtcbn07XG5jbGFzcyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZ2V0dGVyKSB7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgICAgICBsZXQgY29tcGFyZVRhcmdldDtcbiAgICAgICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIChjb21wdXRlZFRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZVRhcmdldCA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRvQ29tcGFyZSA9IGhhc0NvbXBhcmVUYXJnZXQgPyBjb21wYXJlVGFyZ2V0IDogdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVmZmVjdC5hY3RpdmUgJiYgdGhpcy5fZ2V0KCkgIT09IHZhbHVlVG9Db21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGFpbmVkIHVwc3RyZWFtIGNvbXB1dGVkcyBhcmUgbm90aWZpZWQgc3luY2hyb25vdXNseSB0byBlbnN1cmVcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpbnZhbGlkYXRpb24gaW4gY2FzZSBvZiBzeW5jIGFjY2Vzczsgbm9ybWFsIGVmZmVjdHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQgdG8gYmUgdHJpZ2dlcmVkIGluIHNjaGVkdWxlci5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29tcHV0ZWQgaW5zdGFuY2VvZiBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zY2hlZHVsZXIodHJ1ZSAvKiBjb21wdXRlZFRyaWdnZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgIH1cbiAgICBfZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxuICAgICAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xuICAgIH1cbn1cbl9hID0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi87XG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xuICAgIHJldHVybiBuZXcgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwoZ2V0dGVyKTtcbn1cblxuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIElURVJBVEVfS0VZLCBSZWFjdGl2ZUVmZmVjdCwgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZGVmZXJyZWRDb21wdXRlZCwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJhY2ssIHRyaWdnZXIsIHRyaWdnZXJSZWYsIHVucmVmIH07XG4iXSwibmFtZXMiOlsiZXh0ZW5kIiwiaXNBcnJheSIsImlzTWFwIiwiaXNJbnRlZ2VyS2V5IiwiaGFzT3duIiwiaXNTeW1ib2wiLCJpc09iamVjdCIsImhhc0NoYW5nZWQiLCJtYWtlTWFwIiwiY2FwaXRhbGl6ZSIsInRvUmF3VHlwZSIsImRlZiIsImlzRnVuY3Rpb24iLCJOT09QIiwid2FybiIsIm1zZyIsImFyZ3MiLCJjb25zb2xlIiwiYWN0aXZlRWZmZWN0U2NvcGUiLCJFZmZlY3RTY29wZSIsImNvbnN0cnVjdG9yIiwiZGV0YWNoZWQiLCJfYWN0aXZlIiwiZWZmZWN0cyIsImNsZWFudXBzIiwicGFyZW50IiwiaW5kZXgiLCJzY29wZXMiLCJwdXNoIiwiYWN0aXZlIiwicnVuIiwiZm4iLCJjdXJyZW50RWZmZWN0U2NvcGUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJvbiIsIm9mZiIsInN0b3AiLCJmcm9tUGFyZW50IiwiaSIsImwiLCJsZW5ndGgiLCJsYXN0IiwicG9wIiwidW5kZWZpbmVkIiwiZWZmZWN0U2NvcGUiLCJyZWNvcmRFZmZlY3RTY29wZSIsImVmZmVjdCIsInNjb3BlIiwiZ2V0Q3VycmVudFNjb3BlIiwib25TY29wZURpc3Bvc2UiLCJjcmVhdGVEZXAiLCJkZXAiLCJTZXQiLCJ3IiwibiIsIndhc1RyYWNrZWQiLCJ0cmFja09wQml0IiwibmV3VHJhY2tlZCIsImluaXREZXBNYXJrZXJzIiwiZGVwcyIsImZpbmFsaXplRGVwTWFya2VycyIsInB0ciIsImRlbGV0ZSIsInRhcmdldE1hcCIsIldlYWtNYXAiLCJlZmZlY3RUcmFja0RlcHRoIiwibWF4TWFya2VyQml0cyIsImFjdGl2ZUVmZmVjdCIsIklURVJBVEVfS0VZIiwiU3ltYm9sIiwiTUFQX0tFWV9JVEVSQVRFX0tFWSIsIlJlYWN0aXZlRWZmZWN0Iiwic2NoZWR1bGVyIiwibGFzdFNob3VsZFRyYWNrIiwic2hvdWxkVHJhY2siLCJjbGVhbnVwRWZmZWN0IiwiZGVmZXJTdG9wIiwib25TdG9wIiwib3B0aW9ucyIsIl9lZmZlY3QiLCJsYXp5IiwicnVubmVyIiwiYmluZCIsInRyYWNrU3RhY2siLCJwYXVzZVRyYWNraW5nIiwiZW5hYmxlVHJhY2tpbmciLCJyZXNldFRyYWNraW5nIiwidHJhY2siLCJ0YXJnZXQiLCJ0eXBlIiwia2V5IiwiZGVwc01hcCIsImdldCIsInNldCIsIk1hcCIsImV2ZW50SW5mbyIsInRyYWNrRWZmZWN0cyIsImRlYnVnZ2VyRXZlbnRFeHRyYUluZm8iLCJoYXMiLCJhZGQiLCJvblRyYWNrIiwiT2JqZWN0IiwiYXNzaWduIiwidHJpZ2dlciIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJvbGRUYXJnZXQiLCJ2YWx1ZXMiLCJuZXdMZW5ndGgiLCJOdW1iZXIiLCJmb3JFYWNoIiwidHJpZ2dlckVmZmVjdHMiLCJjb21wdXRlZCIsInRyaWdnZXJFZmZlY3QiLCJhbGxvd1JlY3Vyc2UiLCJvblRyaWdnZXIiLCJnZXREZXBGcm9tUmVhY3RpdmUiLCJvYmplY3QiLCJfYSIsImlzTm9uVHJhY2thYmxlS2V5cyIsImJ1aWx0SW5TeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpbHRlciIsIm1hcCIsImdldCQxIiwiY3JlYXRlR2V0dGVyIiwic2hhbGxvd0dldCIsInJlYWRvbmx5R2V0Iiwic2hhbGxvd1JlYWRvbmx5R2V0IiwiYXJyYXlJbnN0cnVtZW50YXRpb25zIiwiY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zIiwiaW5zdHJ1bWVudGF0aW9ucyIsImFyciIsInRvUmF3IiwicmVzIiwiYXBwbHkiLCJoYXNPd25Qcm9wZXJ0eSIsIm9iaiIsImlzUmVhZG9ubHkiLCJzaGFsbG93IiwicmVjZWl2ZXIiLCJzaGFsbG93UmVhZG9ubHlNYXAiLCJyZWFkb25seU1hcCIsInNoYWxsb3dSZWFjdGl2ZU1hcCIsInJlYWN0aXZlTWFwIiwidGFyZ2V0SXNBcnJheSIsIlJlZmxlY3QiLCJpc1JlZiIsInZhbHVlIiwicmVhZG9ubHkiLCJyZWFjdGl2ZSIsInNldCQxIiwiY3JlYXRlU2V0dGVyIiwic2hhbGxvd1NldCIsImlzU2hhbGxvdyIsImhhZEtleSIsInJlc3VsdCIsImRlbGV0ZVByb3BlcnR5IiwiaGFzJDEiLCJvd25LZXlzIiwibXV0YWJsZUhhbmRsZXJzIiwicmVhZG9ubHlIYW5kbGVycyIsIlN0cmluZyIsInNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzIiwic2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMiLCJ0b1NoYWxsb3ciLCJnZXRQcm90byIsInYiLCJnZXRQcm90b3R5cGVPZiIsInJhd1RhcmdldCIsInJhd0tleSIsIndyYXAiLCJ0b1JlYWRvbmx5IiwidG9SZWFjdGl2ZSIsImNhbGwiLCJzaXplIiwicHJvdG8iLCJjaGVja0lkZW50aXR5S2V5cyIsImRlbGV0ZUVudHJ5IiwiY2xlYXIiLCJoYWRJdGVtcyIsImNyZWF0ZUZvckVhY2giLCJjYWxsYmFjayIsInRoaXNBcmciLCJvYnNlcnZlZCIsImNyZWF0ZUl0ZXJhYmxlTWV0aG9kIiwibWV0aG9kIiwidGFyZ2V0SXNNYXAiLCJpc1BhaXIiLCJpdGVyYXRvciIsImlzS2V5T25seSIsImlubmVySXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsImNyZWF0ZVJlYWRvbmx5TWV0aG9kIiwiY3JlYXRlSW5zdHJ1bWVudGF0aW9ucyIsIm11dGFibGVJbnN0cnVtZW50YXRpb25zIiwic2hhbGxvd0luc3RydW1lbnRhdGlvbnMiLCJyZWFkb25seUluc3RydW1lbnRhdGlvbnMiLCJzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIiwiaXRlcmF0b3JNZXRob2RzIiwiY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyIiwibXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyIsInNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMiLCJyZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyIsInNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyIsInRhcmdldFR5cGVNYXAiLCJyYXdUeXBlIiwiZ2V0VGFyZ2V0VHlwZSIsImlzRXh0ZW5zaWJsZSIsImNyZWF0ZVJlYWN0aXZlT2JqZWN0Iiwic2hhbGxvd1JlYWN0aXZlIiwic2hhbGxvd1JlYWRvbmx5IiwiYmFzZUhhbmRsZXJzIiwiY29sbGVjdGlvbkhhbmRsZXJzIiwicHJveHlNYXAiLCJleGlzdGluZ1Byb3h5IiwidGFyZ2V0VHlwZSIsInByb3h5IiwiUHJveHkiLCJpc1JlYWN0aXZlIiwiaXNQcm94eSIsInJhdyIsIm1hcmtSYXciLCJ0cmFja1JlZlZhbHVlIiwicmVmIiwidHJpZ2dlclJlZlZhbHVlIiwibmV3VmFsIiwiciIsIl9fdl9pc1JlZiIsImNyZWF0ZVJlZiIsInNoYWxsb3dSZWYiLCJyYXdWYWx1ZSIsIlJlZkltcGwiLCJfX3ZfaXNTaGFsbG93IiwiX3Jhd1ZhbHVlIiwiX3ZhbHVlIiwidXNlRGlyZWN0VmFsdWUiLCJ0cmlnZ2VyUmVmIiwidW5yZWYiLCJzaGFsbG93VW53cmFwSGFuZGxlcnMiLCJwcm94eVJlZnMiLCJvYmplY3RXaXRoUmVmcyIsIkN1c3RvbVJlZkltcGwiLCJmYWN0b3J5IiwiX2dldCIsIl9zZXQiLCJjdXN0b21SZWYiLCJ0b1JlZnMiLCJyZXQiLCJBcnJheSIsInRvUmVmIiwiT2JqZWN0UmVmSW1wbCIsIl9vYmplY3QiLCJfa2V5IiwiX2RlZmF1bHRWYWx1ZSIsInZhbCIsImRlZmF1bHRWYWx1ZSIsIl9hJDEiLCJDb21wdXRlZFJlZkltcGwiLCJnZXR0ZXIiLCJfc2V0dGVyIiwiaXNTU1IiLCJfZGlydHkiLCJfY2FjaGVhYmxlIiwic2VsZiIsImdldHRlck9yT3B0aW9ucyIsImRlYnVnT3B0aW9ucyIsInNldHRlciIsIm9ubHlHZXR0ZXIiLCJjUmVmIiwidGljayIsIlByb21pc2UiLCJyZXNvbHZlIiwicXVldWUiLCJxdWV1ZWQiLCJ0aGVuIiwiZmx1c2giLCJEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCIsImNvbXBhcmVUYXJnZXQiLCJoYXNDb21wYXJlVGFyZ2V0Iiwic2NoZWR1bGVkIiwiY29tcHV0ZWRUcmlnZ2VyIiwidmFsdWVUb0NvbXBhcmUiLCJlIiwiZGVmZXJyZWRDb21wdXRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4870\n')},3396:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$d\": function() { return /* binding */ callWithAsyncErrorHandling; },\n/* harmony export */   \"FN\": function() { return /* binding */ getCurrentInstance; },\n/* harmony export */   \"Fl\": function() { return /* binding */ computed; },\n/* harmony export */   \"HY\": function() { return /* binding */ Fragment; },\n/* harmony export */   \"JJ\": function() { return /* binding */ provide; },\n/* harmony export */   \"Ko\": function() { return /* binding */ renderList; },\n/* harmony export */   \"P$\": function() { return /* binding */ BaseTransition; },\n/* harmony export */   \"Q6\": function() { return /* binding */ getTransitionRawChildren; },\n/* harmony export */   \"U2\": function() { return /* binding */ resolveTransitionHooks; },\n/* harmony export */   \"Uk\": function() { return /* binding */ createTextVNode; },\n/* harmony export */   \"Us\": function() { return /* binding */ createRenderer; },\n/* harmony export */   \"Wm\": function() { return /* binding */ createVNode; },\n/* harmony export */   \"Y3\": function() { return /* binding */ nextTick; },\n/* harmony export */   \"Y8\": function() { return /* binding */ useTransitionState; },\n/* harmony export */   \"YP\": function() { return /* binding */ watch; },\n/* harmony export */   \"_\": function() { return /* binding */ createBaseVNode; },\n/* harmony export */   \"aZ\": function() { return /* binding */ defineComponent; },\n/* harmony export */   \"f3\": function() { return /* binding */ inject; },\n/* harmony export */   \"h\": function() { return /* binding */ h; },\n/* harmony export */   \"iD\": function() { return /* binding */ createElementBlock; },\n/* harmony export */   \"ic\": function() { return /* binding */ onUpdated; },\n/* harmony export */   \"j4\": function() { return /* binding */ createBlock; },\n/* harmony export */   \"nK\": function() { return /* binding */ setTransitionHooks; },\n/* harmony export */   \"up\": function() { return /* binding */ resolveComponent; },\n/* harmony export */   \"w5\": function() { return /* binding */ withCtx; },\n/* harmony export */   \"wg\": function() { return /* binding */ openBlock; },\n/* harmony export */   \"wy\": function() { return /* binding */ withDirectives; }\n/* harmony export */ });\n/* unused harmony exports Comment, KeepAlive, Static, Suspense, Teleport, Text, assertNumber, callWithErrorHandling, cloneVNode, compatUtils, createCommentVNode, createHydrationRenderer, createPropsRestProxy, createSlots, createStaticVNode, defineAsyncComponent, defineEmits, defineExpose, defineProps, devtools, guardReactiveProps, handleError, initCustomFormatter, isMemoSame, isRuntimeOnly, isVNode, mergeDefaults, mergeProps, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onServerPrefetch, onUnmounted, popScopeId, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderSlot, resolveDirective, resolveDynamicComponent, resolveFilter, setBlockTracking, setDevtoolsHook, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useAttrs, useSSRContext, useSlots, version, warn, watchEffect, watchPostEffect, watchSyncEffect, withAsyncContext, withDefaults, withMemo, withScopeId */\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(541);\n/* harmony import */ var core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4870);\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7139);\n\n\n\n\n\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nfunction warn(msg, ...args) {\n  if (true) return;\n  // avoid props formatting or warn handler tracking deps that might be mutated\n  // during patch, leading to infinite recursion.\n  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .pauseTracking */ .Jd)();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [msg + args.join(''), instance && instance.proxy, trace.map(({\n      vnode\n    }) => `at <${formatComponentName(instance, vnode.type)}>`).join('\\n'), trace]);\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    /* istanbul ignore if */\n    if (trace.length &&\n    // avoid spamming console during tests\n    !false) {\n      warnArgs.push(`\\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .resetTracking */ .lk)();\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  // we can't just use the stack because it will be incomplete during updates\n  // that did not start from the root. Re-construct the parent chain using\n  // instance parent pointers.\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\n/* istanbul ignore next */\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({\n  vnode,\n  recurseCount\n}) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\n/* istanbul ignore next */\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\n/* istanbul ignore next */\nfunction formatProp(key, value, raw) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(value)) {\n    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .IU)(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .IU)(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\n/**\n * @internal\n */\nfunction assertNumber(val, type) {\n  if (true) return;\n  if (val === undefined) {\n    return;\n  } else if (typeof val !== 'number') {\n    warn(`${type} is not a valid number - ` + `got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    warn(`${type} is NaN - ` + 'the duration expression might be incorrect.');\n  }\n}\nconst ErrorTypeStrings = {\n  [\"sp\" /* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',\n  [\"bc\" /* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',\n  [\"c\" /* LifecycleHooks.CREATED */]: 'created hook',\n  [\"bm\" /* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',\n  [\"m\" /* LifecycleHooks.MOUNTED */]: 'mounted hook',\n  [\"bu\" /* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',\n  [\"u\" /* LifecycleHooks.UPDATED */]: 'updated',\n  [\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',\n  [\"um\" /* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',\n  [\"a\" /* LifecycleHooks.ACTIVATED */]: 'activated hook',\n  [\"da\" /* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',\n  [\"ec\" /* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',\n  [\"rtc\" /* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',\n  [\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',\n  [0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',\n  [1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',\n  [2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',\n  [3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',\n  [4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',\n  [5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',\n  [6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',\n  [7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',\n  [8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',\n  [9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',\n  [10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',\n  [11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',\n  [12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',\n  [13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',\n  [14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isPromise */ .tI)(res)) {\n      res.catch(err => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n  return values;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    // the exposed instance is the render proxy to keep it consistent with 2.x\n    const exposedInstance = instance.proxy;\n    // in production the hook receives only the error code\n    const errorInfo =  false ? 0 : type;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    // app-level handling\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (false) {} else {\n    // recover in prod to reduce the impact on end-user\n    console.error(err);\n  }\n}\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /*#__PURE__*/Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\n// #2768\n// Use binary-search to find a suitable position in the queue,\n// so that the queue maintains the increasing order of job's id,\n// which can prevent the job from being skipped and also can avoid repeated patching.\nfunction findInsertionIndex(id) {\n  // the start index should be `flushIndex + 1`\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJobId = getId(queue[middle]);\n    middleJobId < id ? start = middle + 1 : end = middle;\n  }\n  return start;\n}\nfunction queueJob(job) {\n  // the dedupe search uses the startIndex argument of Array.includes()\n  // by default the search index includes the current job that is being run\n  // so it cannot recursively trigger itself again.\n  // if the job is a watch() callback, the search will start with a +1 index to\n  // allow it recursively trigger itself - it is the user's responsibility to\n  // ensure it doesn't end up in an infinite loop.\n  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {\n    if (job.id == null) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction invalidateJob(job) {\n  const i = queue.indexOf(job);\n  if (i > flushIndex) {\n    queue.splice(i, 1);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(cb)) {\n    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {\n      pendingPostFlushCbs.push(cb);\n    }\n  } else {\n    // if cb is an array, it is a component lifecycle hook which can only be\n    // triggered by a job, which is already deduped in the main queue, so\n    // we can skip duplicate check here to improve perf\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(seen,\n// if currently flushing, skip the current job itself\ni = isFlushing ? flushIndex + 1 : 0) {\n  if (false) {}\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.pre) {\n      if (false) {}\n      queue.splice(i, 1);\n      i--;\n      cb();\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0;\n    // #1947 already has active queue, nested flushPostFlushCbs call\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (false) {}\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if (false) {}\n      activePostFlushCbs[postFlushIndex]();\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = job => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n  const diff = getId(a) - getId(b);\n  if (diff === 0) {\n    if (a.pre && !b.pre) return -1;\n    if (b.pre && !a.pre) return 1;\n  }\n  return diff;\n};\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  if (false) {}\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child so its render effect will have smaller\n  //    priority number)\n  // 2. If a component is unmounted during a parent component's update,\n  //    its update can be skipped.\n  queue.sort(comparator);\n  // conditional usage of checkRecursiveUpdate must be determined out of\n  // try ... catch block since Rollup by default de-optimizes treeshaking\n  // inside try-catch. This can leave all warning code unshaked. Although\n  // they would get eventually shaken by a minifier like terser, some minifiers\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n  const check =  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && job.active !== false) {\n        if (false) {}\n        // console.log(`running:`, job.id)\n        callWithErrorHandling(job, null, 14 /* ErrorCodes.SCHEDULER */);\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null;\n    // some postFlushCb queued jobs!\n    // keep flushing until it drains.\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1);\n  } else {\n    const count = seen.get(fn);\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance;\n      const componentName = instance && getComponentName(instance.type);\n      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` + `This means you have a reactive effect that is mutating its own ` + `dependencies and thus recursively triggering itself. Possible sources ` + `include component template, render function, updated hook or ` + `watcher source function.`);\n      return true;\n    } else {\n      seen.set(fn, count + 1);\n    }\n  }\n}\n\n/* eslint-disable no-restricted-globals */\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = new Set();\n// Expose the HMR runtime on the global object\n// This makes it entirely tree-shakable without polluting the exports and makes\n// it easier to be used in toolings like vue-loader\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\n// to be set so that its instances can be registered / removed.\nif (false) {}\nconst map = new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  // update initial record (for not-yet-rendered component)\n  record.initialDef.render = newRender;\n  [...record.instances].forEach(instance => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    // this flag forces child components with slot content to update\n    isHmrUpdating = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return;\n  newComp = normalizeClassComponent(newComp);\n  // update initial def (for not-yet-rendered components)\n  updateComponentDef(record.initialDef, newComp);\n  // create a snapshot which avoids the set being mutated during updates\n  const instances = [...record.instances];\n  for (const instance of instances) {\n    const oldComp = normalizeClassComponent(instance.type);\n    if (!hmrDirtyComponents.has(oldComp)) {\n      // 1. Update existing comp definition to match new one\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      // 2. mark definition dirty. This forces the renderer to replace the\n      // component on patch.\n      hmrDirtyComponents.add(oldComp);\n    }\n    // 3. invalidate options resolution cache\n    instance.appContext.optionsCache.delete(instance.type);\n    // 4. actually update\n    if (instance.ceReload) {\n      // custom element\n      hmrDirtyComponents.add(oldComp);\n      instance.ceReload(newComp.styles);\n      hmrDirtyComponents.delete(oldComp);\n    } else if (instance.parent) {\n      // 4. Force the parent instance to re-render. This will cause all updated\n      // components to be unmounted and re-mounted. Queue the update so that we\n      // don't end up forcing the same parent to re-render multiple times.\n      queueJob(instance.parent.update);\n    } else if (instance.appContext.reload) {\n      // root instance mounted via createApp() has a reload method\n      instance.appContext.reload();\n    } else if (typeof window !== 'undefined') {\n      // root instance inside tree created via raw render(). Force reload.\n      window.location.reload();\n    } else {\n      console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\n    }\n  }\n  // 5. make sure to cleanup dirty hmr components after update\n  queuePostFlushCb(() => {\n    for (const instance of instances) {\n      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\n    }\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  extend(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== '__file' && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` + `Full reload required.`);\n    }\n  };\n}\nlet devtools;\nlet buffer = (/* unused pure expression or super */ null && ([]));\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n  if (devtools) {\n    devtools.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({\n      event,\n      args\n    });\n  }\n}\nfunction setDevtoolsHook(hook, target) {\n  var _a, _b;\n  devtools = hook;\n  if (devtools) {\n    devtools.enabled = true;\n    buffer.forEach(({\n      event,\n      args\n    }) => devtools.emit(event, ...args));\n    buffer = [];\n  } else if (\n  // handle late devtools injection - only do this if we are in an actual\n  // browser environment to avoid the timer handle stalling test runner exit\n  // (#4815)\n  typeof window !== 'undefined' &&\n  // some envs mock window but not fully\n  window.HTMLElement &&\n  // also exclude jsdom\n  !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push(newHook => {\n      setDevtoolsHook(newHook, target);\n    });\n    // clear buffer after 3s - the user probably doesn't have devtools installed\n    // at all, and keeping the buffer will cause memory leaks (#4738)\n    setTimeout(() => {\n      if (!devtools) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3000);\n  } else {\n    // non-browser env, assume not installed\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nfunction devtoolsInitApp(app, version) {\n  emit$1(\"app:init\" /* DevtoolsHooks.APP_INIT */, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1(\"app:unmount\" /* DevtoolsHooks.APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /*#__PURE__*/(/* unused pure expression or super */ null && (createDevtoolsComponentHook(\"component:added\" /* DevtoolsHooks.COMPONENT_ADDED */)));\nconst devtoolsComponentUpdated = /*#__PURE__*/(/* unused pure expression or super */ null && (createDevtoolsComponentHook(\"component:updated\" /* DevtoolsHooks.COMPONENT_UPDATED */)));\nconst _devtoolsComponentRemoved = /*#__PURE__*/(/* unused pure expression or super */ null && (createDevtoolsComponentHook(\"component:removed\" /* DevtoolsHooks.COMPONENT_REMOVED */)));\nconst devtoolsComponentRemoved = component => {\n  if (devtools && typeof devtools.cleanupBuffer === 'function' &&\n  // remove the component if it wasn't buffered\n  !devtools.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\nfunction createDevtoolsComponentHook(hook) {\n  return component => {\n    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\n  };\n}\nconst devtoolsPerfStart = /*#__PURE__*/(/* unused pure expression or super */ null && (createDevtoolsPerformanceHook(\"perf:start\" /* DevtoolsHooks.PERFORMANCE_START */)));\nconst devtoolsPerfEnd = /*#__PURE__*/(/* unused pure expression or super */ null && (createDevtoolsPerformanceHook(\"perf:end\" /* DevtoolsHooks.PERFORMANCE_END */)));\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1(\"component:emit\" /* DevtoolsHooks.COMPONENT_EMIT */, component.appContext.app, component, event, params);\n}\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted) return;\n  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n  if (false) {}\n  let args = rawArgs;\n  const isModelListener = event.startsWith('update:');\n  // for v-model update:xxx events, apply modifiers on args\n  const modelArg = isModelListener && event.slice(7);\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\n    const {\n      number,\n      trim\n    } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n    if (trim) {\n      args = rawArgs.map(a => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(a) ? a.trim() : a);\n    }\n    if (number) {\n      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .looseToNumber */ .h5);\n    }\n  }\n  if (false) {}\n  if (false) {}\n  let handlerName;\n  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .toHandlerKey */ .hR)(event)] ||\n  // also try camelCase event handler (#2249)\n  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .toHandlerKey */ .hR)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(event))];\n  // for v-model update:xxx events, also trigger kebab-case equivalent\n  // for props passed via kebab-case\n  if (!handler && isModelListener) {\n    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .toHandlerKey */ .hR)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hyphenate */ .rs)(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(handler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(onceHandler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  // apply mixin/extends props\n  let hasExtends = false;\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(comp)) {\n    const extendEmits = raw => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(raw)) {\n    raw.forEach(key => normalized[key] = null);\n  } else {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(normalized, raw);\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\n// Check if an incoming prop key is a declared emit event listener.\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\n// both considered matched listeners.\nfunction isEmitListener(options, key) {\n  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isOn */ .F7)(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, '');\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hyphenate */ .rs)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(options, key);\n}\n\n/**\n * mark the current rendering instance for asset resolution (e.g.\n * resolveComponent, resolveDirective) during render\n */\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\n/**\n * Note: rendering calls maybe nested. The function returns the parent rendering\n * instance if present, which should be restored after the render is done:\n *\n * ```js\n * const prev = setCurrentRenderingInstance(i)\n * // ...render\n * setCurrentRenderingInstance(prev)\n * ```\n */\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\n/**\n * Set scope id when creating hoisted vnodes.\n * @private compiler helper\n */\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\n/**\n * Technically we no longer need this after 3.0.8 but we need to keep the same\n * API for backwards compat w/ code generated by compilers.\n * @private\n */\nfunction popScopeId() {\n  currentScopeId = null;\n}\n/**\n * Only for backwards compat\n * @private\n */\nconst withScopeId = _id => withCtx;\n/**\n * Wrap a slot function to memoize current rendering instance\n * @private compiler helper\n */\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only\n) {\n  if (!ctx) return fn;\n  // already normalized\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    // If a user calls a compiled slot inside a template expression (#1745), it\n    // can mess up block tracking, so by default we disable block tracking and\n    // force bail out when invoking a compiled slot (indicated by the ._d flag).\n    // This isn't necessary if rendering a compiled `<slot>`, so we flip the\n    // ._d flag off when invoking the wrapped fn inside `renderSlot`.\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if (false) {}\n    return res;\n  };\n  // mark normalized to avoid duplicated wrapping\n  renderFnWithContext._n = true;\n  // mark this as compiled by default\n  // this is used in vnode.ts -> normalizeChildren() to set the slot\n  // rendering flag.\n  renderFnWithContext._c = true;\n  // disable block tracking by default\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\n\n/**\n * dev only flag to track whether $attrs was used during render.\n * If $attrs was used during render then the warning for failed attrs\n * fallthrough can be suppressed.\n */\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  let result;\n  let fallthroughAttrs;\n  const prev = setCurrentRenderingInstance(instance);\n  if (false) {}\n  try {\n    if (vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) {\n      // withProxy is a proxy with a different `has` trap only for\n      // runtime-compiled render functions using `with` block.\n      const proxyToUse = withProxy || proxy;\n      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\n      fallthroughAttrs = attrs;\n    } else {\n      // functional\n      const render = Component;\n      // in dev, mark attrs accessed if optional props (attrs === props)\n      if (false) {}\n      result = normalizeVNode(render.length > 1 ? render(props,  false ? 0 : {\n        attrs,\n        slots,\n        emit\n      }) : render(props, null /* we know it doesn't need it */));\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1 /* ErrorCodes.RENDER_FUNCTION */);\n    result = createVNode(Comment);\n  }\n  // attr merging\n  // in dev mode, comments are preserved, and it's possible for a template\n  // to have comments along side the root element which makes it a fragment\n  let root = result;\n  let setRoot = undefined;\n  if (false /* PatchFlags.DEV_ROOT_FRAGMENT */) {}\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const {\n      shapeFlag\n    } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 6 /* ShapeFlags.COMPONENT */)) {\n        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isModelListener */ .tR)) {\n          // If a v-model listener (onUpdate:xxx) has a corresponding declared\n          // prop, it indicates this component expects to handle v-model and\n          // it should not fallthrough.\n          // related: #1543, #1643, #1989\n          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n        }\n        root = cloneVNode(root, fallthroughAttrs);\n      } else if (false) {}\n    }\n  }\n  // inherit directives\n  if (vnode.dirs) {\n    if (false) {}\n    // clone before mutating since the root may be a hoisted vnode\n    root = cloneVNode(root);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  // inherit transition data\n  if (vnode.transition) {\n    if (false) {}\n    root.transition = vnode.transition;\n  }\n  if (false) {} else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\n/**\n * dev only\n * In dev mode, template root level comments are rendered, which turns the\n * template into a fragment root, but we need to locate the single element\n * root for attrs and scope id processing.\n */\nconst getChildRoot = vnode => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren);\n  if (!childRoot) {\n    return [vnode, undefined];\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = updatedRoot => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      // ignore user comment\n      if (child.type !== Comment || child.children === 'v-if') {\n        if (singleRoot) {\n          // has more than 1 non-comment child, return now\n          return;\n        } else {\n          singleRoot = child;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = attrs => {\n  let res;\n  for (const key in attrs) {\n    if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isOn */ .F7)(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isModelListener */ .tR)(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = vnode => {\n  return vnode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 1 /* ShapeFlags.ELEMENT */) || vnode.type === Comment // potential v-if branch switch\n  ;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const {\n    props: prevProps,\n    children: prevChildren,\n    component\n  } = prevVNode;\n  const {\n    props: nextProps,\n    children: nextChildren,\n    patchFlag\n  } = nextVNode;\n  const emits = component.emitsOptions;\n  // Parent component's render function was hot-updated. Since this may have\n  // caused the child component's slots content to have changed, we need to\n  // force the child to update as well.\n  if (false) {}\n  // force child update for runtime directive or transition on component vnode.\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024 /* PatchFlags.DYNAMIC_SLOTS */) {\n      // slot content that references values that might have changed,\n      // e.g. in a v-for\n      return true;\n    }\n    if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      // presence of this flag indicates props are always non-null\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8 /* PatchFlags.PROPS */) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // this path is only taken by manually written render functions\n    // so presence of any children leads to a forced update\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({\n  vnode,\n  parent\n}, el // HostNode\n) {\n  while (parent && parent.subTree === vnode) {\n    (vnode = parent.vnode).el = el;\n    parent = parent.parent;\n  }\n}\nconst isSuspense = type => type.__isSuspense;\n// Suspense exposes a component-like API, and is treated like a component\n// in the compiler, but internally it's a special built-in type that hooks\n// directly into the renderer.\nconst SuspenseImpl = {\n  name: 'Suspense',\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized,\n  // platform-specific impl passed from renderer\n  rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\n    } else {\n      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n};\n// Force-casted public typing for h and TSX props inference\nconst Suspense = (/* unused pure expression or super */ null && (SuspenseImpl));\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: {\n      createElement\n    }\n  } = rendererInternals;\n  const hiddenContainer = createElement('div');\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);\n  // start mounting the content subtree in an off-dom container\n  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\n  // now check if we have encountered any async deps\n  if (suspense.deps > 0) {\n    // has async\n    // invoke @fallback event\n    triggerEvent(vnode, 'onPending');\n    triggerEvent(vnode, 'onFallback');\n    // mount the fallback tree\n    patch(null, vnode.ssFallback, container, anchor, parentComponent, null,\n    // fallback tree will not have suspense context\n    isSVG, slotScopeIds);\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    // Suspense has no async deps. Just resolve.\n    suspense.resolve();\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, {\n  p: patch,\n  um: unmount,\n  o: {\n    createElement\n  }\n}) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const {\n    activeBranch,\n    pendingBranch,\n    isInFallback,\n    isHydrating\n  } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      // same root type but content may have changed.\n      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n        // fallback tree will not have suspense context\n        isSVG, slotScopeIds, optimized);\n        setActiveBranch(suspense, newFallback);\n      }\n    } else {\n      // toggled before pending tree is resolved\n      suspense.pendingId++;\n      if (isHydrating) {\n        // if toggled before hydration is finished, the current DOM tree is\n        // no longer valid. set it as the active branch so it will be unmounted\n        // when resolved\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      // increment pending ID. this is used to invalidate async callbacks\n      // reset suspense state\n      suspense.deps = 0;\n      // discard effects from pending branch\n      suspense.effects.length = 0;\n      // discard previous container\n      suspense.hiddenContainer = createElement('div');\n      if (isInFallback) {\n        // already in fallback state\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n          // fallback tree will not have suspense context\n          isSVG, slotScopeIds, optimized);\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        // toggled \"back\" to current active branch\n        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        // force resolve\n        suspense.resolve(true);\n      } else {\n        // switched to a 3rd branch\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      // root did not change, just normal patch\n      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      setActiveBranch(suspense, newBranch);\n    } else {\n      // root node toggled\n      // invoke @pending event\n      triggerEvent(n2, 'onPending');\n      // mount pending branch in off-dom container\n      suspense.pendingBranch = newBranch;\n      suspense.pendingId++;\n      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        // incoming branch has no async deps, resolve now.\n        suspense.resolve();\n      } else {\n        const {\n          timeout,\n          pendingId\n        } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  /* istanbul ignore if */\n  if (false) {}\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: {\n      parentNode,\n      remove\n    }\n  } = rendererInternals;\n  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .toNumber */ .He)(vnode.props.timeout) : undefined;\n  if (false) {}\n  const suspense = {\n    vnode,\n    parent,\n    parentComponent,\n    isSVG,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: 0,\n    timeout: typeof timeout === 'number' ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: true,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false) {\n      if (false) {}\n      const {\n        vnode,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent,\n        container\n      } = suspense;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);\n            }\n          };\n        }\n        // this is initial anchor on mount\n        let {\n          anchor\n        } = suspense;\n        // unmount current active tree\n        if (activeBranch) {\n          // if the fallback tree was mounted, it may have been moved\n          // as part of a parent suspense. get the latest anchor for insertion\n          anchor = next(activeBranch);\n          unmount(activeBranch, parentComponent, suspense, true);\n        }\n        if (!delayEnter) {\n          // move content from off-dom container to actual container\n          move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      // flush buffered effects\n      // check if there is a pending parent suspense\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          // found a pending parent suspense, merge buffered post jobs\n          // into that parent\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      // no pending parent suspense, flush all jobs\n      if (!hasUnresolvedAncestor) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      // invoke @resolve event\n      triggerEvent(vnode, 'onResolve');\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const {\n        vnode,\n        activeBranch,\n        parentComponent,\n        container,\n        isSVG\n      } = suspense;\n      // invoke @fallback event\n      triggerEvent(vnode, 'onFallback');\n      const anchor = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        // mount the fallback tree\n        patch(null, fallbackVNode, container, anchor, parentComponent, null,\n        // fallback tree will not have suspense context\n        isSVG, slotScopeIds, optimized);\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      // unmount current active branch\n      unmount(activeBranch, parentComponent, null,\n      // no suspense so unmount hooks fire now\n      true // shouldRemove\n      );\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container, anchor, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container, anchor, type);\n      suspense.container = container;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch(err => {\n        handleError(err, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);\n      }).then(asyncSetupResult => {\n        // retry when the setup() promise resolves.\n        // component may have been unmounted before resolve.\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        // retry from this component\n        instance.asyncResolved = true;\n        const {\n          vnode\n        } = instance;\n        if (false) {}\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          // vnode may have been replaced if an update happened before the\n          // async dep is resolved.\n          vnode.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(instance, vnode,\n        // component may have been moved before resolve.\n        // if this is not a hydration, instance.subTree will be the comment\n        // placeholder.\n        parentNode(hydratedEl || instance.subTree.el),\n        // anchor will not be used if this is hydration, so only need to\n        // consider the comment placeholder case.\n        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode.el);\n        if (false) {}\n        // only decrease deps count if suspense is not already resolved\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\n      }\n      if (suspense.pendingBranch) {\n        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  /* eslint-disable no-restricted-globals */\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */);\n  // there are two possible scenarios for server-rendered suspense:\n  // - success: ssr content should be fully resolved\n  // - failure: ssr content should be the fallback branch.\n  // however, on the client we don't really know if it has failed or not\n  // attempt to hydrate the DOM assuming it has succeeded, but we still\n  // need to construct a suspense boundary first\n  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);\n  if (suspense.deps === 0) {\n    suspense.resolve();\n  }\n  return result;\n  /* eslint-enable no-restricted-globals */\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const {\n    shapeFlag,\n    children\n  } = vnode;\n  const isSlotChildren = shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */;\n  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      // disableTracking: false\n      // allow block tracking for compiled slots\n      // (see ./componentRenderContext.ts)\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(s)) {\n    const singleChild = filterSingleRoot(s);\n    if (false) {}\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter(c => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const {\n    vnode,\n    parentComponent\n  } = suspense;\n  const el = vnode.el = branch.el;\n  // in case suspense is the root node of a component,\n  // recursively update the HOC el\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (false) {}\n  } else {\n    let provides = currentInstance.provides;\n    // by default an instance inherits its parent's provides object\n    // but when it needs to provide values of its own, it creates its\n    // own provides object using parent provides object as prototype.\n    // this way in `inject` we can simply look up injections from direct\n    // parent and let the prototype chain do the work.\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    // TS doesn't allow symbol as index type\n    provides[key] = value;\n  }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appContext's `provides` if the instance is at root\n    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;\n    if (provides && key in provides) {\n      // TS doesn't allow symbol as index type\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;\n    } else if (false) {}\n  } else if (false) {}\n}\n\n// Simple effect.\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n  return doWatch(effect, null,  false ? 0 : {\n    flush: 'post'\n  });\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(effect, null,  false ? 0 : {\n    flush: 'sync'\n  });\n}\n// initial value for watchers to trigger on undefined initial values\nconst INITIAL_WATCHER_VALUE = {};\n// implementation\nfunction watch(source, cb, options) {\n  if (false) {}\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush,\n  onTrack,\n  onTrigger\n} = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT) {\n  if (false) {}\n  const warnInvalidSource = s => {\n    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` + `a reactive object, or an array of these types.`);\n  };\n  const instance = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .getCurrentScope */ .nZ)() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;\n  // const instance = currentInstance\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(source)) {\n    getter = () => source.value;\n    forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isShallow */ .yT)(source);\n  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isReactive */ .PG)(source)) {\n    getter = () => source;\n    deep = true;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isReactive */ .PG)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isShallow */ .yT)(s));\n    getter = () => source.map(s => {\n      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(s)) {\n        return s.value;\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isReactive */ .PG)(s)) {\n        return traverse(s);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(s)) {\n        return callWithErrorHandling(s, instance, 2 /* ErrorCodes.WATCH_GETTER */);\n      } else {\n         false && 0;\n      }\n    });\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () => callWithErrorHandling(source, instance, 2 /* ErrorCodes.WATCH_GETTER */);\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return;\n        }\n        if (cleanup) {\n          cleanup();\n        }\n        return callWithAsyncErrorHandling(source, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [onCleanup]);\n      };\n    }\n  } else {\n    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n     false && 0;\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = fn => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4 /* ErrorCodes.WATCH_CLEANUP */);\n    };\n  };\n  // in SSR there is no need to setup an actual effect, and it should be noop\n  // unless it's eager or sync flush\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    // we will also not call the invalidate callback (+ runner is not set up)\n    onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [getter(), isMultiSource ? [] : undefined, onCleanup]);\n    }\n    if (flush === 'sync') {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else {\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n    }\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active) {\n      return;\n    }\n    if (cb) {\n      // watch(source, cb)\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasChanged */ .aU)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasChanged */ .aU)(newValue, oldValue)) || false) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup();\n        }\n        callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [newValue,\n        // pass undefined as the old value when it's changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? undefined : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup]);\n        oldValue = newValue;\n      }\n    } else {\n      // watchEffect\n      effect.run();\n    }\n  };\n  // important: mark the job as a watcher callback so that scheduler knows\n  // it is allowed to self-trigger (#1727)\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === 'sync') {\n    scheduler = job; // the scheduler function gets called directly\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    // default: 'pre'\n    job.pre = true;\n    if (instance) job.id = instance.uid;\n    scheduler = () => queueJob(job);\n  }\n  const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .ReactiveEffect */ .qq(getter, scheduler);\n  if (false) {}\n  // initial run\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === 'post') {\n    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\n  } else {\n    effect.run();\n  }\n  const unwatch = () => {\n    effect.stop();\n    if (instance && instance.scope) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .remove */ .Od)(instance.scope.effects, effect);\n    }\n  };\n  if (ssrCleanup) ssrCleanup.push(unwatch);\n  return unwatch;\n}\n// this.$watch\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(source) ? source.includes('.') ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const cur = currentInstance;\n  setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  if (cur) {\n    setCurrentInstance(cur);\n  } else {\n    unsetCurrentInstance();\n  }\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split('.');\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\nfunction traverse(value, seen) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(value) || value[\"__v_skip\" /* ReactiveFlags.SKIP */]) {\n    return value;\n  }\n  seen = seen || new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(value)) {\n    traverse(value.value, seen);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isSet */ .DM)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isMap */ ._N)(value)) {\n    value.forEach(v => {\n      traverse(v, seen);\n    });\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isPlainObject */ .PO)(value)) {\n    for (const key in value) {\n      traverse(value[key], seen);\n    }\n  }\n  return value;\n}\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: {\n    mode: String,\n    appear: Boolean,\n    persisted: Boolean,\n    // enter\n    onBeforeEnter: TransitionHookValidator,\n    onEnter: TransitionHookValidator,\n    onAfterEnter: TransitionHookValidator,\n    onEnterCancelled: TransitionHookValidator,\n    // leave\n    onBeforeLeave: TransitionHookValidator,\n    onLeave: TransitionHookValidator,\n    onAfterLeave: TransitionHookValidator,\n    onLeaveCancelled: TransitionHookValidator,\n    // appear\n    onBeforeAppear: TransitionHookValidator,\n    onAppear: TransitionHookValidator,\n    onAfterAppear: TransitionHookValidator,\n    onAppearCancelled: TransitionHookValidator\n  },\n  setup(props, {\n    slots\n  }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevTransitionKey;\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      let child = children[0];\n      if (children.length > 1) {\n        let hasFound = false;\n        // locate first non-comment child\n        for (const c of children) {\n          if (c.type !== Comment) {\n            if (false) {}\n            child = c;\n            hasFound = true;\n            if (true) break;\n          }\n        }\n      }\n      // there's no need to track reactivity for these props so use the raw\n      // props for a bit better perf\n      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .IU)(props);\n      const {\n        mode\n      } = rawProps;\n      // check mode\n      if (false) {}\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      // in the case of <transition><keep-alive/></transition>, we need to\n      // compare the type of the kept-alive children.\n      const innerChild = getKeepAliveChild(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      let transitionKeyChanged = false;\n      const {\n        getTransitionKey\n      } = innerChild.type;\n      if (getTransitionKey) {\n        const key = getTransitionKey();\n        if (prevTransitionKey === undefined) {\n          prevTransitionKey = key;\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key;\n          transitionKeyChanged = true;\n        }\n      }\n      // handle mode\n      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\n        // update old tree's hooks in case of dynamic transition\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        // switching between different views\n        if (mode === 'out-in') {\n          state.isLeaving = true;\n          // return placeholder node and queue update when leave finishes\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            // #6835\n            // it also needs to be updated when active is undefined\n            if (instance.update.active !== false) {\n              instance.update();\n            }\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === 'in-out' && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            // early removal callback\n            el._leaveCb = () => {\n              earlyRemove();\n              el._leaveCb = undefined;\n              delete enterHooks.delayedLeave;\n            };\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n      return child;\n    };\n  }\n};\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const {\n    leavingVNodes\n  } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\n// The transition hooks are attached to the vnode as vnode.transition\n// and will be called at appropriate timing in the renderer.\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(hook, instance, 9 /* ErrorCodes.TRANSITION_HOOK */, args);\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(hook)) {\n      if (hook.every(hook => hook.length <= 1)) done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      // for same element (v-show)\n      if (el._leaveCb) {\n        el._leaveCb(true /* cancelled */);\n      }\n      // for toggled element with same key (v-if)\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {\n        // force early removal (not cancelled)\n        leavingVNode.el._leaveCb();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el._enterCb = cancelled => {\n        if (called) return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el._enterCb = undefined;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key = String(vnode.key);\n      if (el._enterCb) {\n        el._enterCb(true /* cancelled */);\n      }\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el._leaveCb = cancelled => {\n        if (called) return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el._leaveCb = undefined;\n        if (leavingVNodesCache[key] === vnode) {\n          delete leavingVNodesCache[key];\n        }\n      };\n      leavingVNodesCache[key] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode) {\n      return resolveTransitionHooks(vnode, props, state, instance);\n    }\n  };\n  return hooks;\n}\n// the placeholder really only handles one special case: KeepAlive\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\n// placeholder with empty content to avoid the KeepAlive instance from being\n// unmounted.\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getKeepAliveChild(vnode) {\n  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */ && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    // #5360 inherit parent key in case of <template v-for>\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    // handle fragment children case, e.g. v-for\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */) keyedFragmentCount++;\n      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\n    }\n    // comment placeholders should be skipped, e.g. v-if\n    else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, {\n        key\n      }) : child);\n    }\n  }\n  // #1126 if a transition children list contains multiple sub fragments, these\n  // fragments will be merged into a flat children array. Since each v-for\n  // fragment may contain different static bindings inside, we need to de-op\n  // these children to force full diffs to ensure correct behavior.\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2 /* PatchFlags.BAIL */;\n    }\n  }\n  return ret;\n}\n\n// implementation, close to no-op\nfunction defineComponent(options) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(options) ? {\n    setup: options,\n    name: options.name\n  } : options;\n}\nconst isAsyncWrapper = i => !!i.type.__asyncLoader;\nfunction defineAsyncComponent(source) {\n  if (isFunction(source)) {\n    source = {\n      loader: source\n    };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then(comp => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if (false) {}\n      // interop module default\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n        comp = comp.default;\n      }\n      if (false) {}\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: 'AsyncComponentWrapper',\n    __asyncLoader: load,\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      // already resolved\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = err => {\n        pendingRequest = null;\n        handleError(err, instance, 13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\n      };\n      // suspense-controlled or SSR.\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then(comp => {\n          return () => createInnerComp(comp, instance);\n        }).catch(err => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = ref(false);\n      const error = ref();\n      const delayed = ref(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(`Async component timed out after ${timeout}ms.`);\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          // parent is keep-alive, force update so the loaded component's\n          // name is taken into account\n          queueJob(instance.parent.update);\n        }\n      }).catch(err => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const {\n    ref,\n    props,\n    children,\n    ce\n  } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref;\n  // pass the custom element callback on to the inner comp\n  // and remove it from the async wrapper\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\nconst isKeepAlive = vnode => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, {\n    slots\n  }) {\n    const instance = getCurrentInstance();\n    // KeepAlive communicates with the instantiated renderer via the\n    // ctx where the renderer passes in its internals,\n    // and the KeepAlive instance exposes activate/deactivate implementations.\n    // The whole point of this is to avoid importing KeepAlive directly in the\n    // renderer to facilitate tree-shaking.\n    const sharedContext = instance.ctx;\n    // if the internal renderer is not registered, it indicates that this is server-side rendering,\n    // for KeepAlive, we just need to render its children\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = new Map();\n    const keys = new Set();\n    let current = null;\n    if (false) {}\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: {\n          createElement\n        }\n      }\n    } = sharedContext;\n    const storageContainer = createElement('div');\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      const instance = vnode.component;\n      move(vnode, container, anchor, 0 /* MoveType.ENTER */, parentSuspense);\n      // in case props have changed\n      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\n      queuePostRenderEffect(() => {\n        instance.isDeactivated = false;\n        if (instance.a) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .invokeArrayFns */ .ir)(instance.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode);\n        }\n      }, parentSuspense);\n      if (false) {}\n    };\n    sharedContext.deactivate = vnode => {\n      const instance = vnode.component;\n      move(vnode, storageContainer, null, 1 /* MoveType.LEAVE */, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance.da) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .invokeArrayFns */ .ir)(instance.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode);\n        }\n        instance.isDeactivated = true;\n      }, parentSuspense);\n      if (false) {}\n    };\n    function unmount(vnode) {\n      // reset the shapeFlag so it can be properly unmounted\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (!current || !isSameVNodeType(cached, current)) {\n        unmount(cached);\n      } else if (current) {\n        // current active instance should no longer be kept-alive.\n        // we can't unmount it now but it might be later, so reset its flag now.\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    // prune cache on include/exclude prop change\n    watch(() => [props.include, props.exclude], ([include, exclude]) => {\n      include && pruneCache(name => matches(include, name));\n      exclude && pruneCache(name => !matches(exclude, name));\n    },\n    // prune post-render after `current` has been updated\n    {\n      flush: 'post',\n      deep: true\n    });\n    // cache sub tree after render\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      // fix #1621, the pendingCacheKey could be 0\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach(cached => {\n        const {\n          subTree,\n          suspense\n        } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          // current instance will be unmounted as part of keep-alive's unmount\n          resetShapeFlag(vnode);\n          // but invoke its deactivated hook here\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (false) {}\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) && !(rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      // for async components, name check should be based in its loaded\n      // inner component if available\n      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);\n      const {\n        include,\n        exclude,\n        max\n      } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      // clone vnode if it's reused because we are going to mutate it\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      // #1513 it's possible for the returned vnode to be cloned due to attr\n      // fallthrough or scopeId, so the vnode here may not be the final vnode\n      // that is mounted. Instead of caching it directly, we store the pending\n      // key and cache `instance.subTree` (the normalized vnode) in\n      // beforeMount/beforeUpdate hooks.\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        // copy over mounted state\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          // recursively update transition hooks on subTree\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        // avoid vnode being mounted as fresh\n        vnode.shapeFlag |= 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n        // make this key the freshest\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        // prune oldest entry\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      // avoid vnode being unmounted\n      vnode.shapeFlag |= 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nconst KeepAlive = (/* unused pure expression or super */ null && (KeepAliveImpl));\nfunction matches(pattern, name) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(pattern)) {\n    return pattern.some(p => matches(p, name));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(pattern)) {\n    return pattern.split(',').includes(name);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isRegExp */ .Kj)(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\" /* LifecycleHooks.ACTIVATED */, target);\n}\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\" /* LifecycleHooks.DEACTIVATED */, target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  // cache the deactivate branch check wrapper for injected hooks so the same\n  // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\n  // deactivation check\".\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    // only fire the hook if the target instance is NOT in a deactivated branch.\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  // In addition to registering it on the target instance, we walk up the parent\n  // chain and register it on all ancestor instances that are keep-alive roots.\n  // This avoids the need to walk the entire component tree when invoking these\n  // hooks, and more importantly, avoids the need to track child components in\n  // arrays.\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  // injectHook wraps the original for error handling, so make sure to remove\n  // the wrapped version.\n  const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\n  onUnmounted(() => {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .remove */ .Od)(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  // bitwise operations to remove keep alive flags\n  vnode.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n  vnode.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */ ? vnode.ssContent : vnode;\n}\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    // cache the error handling wrapper for injected hooks so the same hook\n    // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\n    // handling\".\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      }\n      // disable tracking inside all lifecycle hooks\n      // since they can potentially be called inside effects.\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .pauseTracking */ .Jd)();\n      // Set currentInstance during hook invocation.\n      // This assumes the hook does not synchronously trigger other hooks, which\n      // can only be false when the user does something really funky.\n      setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      unsetCurrentInstance();\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .resetTracking */ .lk)();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (false) {}\n}\nconst createHook = lifecycle => (hook, target = currentInstance) =>\n// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n(!isInSSRComponentSetup || lifecycle === \"sp\" /* LifecycleHooks.SERVER_PREFETCH */) && injectHook(lifecycle, (...args) => hook(...args), target);\nconst onBeforeMount = createHook(\"bm\" /* LifecycleHooks.BEFORE_MOUNT */);\nconst onMounted = createHook(\"m\" /* LifecycleHooks.MOUNTED */);\nconst onBeforeUpdate = createHook(\"bu\" /* LifecycleHooks.BEFORE_UPDATE */);\nconst onUpdated = createHook(\"u\" /* LifecycleHooks.UPDATED */);\nconst onBeforeUnmount = createHook(\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */);\nconst onUnmounted = createHook(\"um\" /* LifecycleHooks.UNMOUNTED */);\nconst onServerPrefetch = createHook(\"sp\" /* LifecycleHooks.SERVER_PREFETCH */);\nconst onRenderTriggered = createHook(\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */);\nconst onRenderTracked = createHook(\"rtc\" /* LifecycleHooks.RENDER_TRACKED */);\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook(\"ec\" /* LifecycleHooks.ERROR_CAPTURED */, hook, target);\n}\n\n/**\nRuntime helper for applying directives to a vnode. Example usage:\n\nconst comp = resolveComponent('comp')\nconst foo = resolveDirective('foo')\nconst bar = resolveDirective('bar')\n\nreturn withDirectives(h(comp), [\n  [foo, this.x],\n  [bar, this.y]\n])\n*/\nfunction validateDirectiveName(name) {\n  if (isBuiltInDirective(name)) {\n    warn('Do not use built-in directive ids as custom directive id: ' + name);\n  }\n}\n/**\n * Adds directives to a VNode.\n */\nfunction withDirectives(vnode, directives) {\n  const internalInstance = currentRenderingInstance;\n  if (internalInstance === null) {\n     false && 0;\n    return vnode;\n  }\n  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT] = directives[i];\n    if (dir) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      // disable tracking inside all lifecycle hooks\n      // since they can potentially be called inside effects.\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .pauseTracking */ .Jd)();\n      callWithAsyncErrorHandling(hook, instance, 8 /* ErrorCodes.DIRECTIVE_HOOK */, [vnode.el, binding, vnode, prevVNode]);\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .resetTracking */ .lk)();\n    }\n  }\n}\nconst COMPONENTS = 'components';\nconst DIRECTIVES = 'directives';\n/**\n * @private\n */\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol();\n/**\n * @private\n */\nfunction resolveDynamicComponent(component) {\n  if (isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    // invalid types will fallthrough to createVNode and raise warning\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\n/**\n * @private\n */\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\n// implementation\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    // explicit self name has highest priority\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);\n      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .capitalize */ .kC)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(name)))) {\n        return Component;\n      }\n    }\n    const res =\n    // local registration\n    // check instance[type] first which is resolved for options API\n    resolve(instance[type] || Component[type], name) ||\n    // global registration\n    resolve(instance.appContext[type], name);\n    if (!res && maybeSelfReference) {\n      // fallback to implicit self-reference\n      return Component;\n    }\n    if (false) {}\n    return res;\n  } else if (false) {}\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .capitalize */ .kC)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(name))]);\n}\n\n/**\n * Actual implementation\n */\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(source)) {\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);\n    }\n  } else if (typeof source === 'number') {\n    if (false) {}\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\n\n/**\n * Compiler runtime helper for creating dynamic slots object\n * @private\n */\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    // array of dynamic slot generated by <template v-for=\"...\" #[...]>\n    if (isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      // conditional single slot generated by <template v-if=\"...\" #foo>\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        // attach branch key so each conditional branch is considered a\n        // different fragment\n        if (res) res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\n\n/**\n * Compiler runtime helper for rendering `<slot/>`\n * @private\n */\nfunction renderSlot(slots, name, props = {},\n// this is not a user-facing function, so the fallback is always generated by\n// the compiler and guaranteed to be a function returning an array\nfallback, noSlotted) {\n  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {\n    if (name !== 'default') props.name = name;\n    return createVNode('slot', props, fallback && fallback());\n  }\n  let slot = slots[name];\n  if (false) {}\n  // a compiled slot disables block tracking by default to avoid manual\n  // invocation interfering with template-based block tracking, but in\n  // `renderSlot` we can be sure that it's template-based so we can force\n  // enable it.\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const rendered = createBlock(Fragment, {\n    key: props.key ||\n    // slot content array of a dynamic conditional slot may have a branch\n    // key attached in the `createSlots` helper, respect that\n    validSlotContent && validSlotContent.key || `_${name}`\n  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* SlotFlags.STABLE */ ? 64 /* PatchFlags.STABLE_FRAGMENT */ : -2 /* PatchFlags.BAIL */);\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + '-s'];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;\n    return true;\n  }) ? vnodes : null;\n}\n\n/**\n * For prefixing keys in v-on=\"obj\" with \"on\"\n * @private\n */\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if (false) {}\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];\n  }\n  return ret;\n}\n\n/**\n * #2437 In Vue 3, functional components do not have a public instance proxy but\n * they exist in the internal parent chain. For code that relies on traversing\n * public $parent chains, skip functional ones and go to the parent instead.\n */\nconst getPublicInstance = i => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap =\n// Move PURE marker to new line to workaround compiler discarding it\n// due to type annotation\n/*#__PURE__*/\n(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(Object.create(null), {\n  $: i => i,\n  $el: i => i.vnode.el,\n  $data: i => i.data,\n  $props: i =>  false ? 0 : i.props,\n  $attrs: i =>  false ? 0 : i.attrs,\n  $slots: i =>  false ? 0 : i.slots,\n  $refs: i =>  false ? 0 : i.refs,\n  $parent: i => getPublicInstance(i.parent),\n  $root: i => getPublicInstance(i.root),\n  $emit: i => i.emit,\n  $options: i =>  true ? resolveMergedOptions(i) : 0,\n  $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\n  $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),\n  $watch: i =>  true ? instanceWatch.bind(i) : 0\n});\nconst isReservedPrefix = key => key === '_' || key === '$';\nconst hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({\n    _: instance\n  }, key) {\n    const {\n      ctx,\n      setupState,\n      data,\n      props,\n      accessCache,\n      type,\n      appContext\n    } = instance;\n    // for internal formatters to know that this is a Vue instance\n    if (false) {}\n    // data / props / ctx\n    // This getter gets called for every property access on the render context\n    // during render and is a major hotspot. The most expensive part of this\n    // is the multiple hasOwn() calls. It's much faster to do a simple property\n    // access on a plain object, so we use an accessCache object (with null\n    // prototype) to memoize what access type a key corresponds to.\n    let normalizedProps;\n    if (key[0] !== '$') {\n      const n = accessCache[key];\n      if (n !== undefined) {\n        switch (n) {\n          case 1 /* AccessTypes.SETUP */:\n            return setupState[key];\n          case 2 /* AccessTypes.DATA */:\n            return data[key];\n          case 4 /* AccessTypes.CONTEXT */:\n            return ctx[key];\n          case 3 /* AccessTypes.PROPS */:\n            return props[key];\n          // default: just fallthrough\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* AccessTypes.SETUP */;\n        return setupState[key];\n      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(data, key)) {\n        accessCache[key] = 2 /* AccessTypes.DATA */;\n        return data[key];\n      } else if (\n      // only cache other properties when instance has declared (thus stable)\n      // props\n      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(normalizedProps, key)) {\n        accessCache[key] = 3 /* AccessTypes.PROPS */;\n        return props[key];\n      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(ctx, key)) {\n        accessCache[key] = 4 /* AccessTypes.CONTEXT */;\n        return ctx[key];\n      } else if ( false || shouldCacheAccess) {\n        accessCache[key] = 0 /* AccessTypes.OTHER */;\n      }\n    }\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    // public $xxx properties\n    if (publicGetter) {\n      if (key === '$attrs') {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .track */ .j)(instance, \"get\" /* TrackOpTypes.GET */, key);\n         false && 0;\n      }\n      return publicGetter(instance);\n    } else if (\n    // css module (injected by vue-loader)\n    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {\n      return cssModule;\n    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(ctx, key)) {\n      // user may set custom properties to `this` that start with `$`\n      accessCache[key] = 4 /* AccessTypes.CONTEXT */;\n      return ctx[key];\n    } else if (\n    // global properties\n    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(globalProperties, key)) {\n      {\n        return globalProperties[key];\n      }\n    } else if (false) {}\n  },\n  set({\n    _: instance\n  }, key, value) {\n    const {\n      data,\n      setupState,\n      ctx\n    } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if (false) {} else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(data, key)) {\n      data[key] = value;\n      return true;\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(instance.props, key)) {\n       false && 0;\n      return false;\n    }\n    if (key[0] === '$' && key.slice(1) in instance) {\n       false && 0;\n      return false;\n    } else {\n      if (false) {} else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: {\n      data,\n      setupState,\n      accessCache,\n      ctx,\n      appContext,\n      propsOptions\n    }\n  }, key) {\n    let normalizedProps;\n    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      // invalidate key cache of a getter based property #5417\n      target._.accessCache[key] = 0;\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(descriptor, 'value')) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (false) {}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    // fast path for unscopables when using `with` block\n    if (key === Symbol.unscopables) {\n      return;\n    }\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n  has(_, key) {\n    const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isGloballyundefineded */ .e1)(key);\n    if (false) {}\n    return has;\n  }\n});\n// dev only\n// In dev mode, the proxy target exposes the same properties as seen on `this`\n// for easier console inspection. In prod mode it will be an empty object so\n// these properties definitions can be skipped.\nfunction createDevRenderContext(instance) {\n  const target = {};\n  // expose internal instance for proxy handlers\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  // expose public properties\n  Object.keys(publicPropertiesMap).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: NOOP\n    });\n  });\n  return target;\n}\n// dev only\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach(key => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: NOOP\n      });\n    });\n  }\n}\n// dev only\nfunction exposeSetupStateOnRenderContext(instance) {\n  const {\n    ctx,\n    setupState\n  } = instance;\n  Object.keys(toRaw(setupState)).forEach(key => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` + `which are reserved prefixes for Vue internals.`);\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: NOOP\n      });\n    }\n  });\n}\nfunction createDuplicateChecker() {\n  const cache = Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  // do not cache property access on public proxy during state initialization\n  shouldCacheAccess = false;\n  // call beforeCreate first before accessing other options since\n  // the hook may mutate resolved options (#2791)\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\" /* LifecycleHooks.BEFORE_CREATE */);\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties =  false ? 0 : null;\n  if (false) {}\n  // options initialization order (to be consistent with Vue 2):\n  // - props (already done outside of this function)\n  // - inject\n  // - methods\n  // - data (deferred since it relies on `this` access)\n  // - computed\n  // - watch (deferred since it relies on `this` access)\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(methodHandler)) {\n        // In dev mode, we use the `createRenderContext` function to define\n        // methods to the proxy target, and those are read-only but\n        // reconfigurable, so it needs to be redefined here\n        if (false) {} else {\n          ctx[key] = methodHandler.bind(publicThis);\n        }\n        if (false) {}\n      } else if (false) {}\n    }\n  }\n  if (dataOptions) {\n    if (false) {}\n    const data = dataOptions.call(publicThis, publicThis);\n    if (false) {}\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(data)) {\n       false && 0;\n    } else {\n      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .reactive */ .qj)(data);\n      if (false) {}\n    }\n  }\n  // state initialization complete at this point - start caching access\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n      if (false) {}\n      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(opt.set) ? opt.set.bind(publicThis) :  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: v => c.value = v\n      });\n      if (false) {}\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach(key => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\" /* LifecycleHooks.CREATED */);\n  }\n  function registerLifecycleHook(register, hook) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(hook)) {\n      hook.forEach(_hook => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach(key => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: val => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  // options that are handled when creating the instance but also need to be\n  // applied from mixins\n  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  // asset options.\n  if (components) instance.components = components;\n  if (directives) instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG, unwrapRef = false) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(opt)) {\n      if ('default' in opt) {\n        injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(injected)) {\n      // TODO remove the check in 3.3\n      if (unwrapRef) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          get: () => injected.value,\n          set: v => injected.value = v\n        });\n      } else {\n        if (false) {}\n        ctx[key] = injected;\n      }\n    } else {\n      ctx[key] = injected;\n    }\n    if (false) {}\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes('.') ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(raw)) {\n    const handler = ctx[raw];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(handler)) {\n      watch(getter, handler);\n    } else if (false) {}\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(raw)) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(raw)) {\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(handler)) {\n        watch(getter, handler, raw);\n      } else if (false) {}\n    }\n  } else if (false) {}\n}\n/**\n * Resolve merged options and cache it on the component.\n * This is done only once per-component since the merging does not involve\n * instances.\n */\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: {\n      optionMergeStrategies\n    }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const {\n    mixins,\n    extends: extendsOptions\n  } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(m => mergeOptions(to, m, strats, true));\n  }\n  for (const key in from) {\n    if (asMixin && key === 'expose') {\n       false && 0;\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeObjectOptions,\n  emits: mergeObjectOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(from) ? from.call(this, this) : from);\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(Object.create(null), to), from) : from;\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\nfunction initProps(instance, rawProps, isStateful,\n// result of bitwise flag comparison\nisSSR = false) {\n  const props = {};\n  const attrs = {};\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .def */ .Nj)(attrs, InternalObjectKey, 1);\n  instance.propsDefaults = Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  // ensure all declared prop keys are present\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = undefined;\n    }\n  }\n  // validation\n  if (false) {}\n  if (isStateful) {\n    // stateful\n    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .shallowReactive */ .Um)(props);\n  } else {\n    if (!instance.type.props) {\n      // functional w/ optional props, props === attrs\n      instance.props = attrs;\n    } else {\n      // functional w/ declared props\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId) return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: {\n      patchFlag\n    }\n  } = instance;\n  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .IU)(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n  // always force full diff in dev\n  // - #1942 if hmr is enabled with sfc component\n  // - vite#872 non-sfc component used by sfc component\n   true && (optimized || patchFlag > 0) && !(patchFlag & 16 /* PatchFlags.FULL_PROPS */)) {\n    if (patchFlag & 8 /* PatchFlags.PROPS */) {\n      // Compiler-generated props & no keys change, just set the updated\n      // the props.\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        // skip if the prop key is a declared emit event listener\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        // PROPS flag guarantees rawProps to be non-null\n        const value = rawProps[key];\n        if (options) {\n          // attr / props separation was done on init and will be consistent\n          // in this code path, so just check if attrs have it.\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(key);\n            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    // full props update.\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    // in case of dynamic props, check if we need to delete keys from\n    // the props object\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps ||\n      // for camelCase\n      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(rawProps, key) && (\n      // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hyphenate */ .rs)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && (\n          // for camelCase\n          rawPrevProps[key] !== undefined ||\n          // for kebab-case\n          rawPrevProps[kebabKey] !== undefined)) {\n            props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    // in the case of functional component w/o props declaration, props and\n    // attrs point to the same object so it should already have been updated.\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(rawProps, key) && !false) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  // trigger updates for $attrs in case it's used in component slots\n  if (hasAttrsChanged) {\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .trigger */ .X$)(instance, \"set\" /* TriggerOpTypes.SET */, '$attrs');\n  }\n  if (false) {}\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      // key, ref are reserved and never passed down\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isReservedProp */ .Gg)(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      // prop option names are camelized during normalization, so to support\n      // kebab -> camel conversion here we need to camelize the key.\n      let camelKey;\n      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .IU)(props);\n    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(castValues, key));\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(opt, 'default');\n    // default values\n    if (hasDefault && value === undefined) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(defaultValue)) {\n        const {\n          propsDefaults\n        } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(null, props);\n          unsetCurrentInstance();\n        }\n      } else {\n        value = defaultValue;\n      }\n    }\n    // boolean casting\n    if (opt[0 /* BooleanFlags.shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* BooleanFlags.shouldCastTrue */] && (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hyphenate */ .rs)(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  // apply mixin/extends props\n  let hasExtends = false;\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(comp)) {\n    const extendProps = raw => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw, appContext, true);\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(comp)) {\n      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_ARR */ .Z6);\n    }\n    return _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_ARR */ .Z6;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if (false) {}\n      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n      }\n    }\n  } else if (raw) {\n    if (false) {}\n    for (const key in raw) {\n      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .camelize */ ._A)(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(opt) ? {\n          type: opt\n        } : Object.assign({}, opt);\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0 /* BooleanFlags.shouldCast */] = booleanIndex > -1;\n          prop[1 /* BooleanFlags.shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;\n          // if the prop needs boolean casting or default value\n          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(prop, 'default')) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== '$') {\n    return true;\n  } else if (false) {}\n  return false;\n}\n// use function string name to check type constructors\n// so that it works across vms / iframes.\nfunction getType(ctor) {\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/);\n  return match ? match[2] : ctor === null ? 'null' : '';\n}\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(expectedTypes)) {\n    return expectedTypes.findIndex(t => isSameType(t, type));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n  return -1;\n}\n/**\n * dev only\n */\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = toRaw(props);\n  const options = instance.propsOptions[0];\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));\n  }\n}\n/**\n * dev only\n */\nfunction validateProp(name, value, prop, isAbsent) {\n  const {\n    type,\n    required,\n    validator\n  } = prop;\n  // required!\n  if (required && isAbsent) {\n    warn('Missing required prop: \"' + name + '\"');\n    return;\n  }\n  // missing but optional\n  if (value == null && !prop.required) {\n    return;\n  }\n  // type check\n  if (type != null && type !== true) {\n    let isValid = false;\n    const types = isArray(type) ? type : [type];\n    const expectedTypes = [];\n    // value is valid as long as one of the specified types match\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const {\n        valid,\n        expectedType\n      } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || '');\n      isValid = valid;\n    }\n    if (!isValid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  // custom validator\n  if (validator && !validator(value)) {\n    warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\nconst isSimpleType = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap('String,Number,Boolean,Function,Symbol,BigInt')));\n/**\n * dev only\n */\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isObject(value);\n  } else if (expectedType === 'Array') {\n    valid = isArray(value);\n  } else if (expectedType === 'null') {\n    valid = value === null;\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\n/**\n * dev only\n */\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  let message = `Invalid prop: type check failed for prop \"${name}\".` + ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = toRawType(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\n/**\n * dev only\n */\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return `\"${value}\"`;\n  } else if (type === 'Number') {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\n/**\n * dev only\n */\nfunction isExplicable(type) {\n  const explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(elem => type.toLowerCase() === elem);\n}\n/**\n * dev only\n */\nfunction isBoolean(...args) {\n  return args.some(elem => elem.toLowerCase() === 'boolean');\n}\nconst isInternalKey = key => key[0] === '_' || key === '$stable';\nconst normalizeSlotValue = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    // already normalized - #5353\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if (false) {}\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (false) {}\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if (false) {}\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {\n    const type = children._;\n    if (type) {\n      // users can get the shallow readonly version of the slots object through `this.$slots`,\n      // we should avoid the proxy object polluting the slots of the internal instance\n      instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .IU)(children);\n      // make compiler marker non-enumerable\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .def */ .Nj)(children, '_', type);\n    } else {\n      normalizeObjectSlots(children, instance.slots = {});\n    }\n  } else {\n    instance.slots = {};\n    if (children) {\n      normalizeVNodeSlots(instance, children);\n    }\n  }\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .def */ .Nj)(instance.slots, InternalObjectKey, 1);\n};\nconst updateSlots = (instance, children, optimized) => {\n  const {\n    vnode,\n    slots\n  } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n  if (vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {\n    const type = children._;\n    if (type) {\n      // compiled slots.\n      if (false) {} else if (optimized && type === 1 /* SlotFlags.STABLE */) {\n        // compiled AND stable.\n        // no need to update, and skip stale slots removal.\n        needDeletionCheck = false;\n      } else {\n        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\n        // normalization.\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)(slots, children);\n        // #2893\n        // when rendering the optimized slots by manually written render function,\n        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\n        // i.e. let the `renderSlot` create the bailed Fragment\n        if (!optimized && type === 1 /* SlotFlags.STABLE */) {\n          delete slots._;\n        }\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    // non slot object children (direct value) passed to a component\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = {\n      default: 1\n    };\n  }\n  // delete stale slots\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n        delete slots[key];\n      }\n    }\n  }\n};\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_3__.NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: undefined,\n      warnHandler: undefined,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null),\n    optionsCache: new WeakMap(),\n    propsCache: new WeakMap(),\n    emitsCache: new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(rootComponent)) {\n      rootComponent = Object.assign({}, rootComponent);\n    }\n    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(rootProps)) {\n       false && 0;\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = new Set();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (false) {}\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n           false && 0;\n        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (false) {}\n        return app;\n      },\n      mixin(mixin) {\n        if (true) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (false) {}\n        } else {}\n        return app;\n      },\n      component(name, component) {\n        if (false) {}\n        if (!component) {\n          return context.components[name];\n        }\n        if (false) {}\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (false) {}\n        if (!directive) {\n          return context.directives[name];\n        }\n        if (false) {}\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, isSVG) {\n        if (!isMounted) {\n          // #5571\n          if (false) {}\n          const vnode = createVNode(rootComponent, rootProps);\n          // store app context on the root VNode.\n          // this will be set on the root instance on initial mount.\n          vnode.appContext = context;\n          // HMR root reload\n          if (false) {}\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, isSVG);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if (false) {}\n          return getExposeProxy(vnode.component) || vnode.component.proxy;\n        } else if (false) {}\n      },\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n          if (false) {}\n          delete app._container.__vue_app__;\n        } else if (false) {}\n      },\n      provide(key, value) {\n        if (false) {}\n        context.provides[key] = value;\n        return app;\n      }\n    };\n    return app;\n  };\n}\n\n/**\n * Function for handling a template ref\n */\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(rawRef)) {\n    rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    // when mounting async components, nothing needs to be done,\n    // because the template ref is forwarded to inner component\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */ ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const {\n    i: owner,\n    r: ref\n  } = rawRef;\n  if (false) {}\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  // dynamic ref changed. unset old ref\n  if (oldRef != null && oldRef !== ref) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(oldRef)) {\n      refs[oldRef] = null;\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(ref)) {\n    callWithErrorHandling(ref, owner, 12 /* ErrorCodes.FUNCTION_REF */, [value, refs]);\n  } else {\n    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(ref);\n    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .remove */ .Od)(existing, refValue);\n          } else {\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(setupState, ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k) refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .hasOwn */ .RI)(setupState, ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k) refs[rawRef.k] = value;\n        } else if (false) {}\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    } else if (false) {}\n  }\n}\nlet hasMismatch = false;\nconst isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\nconst isComment = node => node.nodeType === 8 /* DOMNodeTypes.COMMENT */;\n// Note: hydration is DOM-specific\n// But we have to place it in core due to tight coupling with core - splitting\n// it out creates a ton of unnecessary complexity.\n// Hydration also depends on some renderer internal logic which needs to be\n// passed in via arguments.\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n       false && 0;\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n    if (hasMismatch && !false) {\n      // this error should show up in production\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    const isFragmentStart = isComment(node) && node.data === '[';\n    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\n    const {\n      type,\n      ref,\n      shapeFlag,\n      patchFlag\n    } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (patchFlag === -2 /* PatchFlags.BAIL */) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3 /* DOMNodeTypes.TEXT */) {\n          // #5728 empty text node inside a slot can cause hydration failure\n          // because the server rendered HTML won't contain a text node\n          if (vnode.children === '') {\n            insert(vnode.el = createText(''), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n             false && 0;\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (domType !== 8 /* DOMNodeTypes.COMMENT */ || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          // entire template is static but SSRed as a fragment\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 /* DOMNodeTypes.ELEMENT */ || domType === 3 /* DOMNodeTypes.TEXT */) {\n          // determine anchor, adopt content\n          nextNode = node;\n          // if the static vnode has its content stripped during build,\n          // adopt it from the server-rendered HTML.\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* DOMNodeTypes.ELEMENT */ ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n        }\n        break;\n      default:\n        if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n          if (domType !== 1 /* DOMNodeTypes.ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n          }\n        } else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n          // when setting up the render effect, if the initial vnode already\n          // has .el set, the component will perform hydration instead of mount\n          // on its sub-tree.\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\n          // component may be async, so in the case of fragments we cannot rely\n          // on component's rendered output to determine the end of the fragment\n          // instead, we do a lookahead to find the end anchor node.\n          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);\n          // #4293 teleport as component root\n          if (nextNode && isComment(nextNode) && nextNode.data === 'teleport end') {\n            nextNode = nextSibling(nextNode);\n          }\n          // #3787\n          // if component is async, it may get moved / unmounted before its\n          // inner component is loaded, so we need to give it a placeholder\n          // vnode that matches its adopted DOM.\n          if (isAsyncWrapper(vnode)) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n          if (domType !== 8 /* DOMNodeTypes.COMMENT */) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\n          }\n        } else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\n        } else if (false) {}\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const {\n      type,\n      props,\n      patchFlag,\n      shapeFlag,\n      dirs\n    } = vnode;\n    // #4006 for form elements with non-string v-model value bindings\n    // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\n    const forcePatchValue = type === 'input' && dirs || type === 'option';\n    // skip props & children if this is hoisted static nodes\n    // #5405 in dev, always hydrate children for HMR\n    if ( false || forcePatchValue || patchFlag !== -1 /* PatchFlags.HOISTED */) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'created');\n      }\n      // props\n      if (props) {\n        if (forcePatchValue || !optimized || patchFlag & (16 /* PatchFlags.FULL_PROPS */ | 32 /* PatchFlags.HYDRATE_EVENTS */)) {\n          for (const key in props) {\n            if (forcePatchValue && key.endsWith('value') || isOn(key) && !isReservedProp(key)) {\n              patchProp(el, key, null, props[key], false, undefined, parentComponent);\n            }\n          }\n        } else if (props.onClick) {\n          // Fast path for click listeners (which is most often) to avoid\n          // iterating through props.\n          patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);\n        }\n      }\n      // vnode / directive hooks\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n        }, parentSuspense);\n      }\n      // children\n      if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */ &&\n      // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\n        let hasWarned = false;\n        while (next) {\n          hasMismatch = true;\n          if (false) {}\n          // The SSRed DOM contains more nodes than it should. Remove them.\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true;\n           false && 0;\n          el.textContent = vnode.children;\n        }\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      if (node) {\n        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n      } else if (vnode.type === Text && !vnode.children) {\n        continue;\n      } else {\n        hasMismatch = true;\n        if (false) {}\n        // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\n        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const {\n      slotScopeIds: fragmentSlotScopeIds\n    } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\n    if (next && isComment(next) && next.data === ']') {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      // fragment didn't hydrate successfully, since we didn't get a end anchor\n      // back. This should have led to node/children mismatch warnings.\n      hasMismatch = true;\n      // since the anchor is missing, we need to create one and insert it\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    hasMismatch = true;\n     false && 0;\n    vnode.el = null;\n    if (isFragment) {\n      // remove excessive fragment nodes\n      const end = locateClosingAsyncAnchor(node);\n      while (true) {\n        const next = nextSibling(node);\n        if (next && next !== end) {\n          remove(next);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n    return next;\n  };\n  const locateClosingAsyncAnchor = node => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === '[') match++;\n        if (node.data === ']') {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  return [hydrate, hydrateNode];\n}\n\n/* eslint-disable no-restricted-globals */\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if (false) {}\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if (false) {}\n}\nfunction isSupported() {\n  if (supported !== undefined) {\n    return supported;\n  }\n  if (typeof window !== 'undefined' && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\n\n/**\n * This is only called in esm-bundler builds.\n * It is called when a renderer is created, in `baseCreateRenderer` so that\n * importing runtime-core is side-effects free.\n *\n * istanbul-ignore-next\n */\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (false) {}\n  if (false) {}\n  if (false) {}\n}\nconst queuePostRenderEffect = queueEffectWithSuspense;\n/**\n * The createRenderer function accepts two generic arguments:\n * HostNode and HostElement, corresponding to Node and Element types in the\n * host environment. For example, for runtime-dom, HostNode would be the DOM\n * `Node` interface and HostElement would be the DOM `Element` interface.\n *\n * Custom renderers can pass in the platform specific types like this:\n *\n * ``` js\n * const { render, createApp } = createRenderer<Node, Element>({\n *   patchProp,\n *   ...nodeOps\n * })\n * ```\n */\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\n// Separate API for creating hydration-enabled renderer.\n// Hydration logic is only used when calling this function, making it\n// tree-shakable.\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\n// implementation\nfunction baseCreateRenderer(options, createHydrationFns) {\n  // compile-time feature flags check\n  {\n    initFeatureFlags();\n  }\n  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .getGlobalThis */ .E9)();\n  target.__VUE__ = true;\n  if (false) {}\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  // Note: functions inside this closure should use `const xxx = () => {}`\n  // style in order to prevent being inlined by minifiers.\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    // patching & not same type, unmount old tree\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2 /* PatchFlags.BAIL */) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const {\n      type,\n      ref,\n      shapeFlag\n    } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG);\n        } else if (false) {}\n        break;\n      case Fragment:\n        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        break;\n      default:\n        if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n        } else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n        } else if (false) {}\n    }\n    // set ref\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);\n    } else {\n      // there's no support for dynamic comments\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, isSVG) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\n  };\n  /**\n   * Dev / HMR only\n   */\n  const patchStaticNode = (n1, n2, container, isSVG) => {\n    // static nodes are only patched during dev for HMR\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      // remove existing\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = ({\n    el,\n    anchor\n  }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({\n    el,\n    anchor\n  }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    isSVG = isSVG || n2.type === 'svg';\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    } else {\n      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const {\n      type,\n      props,\n      shapeFlag,\n      transition,\n      dirs\n    } = vnode;\n    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\n    // mount children first, since some props may rely on child content\n    // being already rendered, e.g. `<select value>`\n    if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, 'created');\n    }\n    // scopeId\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    // props\n    if (props) {\n      for (const key in props) {\n        if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isReservedProp */ .Gg)(key)) {\n          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      /**\n       * Special case for setting value on DOM elements:\n       * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\n       * - it needs to be forced (#1471)\n       * #2353 proposes adding another renderer option to configure this, but\n       * the properties affects are so finite it is worth special casing it\n       * here to reduce the complexity. (Special casing it also should not\n       * affect non-DOM renderers)\n       */\n      if ('value' in props) {\n        hostPatchProp(el, 'value', null, props.value);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (false) {}\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n    }\n    // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\n    // #1689 For inside suspense + suspense resolved case, just call it\n    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if (false /* PatchFlags.DEV_ROOT_FRAGMENT */) {}\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    let {\n      patchFlag,\n      dynamicChildren,\n      dirs\n    } = n2;\n    // #1426 take the old vnode's patch flag into account since user may clone a\n    // compiler-generated vnode, which de-opts to FULL_PROPS\n    patchFlag |= n1.patchFlag & 16 /* PatchFlags.FULL_PROPS */;\n    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT;\n    let vnodeHook;\n    // disable recurse in beforeUpdate hooks\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if (false) {}\n    const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\n    if (dynamicChildren) {\n      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\n      if (false) {}\n    } else if (!optimized) {\n      // full diff\n      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\n    }\n    if (patchFlag > 0) {\n      // the presence of a patchFlag means this element's render code was\n      // generated by the compiler and can take the fast path.\n      // in this path old node and new node are guaranteed to have the same shape\n      // (i.e. at the exact same position in the source template)\n      if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {\n        // element props contain dynamic keys, full diff needed\n        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n      } else {\n        // class\n        // this flag is matched when the element has dynamic class bindings.\n        if (patchFlag & 2 /* PatchFlags.CLASS */) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, 'class', null, newProps.class, isSVG);\n          }\n        }\n        // style\n        // this flag is matched when the element has dynamic style bindings\n        if (patchFlag & 4 /* PatchFlags.STYLE */) {\n          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\n        }\n        // props\n        // This flag is matched when the element has dynamic prop/attr bindings\n        // other than class and style. The keys of dynamic prop/attrs are saved for\n        // faster iteration.\n        // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\n        // bail out and go through a full diff because we need to unset the old key\n        if (patchFlag & 8 /* PatchFlags.PROPS */) {\n          // if the flag is present then dynamicProps must be non-null\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            // #1471 force patch value\n            if (next !== prev || key === 'value') {\n              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\n            }\n          }\n        }\n      }\n      // text\n      // This flag is matched when the element has only dynamic text children.\n      if (patchFlag & 1 /* PatchFlags.TEXT */) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      // unoptimized, full diff\n      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\n      }, parentSuspense);\n    }\n  };\n  // The fast path for blocks.\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      // Determine the container (parent element) for the patch.\n      const container =\n      // oldVNode may be an errored async setup() component inside Suspense\n      // which will not have a mounted element\n      oldVNode.el && (\n      // - In the case of a Fragment, we need to provide the actual parent\n      // of the Fragment itself so it can move its children.\n      oldVNode.type === Fragment ||\n      // - In the case of different nodes, there is going to be a replacement\n      // which also requires the correct parent container\n      !isSameVNodeType(oldVNode, newVNode) ||\n      // - In the case of a component, it could contain anything.\n      oldVNode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 64 /* ShapeFlags.TELEPORT */)) ? hostParentNode(oldVNode.el) :\n      // In other cases, the parent container is not actually used so we\n      // just pass the block element here to avoid a DOM parentNode call.\n      fallbackContainer;\n      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\n    }\n  };\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT) {\n        for (const key in oldProps) {\n          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isReservedProp */ .Gg)(key) && !(key in newProps)) {\n            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n          }\n        }\n      }\n      for (const key in newProps) {\n        // empty string is not valid prop\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isReservedProp */ .Gg)(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        // defer patching value\n        if (next !== prev && key !== 'value') {\n          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      if ('value' in newProps) {\n        hostPatchProp(el, 'value', oldProps.value, newProps.value);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');\n    let {\n      patchFlag,\n      dynamicChildren,\n      slotScopeIds: fragmentSlotScopeIds\n    } = n2;\n    if (false) {}\n    // check if this is a slot fragment with :slotted scope ids\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      // a fragment can only have array children\n      // since they are either generated by the compiler, or implicitly created\n      // from arrays.\n      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */ && dynamicChildren &&\n      // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        // a stable fragment (template root or <template v-for>) doesn't need to\n        // patch children order, but it may contain dynamicChildren.\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\n        if (false) {} else if (\n        // #2080 if the stable fragment has a key, it's a <template v-for> that may\n        //  get moved around. Make sure all root level vnodes inherit el.\n        // #2134 or if it's a component root, it may also get moved around\n        // as the component is being moved.\n        n2.key != null || parentComponent && n2 === parentComponent.subTree) {\n          traverseStaticChildren(n1, n2, true /* shallow */);\n        }\n      } else {\n        // keyed / unkeyed, or manual fragments.\n        // for keyed & unkeyed, since they are compiler generated from v-for,\n        // each child is guaranteed to be a block so the fragment will never\n        // have dynamicChildren.\n        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */) {\n        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\n      } else {\n        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);\n    if (false) {}\n    if (false) {}\n    // inject renderer internals for keepAlive\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    // resolve props and slots for setup context\n    {\n      if (false) {}\n      setupComponent(instance);\n      if (false) {}\n    }\n    // setup() is async. This component relies on async logic to be resolved\n    // before proceeding\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n      // Give it a placeholder if this is not hydration\n      // TODO handle self-defined fallback\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n      return;\n    }\n    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\n    if (false) {}\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        // async & still pending - just update props and slots\n        // since the component's reactive effect for render isn't set-up yet\n        if (false) {}\n        updateComponentPreRender(instance, n2, optimized);\n        if (false) {}\n        return;\n      } else {\n        // normal update\n        instance.next = n2;\n        // in case the child component is also queued, remove it to avoid\n        // double updating the same child component in the same flush.\n        invalidateJob(instance.update);\n        // instance.update is the reactive effect.\n        instance.update();\n      }\n    } else {\n      // no update needed. just copy over properties\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const {\n          el,\n          props\n        } = initialVNode;\n        const {\n          bm,\n          m,\n          parent\n        } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        // beforeMount hook\n        if (bm) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .invokeArrayFns */ .ir)(bm);\n        }\n        // onVnodeBeforeMount\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          // vnode has adopted host node - perform hydration instead of mount.\n          const hydrateSubTree = () => {\n            if (false) {}\n            instance.subTree = renderComponentRoot(instance);\n            if (false) {}\n            if (false) {}\n            hydrateNode(el, instance.subTree, instance, parentSuspense, null);\n            if (false) {}\n          };\n          if (isAsyncWrapperVNode) {\n            initialVNode.type.__asyncLoader().then(\n            // note: we are moving the render call into an async callback,\n            // which means it won't track dependencies - but it's ok because\n            // a server-rendered async wrapper is already in resolved state\n            // and it will never need to change.\n            () => !instance.isUnmounted && hydrateSubTree());\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (false) {}\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (false) {}\n          if (false) {}\n          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\n          if (false) {}\n          initialVNode.el = subTree.el;\n        }\n        // mounted hook\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        // onVnodeMounted\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\n        }\n        // activated hook for keep-alive roots.\n        // #1742 activated hook must be accessed after first render\n        // since the hook may be injected by a child keep-alive\n        if (initialVNode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if (false) {}\n        // #2458: deference mount-only object parameters to prevent memleaks\n        initialVNode = container = anchor = null;\n      } else {\n        // updateComponent\n        // This is triggered by mutation of component's own state (next: null)\n        // OR parent calling processComponent (next: VNode)\n        let {\n          next,\n          bu,\n          u,\n          parent,\n          vnode\n        } = instance;\n        let originNext = next;\n        let vnodeHook;\n        if (false) {}\n        // Disallow component effect recursion during pre-lifecycle hooks.\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        // beforeUpdate hook\n        if (bu) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .invokeArrayFns */ .ir)(bu);\n        }\n        // onVnodeBeforeUpdate\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        // render\n        if (false) {}\n        const nextTree = renderComponentRoot(instance);\n        if (false) {}\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (false) {}\n        patch(prevTree, nextTree,\n        // parent may have changed if it's in a teleport\n        hostParentNode(prevTree.el),\n        // anchor may have changed if it's in a fragment\n        getNextHostNode(prevTree), instance, parentSuspense, isSVG);\n        if (false) {}\n        next.el = nextTree.el;\n        if (originNext === null) {\n          // self-triggered update. In case of HOC, update parent component\n          // vnode el. HOC is indicated by parent instance's subTree pointing\n          // to child component's vnode\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        // updated hook\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        // onVnodeUpdated\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\n        }\n        if (false) {}\n        if (false) {}\n      }\n    };\n    // create reactive effect for rendering\n    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .ReactiveEffect */ .qq(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope\n    );\n    const update = instance.update = () => effect.run();\n    update.id = instance.uid;\n    // allowRecurse\n    // #1801, #2043 component render effects should allow recursive updates\n    toggleRecurse(instance, true);\n    if (false) {}\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .pauseTracking */ .Jd)();\n    // props update may have triggered pre-flush watchers.\n    // flush them before the render update.\n    flushPreFlushCbs();\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .resetTracking */ .lk)();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const {\n      patchFlag,\n      shapeFlag\n    } = n2;\n    // fast path\n    if (patchFlag > 0) {\n      if (patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */) {\n        // this could be either fully-keyed or mixed (some keyed some not)\n        // presence of patchFlag means children are guaranteed to be arrays\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        return;\n      } else if (patchFlag & 256 /* PatchFlags.UNKEYED_FRAGMENT */) {\n        // unkeyed\n        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        return;\n      }\n    }\n    // children has 3 possibilities: text, array or no children.\n    if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n      // text children fast path\n      if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        // prev children was array\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n          // two arrays, cannot assume anything, do full diff\n          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else {\n          // no new children, just unmount old\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        // prev children was text OR null\n        // new children is array OR null\n        if (prevShapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n          hostSetElementText(container, '');\n        }\n        // mount new if array\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_ARR */ .Z6;\n    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_ARR */ .Z6;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n    } else {\n      // mount new\n      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\n    }\n  };\n  // can be all-keyed or mixed\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1; // prev ending index\n    let e2 = l2 - 1; // next ending index\n    // 1. sync from start\n    // (a b) c\n    // (a b) d e\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      i++;\n    }\n    // 2. sync from end\n    // a (b c)\n    // d e (b c)\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    // 3. common sequence + mount\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n          i++;\n        }\n      }\n    }\n    // 4. common sequence + unmount\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    }\n    // 5. unknown sequence\n    // [i ... e1 + 1]: a b [c d e] f g\n    // [i ... e2 + 1]: a b [e d c h] f g\n    // i = 2, e1 = 4, e2 = 5\n    else {\n      const s1 = i; // prev starting index\n      const s2 = i; // next starting index\n      // 5.1 build key:index map for newChildren\n      const keyToNewIndexMap = new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if (false) {}\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      // 5.2 loop through old children left to be patched and try to patch\n      // matching nodes & remove nodes that are no longer present\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      // used to track whether any node has moved\n      let maxNewIndexSoFar = 0;\n      // works as Map<newIndex, oldIndex>\n      // Note that oldIndex is offset by +1\n      // and oldIndex = 0 is a special value indicating the new node has\n      // no corresponding old node.\n      // used for determining longest stable subsequence\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          // all new children have been patched so this can only be a removal\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          // key-less node, try to locate a key-less node of the same type\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === undefined) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n          patched++;\n        }\n      }\n      // 5.3 move and mount\n      // generate longest stable subsequence only when nodes have moved\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_ARR */ .Z6;\n      j = increasingNewIndexSequence.length - 1;\n      // looping backwards so that we can use last patched node as anchor\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          // mount new\n          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (moved) {\n          // move if:\n          // There is no stable subsequence (e.g. a reverse)\n          // OR current node is not among the stable sequence\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2 /* MoveType.REORDER */);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const {\n      el,\n      type,\n      transition,\n      children,\n      shapeFlag\n    } = vnode;\n    if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    // single nodes\n    const needTransition = moveType !== 2 /* MoveType.REORDER */ && shapeFlag & 1 /* ShapeFlags.ELEMENT */ && transition;\n    if (needTransition) {\n      if (moveType === 0 /* MoveType.ENTER */) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const {\n          leave,\n          delayLeave,\n          afterLeave\n        } = transition;\n        const remove = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode;\n    // unset ref\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 /* ShapeFlags.ELEMENT */ && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\n      }\n      if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\n      } else if (dynamicChildren && (\n      // #1153: fast path should not be taken for non-stable (v-for) fragments\n      type !== Fragment || patchFlag > 0 && patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */)) {\n        // fast path for block nodes: only need to unmount dynamic children.\n        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n      } else if (type === Fragment && patchFlag & (128 /* PatchFlags.KEYED_FRAGMENT */ | 256 /* PatchFlags.UNKEYED_FRAGMENT */) || !optimized && shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\n      }, parentSuspense);\n    }\n  };\n  const remove = vnode => {\n    const {\n      type,\n      el,\n      anchor,\n      transition\n    } = vnode;\n    if (type === Fragment) {\n      if (false) {} else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && transition && !transition.persisted) {\n      const {\n        leave,\n        delayLeave\n      } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    // For fragments, directly remove all contained DOM nodes.\n    // (fragment child nodes cannot have transition)\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if (false) {}\n    const {\n      bum,\n      scope,\n      update,\n      subTree,\n      um\n    } = instance;\n    // beforeUnmount hook\n    if (bum) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .invokeArrayFns */ .ir)(bum);\n    }\n    // stop effects in component scope\n    scope.stop();\n    // update may be null if a component is unmounted before its async\n    // setup has resolved.\n    if (update) {\n      // so that scheduler will no longer invoke it\n      update.active = false;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    // unmounted hook\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    // A component with async dep inside a pending suspense is unmounted before\n    // its async dep resolves. This should remove the dep from the suspense, and\n    // cause the suspense to resolve immediately if that was the last dep.\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n    if (false) {}\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = vnode => {\n    if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n      return vnode.suspense.next();\n    }\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n  const render = (vnode, container, isSVG) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG);\n    }\n    flushPreFlushCbs();\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(internals);\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction toggleRecurse({\n  effect,\n  update\n}, allowed) {\n  effect.allowRecurse = update.allowRecurse = allowed;\n}\n/**\n * #1156\n * When a component is HMR-enabled, we need to make sure that all static nodes\n * inside a block also inherit the DOM element from the previous tree so that\n * HMR updates (which are full updates) can retrieve the element for patching.\n *\n * #2080\n * Inside keyed `template` fragment static children, if a fragment is moved,\n * the children will always be moved. Therefore, in order to ensure correct move\n * position, el should be inherited from previous nodes.\n */\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      // this is only called in the optimized path so array children are\n      // guaranteed to be vnodes\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow) traverseStaticChildren(c1, c2);\n      }\n      // #6852 also inherit for text nodes\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n      // also inherit for comment nodes, but not placeholders (e.g. v-if which\n      // would have received .el during block patch)\n      if (false) {}\n    }\n  }\n}\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nconst isTeleport = type => type.__isTeleport;\nconst isTeleportDisabled = props => props && (props.disabled || props.disabled === '');\nconst isTargetSVG = target => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(targetSelector)) {\n    if (!select) {\n       false && 0;\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if (!target) {\n         false && 0;\n      }\n      return target;\n    }\n  } else {\n    if (false) {}\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {\n        insert,\n        querySelector,\n        createText,\n        createComment\n      }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let {\n      shapeFlag,\n      children,\n      dynamicChildren\n    } = n2;\n    // #3302\n    // HMR updated, force full diff\n    if (false) {}\n    if (n1 == null) {\n      // insert anchors in the main view\n      const placeholder = n2.el =  false ? 0 : createText('');\n      const mainAnchor = n2.anchor =  false ? 0 : createText('');\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText('');\n      if (target) {\n        insert(targetAnchor, target);\n        // #2652 we could be teleporting from a non-SVG tree into an SVG tree\n        isSVG = isSVG || isTargetSVG(target);\n      } else if (false) {}\n      const mount = (container, anchor) => {\n        // Teleport *always* has Array children. This is enforced in both the\n        // compiler and vnode children normalization.\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n          mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      // update content\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      isSVG = isSVG || isTargetSVG(target);\n      if (dynamicChildren) {\n        // fast path when the teleport happens to be a block root\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\n        // even in block tree mode we need to make sure all root-level nodes\n        // in the teleport inherit previous DOM references so that they can\n        // be moved in future patches.\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          // enabled -> disabled\n          // move into main container\n          moveTeleport(n2, container, mainAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);\n        }\n      } else {\n        // target changed\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);\n          if (nextTarget) {\n            moveTeleport(n2, nextTarget, null, internals, 0 /* TeleportMoveTypes.TARGET_CHANGE */);\n          } else if (false) {}\n        } else if (wasDisabled) {\n          // disabled -> enabled\n          // move into teleport target\n          moveTeleport(n2, target, targetAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);\n        }\n      }\n    }\n    updateCssVars(n2);\n  },\n  remove(vnode, parentComponent, parentSuspense, optimized, {\n    um: unmount,\n    o: {\n      remove: hostRemove\n    }\n  }, doRemove) {\n    const {\n      shapeFlag,\n      children,\n      anchor,\n      targetAnchor,\n      target,\n      props\n    } = vnode;\n    if (target) {\n      hostRemove(targetAnchor);\n    }\n    // an unmounted teleport should always remove its children if not disabled\n    if (doRemove || !isTeleportDisabled(props)) {\n      hostRemove(anchor);\n      if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\n        }\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, {\n  o: {\n    insert\n  },\n  m: move\n}, moveType = 2 /* TeleportMoveTypes.REORDER */) {\n  // move target anchor if this is a target change.\n  if (moveType === 0 /* TeleportMoveTypes.TARGET_CHANGE */) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const {\n    el,\n    anchor,\n    shapeFlag,\n    children,\n    props\n  } = vnode;\n  const isReorder = moveType === 2 /* TeleportMoveTypes.REORDER */;\n  // move main view anchor if this is a re-order.\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  // if this is a re-order and teleport is enabled (content is in target)\n  // do not move children. So the opposite is: only move children if this\n  // is not a reorder, or the teleport is disabled\n  if (!isReorder || isTeleportDisabled(props)) {\n    // Teleport has either Array children or no children.\n    if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, parentAnchor, 2 /* MoveType.REORDER */);\n      }\n    }\n  }\n  // move main view anchor if this is a re-order.\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: {\n    nextSibling,\n    parentNode,\n    querySelector\n  }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(vnode.props, querySelector);\n  if (target) {\n    // if multiple teleports rendered to the same target element, we need to\n    // pick up from where the last teleport finished instead of the first node\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\n        vnode.targetAnchor = targetNode;\n      } else {\n        vnode.anchor = nextSibling(node);\n        // lookahead until we find the target anchor\n        // we cannot rely on return value of hydrateChildren() because there\n        // could be nested teleports\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          targetAnchor = nextSibling(targetAnchor);\n          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === 'teleport anchor') {\n            vnode.targetAnchor = targetAnchor;\n            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n            break;\n          }\n        }\n        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\n      }\n    }\n    updateCssVars(vnode);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\n// Force-casted public typing for h and TSX props inference\nconst Teleport = (/* unused pure expression or super */ null && (TeleportImpl));\nfunction updateCssVars(vnode) {\n  // presence of .ut method indicates owner component uses css vars.\n  // code path here can assume browser environment.\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node = vnode.children[0].el;\n    while (node !== vnode.targetAnchor) {\n      if (node.nodeType === 1) node.setAttribute('data-v-owner', ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\nconst Fragment = Symbol( false ? 0 : undefined);\nconst Text = Symbol( false ? 0 : undefined);\nconst Comment = Symbol( false ? 0 : undefined);\nconst Static = Symbol( false ? 0 : undefined);\n// Since v-if and v-for are the two possible ways node structure can dynamically\n// change, once we consider v-if branches and each v-for fragment a block, we\n// can divide a template into nested blocks, and within each block the node\n// structure would be stable. This allows us to skip most children diffing\n// and only worry about the dynamic nodes (indicated by patch flags).\nconst blockStack = [];\nlet currentBlock = null;\n/**\n * Open a block.\n * This must be called before `createBlock`. It cannot be part of `createBlock`\n * because the children of the block are evaluated before `createBlock` itself\n * is called. The generated code typically looks like this:\n *\n * ```js\n * function render() {\n *   return (openBlock(),createBlock('div', null, [...]))\n * }\n * ```\n * disableTracking is true when creating a v-for fragment block, since a v-for\n * fragment always diffs its children.\n *\n * @private\n */\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\n// Whether we should be tracking dynamic child nodes inside a block.\n// Only tracks when this value is > 0\n// We are not using a simple boolean because this value may need to be\n// incremented/decremented by nested usage of v-once (see below)\nlet isBlockTreeEnabled = 1;\n/**\n * Block tracking sometimes needs to be disabled, for example during the\n * creation of a tree that needs to be cached by v-once. The compiler generates\n * code like this:\n *\n * ``` js\n * _cache[1] || (\n *   setBlockTracking(-1),\n *   _cache[1] = createVNode(...),\n *   setBlockTracking(1),\n *   _cache[1]\n * )\n * ```\n *\n * @private\n */\nfunction setBlockTracking(value) {\n  isBlockTreeEnabled += value;\n}\nfunction setupBlock(vnode) {\n  // save current block children on the block vnode\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_ARR */ .Z6 : null;\n  // close block\n  closeBlock();\n  // a block is always going to be patched, so track it as a child of its\n  // parent block\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\n/**\n * @private\n */\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\n}\n/**\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\n * A block root keeps track of dynamic nodes within the block in the\n * `dynamicChildren` array.\n *\n * @private\n */\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));\n}\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  if (false) {}\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\n/**\n * Internal API for registering an arguments transform for createVNode\n * used for creating stubs in the test-utils\n * It is *internal* but needs to be exposed for test-utils to pick up proper\n * typings\n */\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));\n};\nconst InternalObjectKey = `__vInternal`;\nconst normalizeKey = ({\n  key\n}) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isRef */ .dq)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(ref) ? {\n    i: currentRenderingInstance,\n    r: ref,\n    k: ref_key,\n    f: !!ref_for\n  } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ShapeFlags.ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    // normalize suspense children\n    if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    // compiled element vnode - if children is passed, only possible types are\n    // string or Array.\n    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(children) ? 8 /* ShapeFlags.TEXT_CHILDREN */ : 16 /* ShapeFlags.ARRAY_CHILDREN */;\n  }\n  // validate key\n  if (false) {}\n  // track vnode for block tree\n  if (isBlockTreeEnabled > 0 &&\n  // avoid a block node from tracking itself\n  !isBlockNode &&\n  // has current parent block\n  currentBlock && (\n  // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  vnode.patchFlag > 0 || shapeFlag & 6 /* ShapeFlags.COMPONENT */) &&\n  // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32 /* PatchFlags.HYDRATE_EVENTS */) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst createVNode =  false ? 0 : _createVNode;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if (false) {}\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    // createVNode receiving an existing vnode. This happens in cases like\n    // <component :is=\"vnode\"/>\n    // #2078 make sure to merge refs during the clone instead of overwriting it\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */);\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag |= -2 /* PatchFlags.BAIL */;\n    return cloned;\n  }\n  // class component normalization.\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  // class & style normalization.\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    props = guardReactiveProps(props);\n    let {\n      class: klass,\n      style\n    } = props;\n    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(klass)) {\n      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .normalizeClass */ .C_)(klass);\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(style)) {\n      // reactive state objects need to be cloned since they are likely to be\n      // mutated\n      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isProxy */ .X3)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(style)) {\n        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)({}, style);\n      }\n      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .normalizeStyle */ .j5)(style);\n    }\n  }\n  // encode the vnode type information into a bitmap\n  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isString */ .HD)(type) ? 1 /* ShapeFlags.ELEMENT */ : isSuspense(type) ? 128 /* ShapeFlags.SUSPENSE */ : isTeleport(type) ? 64 /* ShapeFlags.TELEPORT */ : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(type) ? 4 /* ShapeFlags.STATEFUL_COMPONENT */ : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(type) ? 2 /* ShapeFlags.FUNCTIONAL_COMPONENT */ : 0;\n  if (false) {}\n  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\n}\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .isProxy */ .X3)(props) || InternalObjectKey in props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n  // This is intentionally NOT using spread or extend to avoid the runtime\n  // key enumeration cost.\n  const {\n    props,\n    ref,\n    patchFlag,\n    children\n  } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ?\n    // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n    // if the vnode itself already has a ref, cloneVNode will need to merge\n    // the refs so the single vnode can be set on multiple refs\n    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children:  false ? 0 : children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node\n    ? 16 /* PatchFlags.FULL_PROPS */ : patchFlag | 16 /* PatchFlags.FULL_PROPS */ : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  return cloned;\n}\n/**\n * Dev only, for HMR of hoisted vnodes reused in v-for\n * https://github.com/vitejs/vite/issues/2022\n */\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if (isArray(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\n/**\n * @private\n */\nfunction createTextVNode(text = ' ', flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\n/**\n * @private\n */\nfunction createStaticVNode(content, numberOfNodes) {\n  // A static vnode can contain multiple stringified elements, and the number\n  // of elements is necessary for hydration.\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\n/**\n * @private\n */\nfunction createCommentVNode(text = '',\n// when used as the v-else branch, the comment node must be created as a\n// block to ensure correct updates.\nasBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === 'boolean') {\n    // empty placeholder\n    return createVNode(Comment);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(child)) {\n    // fragment\n    return createVNode(Fragment, null,\n    // #3666, avoid reference pollution when reusing vnode\n    child.slice());\n  } else if (typeof child === 'object') {\n    // already vnode, this should be the most common since compiled templates\n    // always produce all-vnode children arrays\n    return cloneIfMounted(child);\n  } else {\n    // strings and numbers\n    return createVNode(Text, null, String(child));\n  }\n}\n// optimized normalization for template-compiled render fns\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 /* PatchFlags.HOISTED */ || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const {\n    shapeFlag\n  } = vnode;\n  if (children == null) {\n    children = null;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(children)) {\n    type = 16 /* ShapeFlags.ARRAY_CHILDREN */;\n  } else if (typeof children === 'object') {\n    if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 64 /* ShapeFlags.TELEPORT */)) {\n      // Normalize slot to plain children for plain element and Teleport\n      const slot = children.default;\n      if (slot) {\n        // _c marker is added by withCtx() indicating this is a compiled slot\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32 /* ShapeFlags.SLOTS_CHILDREN */;\n      const slotFlag = children._;\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 /* SlotFlags.FORWARDED */ && currentRenderingInstance) {\n        // a child component receives forwarded slots from the parent.\n        // its slot type is determined by its parent's slot type.\n        if (currentRenderingInstance.slots._ === 1 /* SlotFlags.STABLE */) {\n          children._ = 1 /* SlotFlags.STABLE */;\n        } else {\n          children._ = 2 /* SlotFlags.DYNAMIC */;\n          vnode.patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n        }\n      }\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(children)) {\n    children = {\n      default: children,\n      _ctx: currentRenderingInstance\n    };\n    type = 32 /* ShapeFlags.SLOTS_CHILDREN */;\n  } else {\n    children = String(children);\n    // force teleport children to array so it can be moved around\n    if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n      type = 16 /* ShapeFlags.ARRAY_CHILDREN */;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8 /* ShapeFlags.TEXT_CHILDREN */;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === 'class') {\n        if (ret.class !== toMerge.class) {\n          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .normalizeClass */ .C_)([ret.class, toMerge.class]);\n        }\n      } else if (key === 'style') {\n        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .normalizeStyle */ .j5)([ret.style, toMerge.style]);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isOn */ .F7)(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== '') {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7 /* ErrorCodes.VNODE_HOOK */, [vnode, prevVNode]);\n}\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  // inherit parent app context - or - if root, adopt from root vnode\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    next: null,\n    subTree: null,\n    effect: null,\n    update: null,\n    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .EffectScope */ .Bj(true /* detached */),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    emitted: null,\n    // props default value\n    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    data: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    props: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_OBJ */ .kT,\n    setupContext: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (false) {} else {\n    instance.ctx = {\n      _: instance\n    };\n  }\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  // apply custom element special handling\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nconst setCurrentInstance = instance => {\n  currentInstance = instance;\n  instance.scope.on();\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  currentInstance = null;\n};\nconst isBuiltInTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap('slot,component')));\nfunction validateComponentName(name, config) {\n  const appIsNativeTag = config.isNativeTag || NO;\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component id: ' + name);\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false) {\n  isInSSRComponentSetup = isSSR;\n  const {\n    props,\n    children\n  } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;\n  isInSSRComponentSetup = false;\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (false) {}\n  // 0. create render proxy property access cache\n  instance.accessCache = Object.create(null);\n  // 1. create public instance / render proxy\n  // also mark it raw so it's never observed\n  instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .markRaw */ .Xl)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\n  if (false) {}\n  // 2. call setup()\n  const {\n    setup\n  } = Component;\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    setCurrentInstance(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .pauseTracking */ .Jd)();\n    const setupResult = callWithErrorHandling(setup, instance, 0 /* ErrorCodes.SETUP_FUNCTION */, [ false ? 0 : instance.props, setupContext]);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .resetTracking */ .lk)();\n    unsetCurrentInstance();\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isPromise */ .tI)(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        // return the promise so server-renderer can wait on it\n        return setupResult.then(resolvedResult => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch(e => {\n          handleError(e, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);\n        });\n      } else {\n        // async setup returned Promise.\n        // bail here and wait for re-entry.\n        instance.asyncDep = setupResult;\n        if (false) {}\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(setupResult)) {\n    // setup returned an inline render function\n    if (instance.type.__ssrInlineRender) {\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\n      // set it as ssrRender instead.\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(setupResult)) {\n    if (false) {}\n    // setup returned bindings.\n    // assuming a render function compiled from template is present.\n    if (false) {}\n    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .proxyRefs */ .WL)(setupResult);\n    if (false) {}\n  } else if (false) {}\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\n/**\n * For runtime-dom to register the compiler.\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\n */\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = i => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\n// dev only\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  // template / render function normalization\n  // could be already set when returned from setup()\n  if (!instance.render) {\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\n    // is done by server-renderer\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || resolveMergedOptions(instance).template;\n      if (template) {\n        if (false) {}\n        const {\n          isCustomElement,\n          compilerOptions\n        } = instance.appContext.config;\n        const {\n          delimiters,\n          compilerOptions: componentCompilerOptions\n        } = Component;\n        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .extend */ .l7)({\n          isCustomElement,\n          delimiters\n        }, compilerOptions), componentCompilerOptions);\n        Component.render = compile(template, finalCompilerOptions);\n        if (false) {}\n      }\n    }\n    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .NOOP */ .dG;\n    // for runtime-compiled render functions using `with` blocks, the render\n    // proxy used needs a different `has` handler which is more performant and\n    // also only allows a allowlist of globals to fallthrough.\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  // support for 2.x options\n  if (true) {\n    setCurrentInstance(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .pauseTracking */ .Jd)();\n    applyOptions(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .resetTracking */ .lk)();\n    unsetCurrentInstance();\n  }\n  // warn missing template/render\n  // the runtime compilation of template in SSR is done by server-render\n  if (false) {}\n}\nfunction createAttrsProxy(instance) {\n  return new Proxy(instance.attrs,  false ? 0 : {\n    get(target, key) {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .track */ .j)(instance, \"get\" /* TrackOpTypes.GET */, '$attrs');\n      return target[key];\n    }\n  });\n}\nfunction createSetupContext(instance) {\n  const expose = exposed => {\n    if (false) {}\n    instance.exposed = exposed || {};\n  };\n  let attrs;\n  if (false) {} else {\n    return {\n      get attrs() {\n        return attrs || (attrs = createAttrsProxy(instance));\n      },\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    };\n  }\n}\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .proxyRefs */ .WL)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .markRaw */ .Xl)(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\nfunction getComponentName(Component, includeInferred = true) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\n/* istanbul ignore next */\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    // try to infer the name based on reverse resolution\n    const inferFromRegistry = registry => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isFunction */ .mf)(value) && '__vccOpts' in value;\n}\nconst computed = (getterOrOptions, debugOptions) => {\n  // @ts-ignore\n  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(getterOrOptions, debugOptions, isInSSRComponentSetup);\n};\n\n// dev only\nconst warnRuntimeUsage = method => warn(`${method}() is a compiler-hint helper that is only usable inside ` + `<script setup> of a single file component. Its arguments should be ` + `compiled away and passing it at runtime has no effect.`);\n// implementation\nfunction defineProps() {\n  if (false) {}\n  return null;\n}\n// implementation\nfunction defineEmits() {\n  if (false) {}\n  return null;\n}\n/**\n * Vue `<script setup>` compiler macro for declaring a component's exposed\n * instance properties when it is accessed by a parent component via template\n * refs.\n *\n * `<script setup>` components are closed by default - i.e. variables inside\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\n * via `defineExpose`.\n *\n * This is only usable inside `<script setup>`, is compiled away in the\n * output and should **not** be actually called at runtime.\n */\nfunction defineExpose(exposed) {\n  if (false) {}\n}\n/**\n * Vue `<script setup>` compiler macro for providing props default values when\n * using type-based `defineProps` declaration.\n *\n * Example usage:\n * ```ts\n * withDefaults(defineProps<{\n *   size?: number\n *   labels?: string[]\n * }>(), {\n *   size: 3,\n *   labels: () => ['default label']\n * })\n * ```\n *\n * This is only usable inside `<script setup>`, is compiled away in the output\n * and should **not** be actually called at runtime.\n */\nfunction withDefaults(props, defaults) {\n  if (false) {}\n  return null;\n}\nfunction useSlots() {\n  return getContext().slots;\n}\nfunction useAttrs() {\n  return getContext().attrs;\n}\nfunction getContext() {\n  const i = getCurrentInstance();\n  if (false) {}\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\n/**\n * Runtime helper for merging default declarations. Imported by compiled code\n * only.\n * @internal\n */\nfunction mergeDefaults(raw, defaults) {\n  const props = isArray(raw) ? raw.reduce((normalized, p) => (normalized[p] = {}, normalized), {}) : raw;\n  for (const key in defaults) {\n    const opt = props[key];\n    if (opt) {\n      if (isArray(opt) || isFunction(opt)) {\n        props[key] = {\n          type: opt,\n          default: defaults[key]\n        };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      props[key] = {\n        default: defaults[key]\n      };\n    } else if (false) {}\n  }\n  return props;\n}\n/**\n * Used to create a proxy for the rest element when destructuring props with\n * defineProps().\n * @internal\n */\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\n/**\n * `<script setup>` helper for persisting the current instance context over\n * async/await flows.\n *\n * `@vue/compiler-sfc` converts the following:\n *\n * ```ts\n * const x = await foo()\n * ```\n *\n * into:\n *\n * ```ts\n * let __temp, __restore\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\n * ```\n * @internal\n */\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  if (false) {}\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if (isPromise(awaitable)) {\n    awaitable = awaitable.catch(e => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\n\n// Actual implementation\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isObject */ .Kn)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__/* .isArray */ .kJ)(propsOrChildren)) {\n      // single vnode without props\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      }\n      // props without children\n      return createVNode(type, propsOrChildren);\n    } else {\n      // omit props\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return createVNode(type, propsOrChildren, children);\n  }\n}\nconst ssrContextKey = Symbol( false ? 0 : ``);\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    if (!ctx) {\n       false && 0;\n    }\n    return ctx;\n  }\n};\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction initCustomFormatter() {\n  /* eslint-disable no-restricted-globals */\n  if (true) {\n    return;\n  }\n  const vueStyle = {\n    style: 'color:#3ba776'\n  };\n  const numberStyle = {\n    style: 'color:#0b1bc9'\n  };\n  const stringStyle = {\n    style: 'color:#b62e24'\n  };\n  const keywordStyle = {\n    style: 'color:#9d288c'\n  };\n  // custom formatter for Chrome\n  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n  const formatter = {\n    header(obj) {\n      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\n      if (!isObject(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return ['div', vueStyle, `VueInstance`];\n      } else if (isRef(obj)) {\n        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), `>`];\n      } else if (isReactive(obj)) {\n        return ['div', {}, ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'], '<', formatValue(obj), `>${isReadonly(obj) ? ` (readonly)` : ``}`];\n      } else if (isReadonly(obj)) {\n        return ['div', {}, ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'], '<', formatValue(obj), '>'];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return ['div', {}, ...formatInstance(obj.$)];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock('props', toRaw(instance.props)));\n    }\n    if (instance.setupState !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('setup', instance.setupState));\n    }\n    if (instance.data !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('data', toRaw(instance.data)));\n    }\n    const computed = extractKeys(instance, 'computed');\n    if (computed) {\n      blocks.push(createInstanceBlock('computed', computed));\n    }\n    const injected = extractKeys(instance, 'inject');\n    if (injected) {\n      blocks.push(createInstanceBlock('injected', injected));\n    }\n    blocks.push(['div', {}, ['span', {\n      style: keywordStyle.style + ';opacity:0.66'\n    }, '$ (internal): '], ['object', {\n      object: instance\n    }]]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = extend({}, target);\n    if (!Object.keys(target).length) {\n      return ['span', {}];\n    }\n    return ['div', {\n      style: 'line-height:1.25em;margin-bottom:0.6em'\n    }, ['div', {\n      style: 'color:#476582'\n    }, type], ['div', {\n      style: 'padding-left:1.25em'\n    }, ...Object.keys(target).map(key => {\n      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];\n    })]];\n  }\n  function formatValue(v, asRaw = true) {\n    if (typeof v === 'number') {\n      return ['span', numberStyle, v];\n    } else if (typeof v === 'string') {\n      return ['span', stringStyle, JSON.stringify(v)];\n    } else if (typeof v === 'boolean') {\n      return ['span', keywordStyle, v];\n    } else if (isObject(v)) {\n      return ['object', {\n        object: asRaw ? toRaw(v) : v\n      }];\n    } else {\n      return ['span', stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if (isFunction(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if (isShallow(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  // shallow clone\n  ret.memo = memo.slice();\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (hasChanged(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  // make sure to let parent block track it when returning cached\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\n\n// Core API ------------------------------------------------------------------\nconst version = \"3.2.47\";\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode,\n  normalizeVNode\n};\n/**\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\n * @internal\n */\nconst ssrUtils = (/* unused pure expression or super */ null && (_ssrUtils));\n/**\n * @internal only exposed in compat builds\n */\nconst resolveFilter = null;\n/**\n * @internal only exposed in compat builds.\n */\nconst compatUtils = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLE1BQU0xQyxPQUFPLEdBQUcsUUFBUTtBQUN4QixNQUFNNi9CLFNBQVMsR0FBRztFQUNkMU4sdUJBQXVCO0VBQ3ZCQyxjQUFjO0VBQ2QxdEIsbUJBQW1CO0VBQ25CbEIsMkJBQTJCO0VBQzNCNEQsT0FBTztFQUNQOUI7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNdzZCLFFBQVEsR0FBSUQsZ0RBQUFBLFNBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsYUFBYSxHQUFHLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsV0FBVyxHQUFJLElBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanM/ZDJkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIGdldEN1cnJlbnRTY29wZSwgaXNTaGFsbG93IGFzIGlzU2hhbGxvdyQxLCBpc1JlYWN0aXZlLCBSZWFjdGl2ZUVmZmVjdCwgcmVmLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIGxvb3NlVG9OdW1iZXIsIGh5cGhlbmF0ZSwgY2FtZWxpemUsIGlzT2JqZWN0LCBpc09uLCBoYXNPd24sIGlzTW9kZWxMaXN0ZW5lciwgdG9OdW1iZXIsIGhhc0NoYW5nZWQsIHJlbW92ZSwgaXNTZXQsIGlzTWFwLCBpc1BsYWluT2JqZWN0LCBpbnZva2VBcnJheUZucywgaXNSZWdFeHAsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgY2FwaXRhbGl6ZSwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBkZWYsIGlzUmVzZXJ2ZWRQcm9wLCBFTVBUWV9BUlIsIHRvUmF3VHlwZSwgbWFrZU1hcCwgTk8sIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xuICAgIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gICAgc3RhY2sucG9wKCk7XG59XG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gYXZvaWQgcHJvcHMgZm9ybWF0dGluZyBvciB3YXJuIGhhbmRsZXIgdHJhY2tpbmcgZGVwcyB0aGF0IG1pZ2h0IGJlIG11dGF0ZWRcbiAgICAvLyBkdXJpbmcgcGF0Y2gsIGxlYWRpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XG4gICAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcbiAgICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gICAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBXYXJuSGFuZGxlciwgaW5zdGFuY2UsIDExIC8qIEVycm9yQ29kZXMuQVBQX1dBUk5fSEFORExFUiAqLywgW1xuICAgICAgICAgICAgbXNnICsgYXJncy5qb2luKCcnKSxcbiAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxuICAgICAgICAgICAgdHJhY2VcbiAgICAgICAgICAgICAgICAubWFwKCh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YClcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyksXG4gICAgICAgICAgICB0cmFjZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0cmFjZS5sZW5ndGggJiZcbiAgICAgICAgICAgIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXG4gICAgICAgICAgICAhZmFsc2UpIHtcbiAgICAgICAgICAgIHdhcm5BcmdzLnB1c2goYFxcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgICB9XG4gICAgcmVzZXRUcmFja2luZygpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gICAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXG4gICAgLy8gaW5zdGFuY2UgcGFyZW50IHBvaW50ZXJzLlxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gICAgY29uc3QgbG9ncyA9IFtdO1xuICAgIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XG4gICAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICAgIHJldHVybiB2bm9kZS5wcm9wc1xuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxuICAgICAgICA6IFtvcGVuICsgY2xvc2VdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgICB9KTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2FybihgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICsgYGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgIHdhcm4oYCR7dHlwZX0gaXMgTmFOIC0gYCArICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XG4gICAgfVxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xuICAgIFtcInNwXCIgLyogTGlmZWN5Y2xlSG9va3MuU0VSVkVSX1BSRUZFVENIICovXTogJ3NlcnZlclByZWZldGNoIGhvb2snLFxuICAgIFtcImJjXCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX0NSRUFURSAqL106ICdiZWZvcmVDcmVhdGUgaG9vaycsXG4gICAgW1wiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkNSRUFURUQgKi9dOiAnY3JlYXRlZCBob29rJyxcbiAgICBbXCJibVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9NT1VOVCAqL106ICdiZWZvcmVNb3VudCBob29rJyxcbiAgICBbXCJtXCIgLyogTGlmZWN5Y2xlSG9va3MuTU9VTlRFRCAqL106ICdtb3VudGVkIGhvb2snLFxuICAgIFtcImJ1XCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX1VQREFURSAqL106ICdiZWZvcmVVcGRhdGUgaG9vaycsXG4gICAgW1widVwiIC8qIExpZmVjeWNsZUhvb2tzLlVQREFURUQgKi9dOiAndXBkYXRlZCcsXG4gICAgW1wiYnVtXCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX1VOTU9VTlQgKi9dOiAnYmVmb3JlVW5tb3VudCBob29rJyxcbiAgICBbXCJ1bVwiIC8qIExpZmVjeWNsZUhvb2tzLlVOTU9VTlRFRCAqL106ICd1bm1vdW50ZWQgaG9vaycsXG4gICAgW1wiYVwiIC8qIExpZmVjeWNsZUhvb2tzLkFDVElWQVRFRCAqL106ICdhY3RpdmF0ZWQgaG9vaycsXG4gICAgW1wiZGFcIiAvKiBMaWZlY3ljbGVIb29rcy5ERUFDVElWQVRFRCAqL106ICdkZWFjdGl2YXRlZCBob29rJyxcbiAgICBbXCJlY1wiIC8qIExpZmVjeWNsZUhvb2tzLkVSUk9SX0NBUFRVUkVEICovXTogJ2Vycm9yQ2FwdHVyZWQgaG9vaycsXG4gICAgW1wicnRjXCIgLyogTGlmZWN5Y2xlSG9va3MuUkVOREVSX1RSQUNLRUQgKi9dOiAncmVuZGVyVHJhY2tlZCBob29rJyxcbiAgICBbXCJydGdcIiAvKiBMaWZlY3ljbGVIb29rcy5SRU5ERVJfVFJJR0dFUkVEICovXTogJ3JlbmRlclRyaWdnZXJlZCBob29rJyxcbiAgICBbMCAvKiBFcnJvckNvZGVzLlNFVFVQX0ZVTkNUSU9OICovXTogJ3NldHVwIGZ1bmN0aW9uJyxcbiAgICBbMSAvKiBFcnJvckNvZGVzLlJFTkRFUl9GVU5DVElPTiAqL106ICdyZW5kZXIgZnVuY3Rpb24nLFxuICAgIFsyIC8qIEVycm9yQ29kZXMuV0FUQ0hfR0VUVEVSICovXTogJ3dhdGNoZXIgZ2V0dGVyJyxcbiAgICBbMyAvKiBFcnJvckNvZGVzLldBVENIX0NBTExCQUNLICovXTogJ3dhdGNoZXIgY2FsbGJhY2snLFxuICAgIFs0IC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0xFQU5VUCAqL106ICd3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb24nLFxuICAgIFs1IC8qIEVycm9yQ29kZXMuTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi9dOiAnbmF0aXZlIGV2ZW50IGhhbmRsZXInLFxuICAgIFs2IC8qIEVycm9yQ29kZXMuQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi9dOiAnY29tcG9uZW50IGV2ZW50IGhhbmRsZXInLFxuICAgIFs3IC8qIEVycm9yQ29kZXMuVk5PREVfSE9PSyAqL106ICd2bm9kZSBob29rJyxcbiAgICBbOCAvKiBFcnJvckNvZGVzLkRJUkVDVElWRV9IT09LICovXTogJ2RpcmVjdGl2ZSBob29rJyxcbiAgICBbOSAvKiBFcnJvckNvZGVzLlRSQU5TSVRJT05fSE9PSyAqL106ICd0cmFuc2l0aW9uIGhvb2snLFxuICAgIFsxMCAvKiBFcnJvckNvZGVzLkFQUF9FUlJPUl9IQU5ETEVSICovXTogJ2FwcCBlcnJvckhhbmRsZXInLFxuICAgIFsxMSAvKiBFcnJvckNvZGVzLkFQUF9XQVJOX0hBTkRMRVIgKi9dOiAnYXBwIHdhcm5IYW5kbGVyJyxcbiAgICBbMTIgLyogRXJyb3JDb2Rlcy5GVU5DVElPTl9SRUYgKi9dOiAncmVmIGZ1bmN0aW9uJyxcbiAgICBbMTMgLyogRXJyb3JDb2Rlcy5BU1lOQ19DT01QT05FTlRfTE9BREVSICovXTogJ2FzeW5jIGNvbXBvbmVudCBsb2FkZXInLFxuICAgIFsxNCAvKiBFcnJvckNvZGVzLlNDSEVEVUxFUiAqL106ICdzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuICcgK1xuICAgICAgICAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL2NvcmUnXG59O1xuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAgICAgcmVzLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcbiAgICAgICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XG4gICAgICAgIC8vIGluIHByb2R1Y3Rpb24gdGhlIGhvb2sgcmVjZWl2ZXMgb25seSB0aGUgZXJyb3IgY29kZVxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcbiAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xuICAgICAgICBjb25zdCBhcHBFcnJvckhhbmRsZXIgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5lcnJvckhhbmRsZXI7XG4gICAgICAgIGlmIChhcHBFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEVycm9yQ29kZXMuQVBQX0VSUk9SX0hBTkRMRVIgKi8sIFtlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXTtcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2FybihgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3Jhc2ggaW4gZGV2IGJ5IGRlZmF1bHQgc28gaXQncyBtb3JlIG5vdGljZWFibGVcbiAgICAgICAgaWYgKHRocm93SW5EZXYpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVjb3ZlciBpbiBwcm9kIHRvIHJlZHVjZSB0aGUgaW1wYWN0IG9uIGVuZC11c2VyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XG5sZXQgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgZmx1c2hJbmRleCA9IDA7XG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XG4gICAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcbn1cbi8vICMyNzY4XG4vLyBVc2UgYmluYXJ5LXNlYXJjaCB0byBmaW5kIGEgc3VpdGFibGUgcG9zaXRpb24gaW4gdGhlIHF1ZXVlLFxuLy8gc28gdGhhdCB0aGUgcXVldWUgbWFpbnRhaW5zIHRoZSBpbmNyZWFzaW5nIG9yZGVyIG9mIGpvYidzIGlkLFxuLy8gd2hpY2ggY2FuIHByZXZlbnQgdGhlIGpvYiBmcm9tIGJlaW5nIHNraXBwZWQgYW5kIGFsc28gY2FuIGF2b2lkIHJlcGVhdGVkIHBhdGNoaW5nLlxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gICAgLy8gdGhlIHN0YXJ0IGluZGV4IHNob3VsZCBiZSBgZmx1c2hJbmRleCArIDFgXG4gICAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XG4gICAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcbiAgICAgICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChxdWV1ZVttaWRkbGVdKTtcbiAgICAgICAgbWlkZGxlSm9iSWQgPCBpZCA/IChzdGFydCA9IG1pZGRsZSArIDEpIDogKGVuZCA9IG1pZGRsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICAgIC8vIHRoZSBkZWR1cGUgc2VhcmNoIHVzZXMgdGhlIHN0YXJ0SW5kZXggYXJndW1lbnQgb2YgQXJyYXkuaW5jbHVkZXMoKVxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIHNlYXJjaCBpbmRleCBpbmNsdWRlcyB0aGUgY3VycmVudCBqb2IgdGhhdCBpcyBiZWluZyBydW5cbiAgICAvLyBzbyBpdCBjYW5ub3QgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgYWdhaW4uXG4gICAgLy8gaWYgdGhlIGpvYiBpcyBhIHdhdGNoKCkgY2FsbGJhY2ssIHRoZSBzZWFyY2ggd2lsbCBzdGFydCB3aXRoIGEgKzEgaW5kZXggdG9cbiAgICAvLyBhbGxvdyBpdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiAtIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG9cbiAgICAvLyBlbnN1cmUgaXQgZG9lc24ndCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcC5cbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCB8fFxuICAgICAgICAhcXVldWUuaW5jbHVkZXMoam9iLCBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXgpKSB7XG4gICAgICAgIGlmIChqb2IuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUucHVzaChqb2IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2IuaWQpLCAwLCBqb2IpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlRmx1c2goKTtcbiAgICB9XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICAgIGlmICghaXNGbHVzaGluZyAmJiAhaXNGbHVzaFBlbmRpbmcpIHtcbiAgICAgICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xuICAgIGNvbnN0IGkgPSBxdWV1ZS5pbmRleE9mKGpvYik7XG4gICAgaWYgKGkgPiBmbHVzaEluZGV4KSB7XG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xuICAgICAgICBpZiAoIWFjdGl2ZVBvc3RGbHVzaENicyB8fFxuICAgICAgICAgICAgIWFjdGl2ZVBvc3RGbHVzaENicy5pbmNsdWRlcyhjYiwgY2IuYWxsb3dSZWN1cnNlID8gcG9zdEZsdXNoSW5kZXggKyAxIDogcG9zdEZsdXNoSW5kZXgpKSB7XG4gICAgICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBpZiBjYiBpcyBhbiBhcnJheSwgaXQgaXMgYSBjb21wb25lbnQgbGlmZWN5Y2xlIGhvb2sgd2hpY2ggY2FuIG9ubHkgYmVcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IGEgam9iLCB3aGljaCBpcyBhbHJlYWR5IGRlZHVwZWQgaW4gdGhlIG1haW4gcXVldWUsIHNvXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxuICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goLi4uY2IpO1xuICAgIH1cbiAgICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIFxuLy8gaWYgY3VycmVudGx5IGZsdXNoaW5nLCBza2lwIHRoZSBjdXJyZW50IGpvYiBpdHNlbGZcbmkgPSBpc0ZsdXNoaW5nID8gZmx1c2hJbmRleCArIDEgOiAwKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2IgPSBxdWV1ZVtpXTtcbiAgICAgICAgaWYgKGNiICYmIGNiLnByZSkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xuICAgIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xuICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vICMxOTQ3IGFscmVhZHkgaGFzIGFjdGl2ZSBxdWV1ZSwgbmVzdGVkIGZsdXNoUG9zdEZsdXNoQ2JzIGNhbGxcbiAgICAgICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcbiAgICAgICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSgpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG4gICAgICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgICB9XG59XG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gSW5maW5pdHkgOiBqb2IuaWQ7XG5jb25zdCBjb21wYXJhdG9yID0gKGEsIGIpID0+IHtcbiAgICBjb25zdCBkaWZmID0gZ2V0SWQoYSkgLSBnZXRJZChiKTtcbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICBpZiAoYS5wcmUgJiYgIWIucHJlKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYi5wcmUgJiYgIWEucHJlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xufTtcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZCBzbyBpdHMgcmVuZGVyIGVmZmVjdCB3aWxsIGhhdmUgc21hbGxlclxuICAgIC8vICAgIHByaW9yaXR5IG51bWJlcilcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcbiAgICAvLyAgICBpdHMgdXBkYXRlIGNhbiBiZSBza2lwcGVkLlxuICAgIHF1ZXVlLnNvcnQoY29tcGFyYXRvcik7XG4gICAgLy8gY29uZGl0aW9uYWwgdXNhZ2Ugb2YgY2hlY2tSZWN1cnNpdmVVcGRhdGUgbXVzdCBiZSBkZXRlcm1pbmVkIG91dCBvZlxuICAgIC8vIHRyeSAuLi4gY2F0Y2ggYmxvY2sgc2luY2UgUm9sbHVwIGJ5IGRlZmF1bHQgZGUtb3B0aW1pemVzIHRyZWVzaGFraW5nXG4gICAgLy8gaW5zaWRlIHRyeS1jYXRjaC4gVGhpcyBjYW4gbGVhdmUgYWxsIHdhcm5pbmcgY29kZSB1bnNoYWtlZC4gQWx0aG91Z2hcbiAgICAvLyB0aGV5IHdvdWxkIGdldCBldmVudHVhbGx5IHNoYWtlbiBieSBhIG1pbmlmaWVyIGxpa2UgdGVyc2VyLCBzb21lIG1pbmlmaWVyc1xuICAgIC8vIHdvdWxkIGZhaWwgdG8gZG8gdGhhdCAoZS5nLiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZXNidWlsZC9pc3N1ZXMvMTYxMClcbiAgICBjb25zdCBjaGVjayA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICA/IChqb2IpID0+IGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpXG4gICAgICAgIDogTk9PUDtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGpvYiAmJiBqb2IuYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYHJ1bm5pbmc6YCwgam9iLmlkKVxuICAgICAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhqb2IsIG51bGwsIDE0IC8qIEVycm9yQ29kZXMuU0NIRURVTEVSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuICAgICAgICAvLyBzb21lIHBvc3RGbHVzaENiIHF1ZXVlZCBqb2JzIVxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgICAgICAgZmx1c2hKb2JzKHNlZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XG4gICAgaWYgKCFzZWVuLmhhcyhmbikpIHtcbiAgICAgICAgc2Vlbi5zZXQoZm4sIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XG4gICAgICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5vd25lckluc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgICAgICAgICB3YXJuKGBNYXhpbXVtIHJlY3Vyc2l2ZSB1cGRhdGVzIGV4Y2VlZGVkJHtjb21wb25lbnROYW1lID8gYCBpbiBjb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZX0+YCA6IGBgfS4gYCArXG4gICAgICAgICAgICAgICAgYFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGAgK1xuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXG4gICAgICAgICAgICAgICAgYGluY2x1ZGUgY29tcG9uZW50IHRlbXBsYXRlLCByZW5kZXIgZnVuY3Rpb24sIHVwZGF0ZWQgaG9vayBvciBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSBuZXcgU2V0KCk7XG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XG4vLyBUaGlzIG1ha2VzIGl0IGVudGlyZWx5IHRyZWUtc2hha2FibGUgd2l0aG91dCBwb2xsdXRpbmcgdGhlIGV4cG9ydHMgYW5kIG1ha2VzXG4vLyBpdCBlYXNpZXIgdG8gYmUgdXNlZCBpbiB0b29saW5ncyBsaWtlIHZ1ZS1sb2FkZXJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXG4vLyB0byBiZSBzZXQgc28gdGhhdCBpdHMgaW5zdGFuY2VzIGNhbiBiZSByZWdpc3RlcmVkIC8gcmVtb3ZlZC5cbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgICAgICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcbiAgICAgICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcbiAgICB9O1xufVxuY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcbiAgICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcbiAgICAgICAgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gICAgfVxuICAgIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGluaXRpYWxEZWYpIHtcbiAgICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxuICAgICAgICBpbnN0YW5jZXM6IG5ldyBTZXQoKVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgaW5pdGlhbCByZWNvcmQgKGZvciBub3QteWV0LXJlbmRlcmVkIGNvbXBvbmVudClcbiAgICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICBpZiAobmV3UmVuZGVyKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICAgICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxuICAgICAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICAgIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICAgIGlmICghcmVjb3JkKVxuICAgICAgICByZXR1cm47XG4gICAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICAgIC8vIHVwZGF0ZSBpbml0aWFsIGRlZiAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50cylcbiAgICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICAgIC8vIGNyZWF0ZSBhIHNuYXBzaG90IHdoaWNoIGF2b2lkcyB0aGUgc2V0IGJlaW5nIG11dGF0ZWQgZHVyaW5nIHVwZGF0ZXNcbiAgICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgICAgICBpZiAoIWhtckRpcnR5Q29tcG9uZW50cy5oYXMob2xkQ29tcCkpIHtcbiAgICAgICAgICAgIC8vIDEuIFVwZGF0ZSBleGlzdGluZyBjb21wIGRlZmluaXRpb24gdG8gbWF0Y2ggbmV3IG9uZVxuICAgICAgICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMi4gbWFyayBkZWZpbml0aW9uIGRpcnR5LiBUaGlzIGZvcmNlcyB0aGUgcmVuZGVyZXIgdG8gcmVwbGFjZSB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBvbiBwYXRjaC5cbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gaW52YWxpZGF0ZSBvcHRpb25zIHJlc29sdXRpb24gY2FjaGVcbiAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgICAgICAvLyA0LiBhY3R1YWxseSB1cGRhdGVcbiAgICAgICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XG4gICAgICAgICAgICAvLyBjdXN0b20gZWxlbWVudFxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUob2xkQ29tcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXG4gICAgICAgICAgICAvLyBjb21wb25lbnRzIHRvIGJlIHVubW91bnRlZCBhbmQgcmUtbW91bnRlZC4gUXVldWUgdGhlIHVwZGF0ZSBzbyB0aGF0IHdlXG4gICAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgZm9yY2luZyB0aGUgc2FtZSBwYXJlbnQgdG8gcmUtcmVuZGVyIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBpbnNpZGUgdHJlZSBjcmVhdGVkIHZpYSByYXcgcmVuZGVyKCkuIEZvcmNlIHJlbG9hZC5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA1LiBtYWtlIHN1cmUgdG8gY2xlYW51cCBkaXJ0eSBobXIgY29tcG9uZW50cyBhZnRlciB1cGRhdGVcbiAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUobm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xuICAgIGV4dGVuZChvbGRDb21wLCBuZXdDb21wKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdfX2ZpbGUnICYmICEoa2V5IGluIG5ld0NvbXApKSB7XG4gICAgICAgICAgICBkZWxldGUgb2xkQ29tcFtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcbiAgICAgICAgICAgICAgICBgRnVsbCByZWxvYWQgcmVxdWlyZWQuYCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5sZXQgZGV2dG9vbHM7XG5sZXQgYnVmZmVyID0gW107XG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVtaXQkMShldmVudCwgLi4uYXJncykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2ssIHRhcmdldCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgZGV2dG9vbHMgPSBob29rO1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgICAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdqc2RvbScpKSkge1xuICAgICAgICBjb25zdCByZXBsYXkgPSAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPVxuICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW10pO1xuICAgICAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgICAgICAgc2V0RGV2dG9vbHNIb29rKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjbGVhciBidWZmZXIgYWZ0ZXIgM3MgLSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgZGV2dG9vbHMgaW5zdGFsbGVkXG4gICAgICAgIC8vIGF0IGFsbCwgYW5kIGtlZXBpbmcgdGhlIGJ1ZmZlciB3aWxsIGNhdXNlIG1lbW9yeSBsZWFrcyAoIzQ3MzgpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkZXZ0b29scykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm9uLWJyb3dzZXIgZW52LCBhc3N1bWUgbm90IGluc3RhbGxlZFxuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIERldnRvb2xzSG9va3MuQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xuICAgICAgICBGcmFnbWVudCxcbiAgICAgICAgVGV4dCxcbiAgICAgICAgQ29tbWVudCxcbiAgICAgICAgU3RhdGljXG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XG4gICAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBEZXZ0b29sc0hvb2tzLkFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogRGV2dG9vbHNIb29rcy5DT01QT05FTlRfQURERUQgKi8pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gXG4vKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogRGV2dG9vbHNIb29rcy5DT01QT05FTlRfVVBEQVRFRCAqLyk7XG5jb25zdCBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIERldnRvb2xzSG9va3MuQ09NUE9ORU5UX1JFTU9WRUQgKi8pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gKGNvbXBvbmVudCkgPT4ge1xuICAgIGlmIChkZXZ0b29scyAmJlxuICAgICAgICB0eXBlb2YgZGV2dG9vbHMuY2xlYW51cEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAvLyByZW1vdmUgdGhlIGNvbXBvbmVudCBpZiBpdCB3YXNuJ3QgYnVmZmVyZWRcbiAgICAgICAgIWRldnRvb2xzLmNsZWFudXBCdWZmZXIoY29tcG9uZW50KSkge1xuICAgICAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICAgICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xuICAgIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogRGV2dG9vbHNIb29rcy5QRVJGT1JNQU5DRV9TVEFSVCAqLyk7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBEZXZ0b29sc0hvb2tzLlBFUkZPUk1BTkNFX0VORCAqLyk7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICAgICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xuICAgIGVtaXQkMShcImNvbXBvbmVudDplbWl0XCIgLyogRGV2dG9vbHNIb29rcy5DT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgeyBlbWl0c09wdGlvbnMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoZXZlbnQpIGluIHByb3BzT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoZXZlbnQpfVwiIHByb3AuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICAgIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoJ3VwZGF0ZTonKTtcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYXBwbHkgbW9kaWZpZXJzIG9uIGFyZ3NcbiAgICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcbiAgICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYCR7bW9kZWxBcmcgPT09ICdtb2RlbFZhbHVlJyA/ICdtb2RlbCcgOiBtb2RlbEFyZ31Nb2RpZmllcnNgO1xuICAgICAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XG4gICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAoYSA9PiAoaXNTdHJpbmcoYSkgPyBhLnRyaW0oKSA6IGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAobG9vc2VUb051bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICAgICAgICB3YXJuKGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXG4gICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xuICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcbiAgICAgICAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xuICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGFuZGxlck5hbWU7XG4gICAgbGV0IGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpKV0gfHxcbiAgICAgICAgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxuICAgICAgICBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSldO1xuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhbHNvIHRyaWdnZXIga2ViYWItY2FzZSBlcXVpdmFsZW50XG4gICAgLy8gZm9yIHByb3BzIHBhc3NlZCB2aWEga2ViYWItY2FzZVxuICAgIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcbiAgICAgICAgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKSldO1xuICAgIH1cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBFcnJvckNvZGVzLkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhvbmNlSGFuZGxlciwgaW5zdGFuY2UsIDYgLyogRXJyb3JDb2Rlcy5DT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcbiAgICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgICAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgICAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgICByYXcuZm9yRWFjaChrZXkgPT4gKG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8vIENoZWNrIGlmIGFuIGluY29taW5nIHByb3Aga2V5IGlzIGEgZGVjbGFyZWQgZW1pdCBldmVudCBsaXN0ZW5lci5cbi8vIGUuZy4gV2l0aCBgZW1pdHM6IHsgY2xpY2s6IG51bGwgfWAsIHByb3BzIG5hbWVkIGBvbkNsaWNrYCBhbmQgYG9uY2xpY2tgIGFyZVxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCAnJyk7XG4gICAgcmV0dXJuIChoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8XG4gICAgICAgIGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHxcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGtleSkpO1xufVxuXG4vKipcbiAqIG1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlIGZvciBhc3NldCByZXNvbHV0aW9uIChlLmcuXG4gKiByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlKSBkdXJpbmcgcmVuZGVyXG4gKi9cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbi8qKlxuICogTm90ZTogcmVuZGVyaW5nIGNhbGxzIG1heWJlIG5lc3RlZC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBhcmVudCByZW5kZXJpbmdcbiAqIGluc3RhbmNlIGlmIHByZXNlbnQsIHdoaWNoIHNob3VsZCBiZSByZXN0b3JlZCBhZnRlciB0aGUgcmVuZGVyIGlzIGRvbmU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaSlcbiAqIC8vIC4uLnJlbmRlclxuICogc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBjdXJyZW50U2NvcGVJZCA9IChpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCkgfHwgbnVsbDtcbiAgICByZXR1cm4gcHJldjtcbn1cbi8qKlxuICogU2V0IHNjb3BlIGlkIHdoZW4gY3JlYXRpbmcgaG9pc3RlZCB2bm9kZXMuXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcbiAqL1xuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcbiAgICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuLyoqXG4gKiBUZWNobmljYWxseSB3ZSBubyBsb25nZXIgbmVlZCB0aGlzIGFmdGVyIDMuMC44IGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHNhbWVcbiAqIEFQSSBmb3IgYmFja3dhcmRzIGNvbXBhdCB3LyBjb2RlIGdlbmVyYXRlZCBieSBjb21waWxlcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xuICAgIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbn1cbi8qKlxuICogT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuLyoqXG4gKiBXcmFwIGEgc2xvdCBmdW5jdGlvbiB0byBtZW1vaXplIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcbiAqL1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QgLy8gZmFsc2Ugb25seVxuKSB7XG4gICAgaWYgKCFjdHgpXG4gICAgICAgIHJldHVybiBmbjtcbiAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAgICBpZiAoZm4uX24pIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gSWYgYSB1c2VyIGNhbGxzIGEgY29tcGlsZWQgc2xvdCBpbnNpZGUgYSB0ZW1wbGF0ZSBleHByZXNzaW9uICgjMTc0NSksIGl0XG4gICAgICAgIC8vIGNhbiBtZXNzIHVwIGJsb2NrIHRyYWNraW5nLCBzbyBieSBkZWZhdWx0IHdlIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYW5kXG4gICAgICAgIC8vIGZvcmNlIGJhaWwgb3V0IHdoZW4gaW52b2tpbmcgYSBjb21waWxlZCBzbG90IChpbmRpY2F0ZWQgYnkgdGhlIC5fZCBmbGFnKS5cbiAgICAgICAgLy8gVGhpcyBpc24ndCBuZWNlc3NhcnkgaWYgcmVuZGVyaW5nIGEgY29tcGlsZWQgYDxzbG90PmAsIHNvIHdlIGZsaXAgdGhlXG4gICAgICAgIC8vIC5fZCBmbGFnIG9mZiB3aGVuIGludm9raW5nIHRoZSB3cmFwcGVkIGZuIGluc2lkZSBgcmVuZGVyU2xvdGAuXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBtYXJrIG5vcm1hbGl6ZWQgdG8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGluZ1xuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICAgIC8vIG1hcmsgdGhpcyBhcyBjb21waWxlZCBieSBkZWZhdWx0XG4gICAgLy8gdGhpcyBpcyB1c2VkIGluIHZub2RlLnRzIC0+IG5vcm1hbGl6ZUNoaWxkcmVuKCkgdG8gc2V0IHRoZSBzbG90XG4gICAgLy8gcmVuZGVyaW5nIGZsYWcuXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gICAgLy8gZGlzYWJsZSBibG9jayB0cmFja2luZyBieSBkZWZhdWx0XG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5cbi8qKlxuICogZGV2IG9ubHkgZmxhZyB0byB0cmFjayB3aGV0aGVyICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyLlxuICogSWYgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIgdGhlbiB0aGUgd2FybmluZyBmb3IgZmFpbGVkIGF0dHJzXG4gKiBmYWxsdGhyb3VnaCBjYW4gYmUgc3VwcHJlc3NlZC5cbiAqL1xubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICAgIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xuICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50LCB2bm9kZSwgcHJveHksIHdpdGhQcm94eSwgcHJvcHMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sIHNsb3RzLCBhdHRycywgZW1pdCwgcmVuZGVyLCByZW5kZXJDYWNoZSwgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4LCBpbmhlcml0QXR0cnMgfSA9IGluc3RhbmNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XG4gICAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICAvLyB3aXRoUHJveHkgaXMgYSBwcm94eSB3aXRoIGEgZGlmZmVyZW50IGBoYXNgIHRyYXAgb25seSBmb3JcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXG4gICAgICAgICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmNhbGwocHJveHlUb1VzZSwgcHJveHlUb1VzZSwgcmVuZGVyQ2FjaGUsIHByb3BzLCBzZXR1cFN0YXRlLCBkYXRhLCBjdHgpKTtcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlciA9IENvbXBvbmVudDtcbiAgICAgICAgICAgIC8vIGluIGRldiwgbWFyayBhdHRycyBhY2Nlc3NlZCBpZiBvcHRpb25hbCBwcm9wcyAoYXR0cnMgPT09IHByb3BzKVxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICA/IHJlbmRlcihwcm9wcywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogeyBhdHRycywgc2xvdHMsIGVtaXQgfSlcbiAgICAgICAgICAgICAgICA6IHJlbmRlcihwcm9wcywgbnVsbCAvKiB3ZSBrbm93IGl0IGRvZXNuJ3QgbmVlZCBpdCAqLykpO1xuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xuICAgICAgICAgICAgICAgID8gYXR0cnNcbiAgICAgICAgICAgICAgICA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEgLyogRXJyb3JDb2Rlcy5SRU5ERVJfRlVOQ1RJT04gKi8pO1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICB9XG4gICAgLy8gYXR0ciBtZXJnaW5nXG4gICAgLy8gaW4gZGV2IG1vZGUsIGNvbW1lbnRzIGFyZSBwcmVzZXJ2ZWQsIGFuZCBpdCdzIHBvc3NpYmxlIGZvciBhIHRlbXBsYXRlXG4gICAgLy8gdG8gaGF2ZSBjb21tZW50cyBhbG9uZyBzaWRlIHRoZSByb290IGVsZW1lbnQgd2hpY2ggbWFrZXMgaXQgYSBmcmFnbWVudFxuICAgIGxldCByb290ID0gcmVzdWx0O1xuICAgIGxldCBzZXRSb290ID0gdW5kZWZpbmVkO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLykge1xuICAgICAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gfCA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSB2LW1vZGVsIGxpc3RlbmVyIChvblVwZGF0ZTp4eHgpIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjbGFyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcCwgaXQgaW5kaWNhdGVzIHRoaXMgY29tcG9uZW50IGV4cGVjdHMgdG8gaGFuZGxlIHYtbW9kZWwgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBub3QgZmFsbHRocm91Z2guXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQ6ICMxNTQzLCAjMTY0MywgIzE5ODlcbiAgICAgICAgICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKGZhbGx0aHJvdWdoQXR0cnMsIHByb3BzT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGhhbmRsZXJzIHdoZW4gdGhleSBmYWlsIHRvIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcbiAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xvbmUgYmVmb3JlIG11dGF0aW5nIHNpbmNlIHRoZSByb290IG1heSBiZSBhIGhvaXN0ZWQgdm5vZGVcbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCk7XG4gICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICAgIH1cbiAgICAvLyBpbmhlcml0IHRyYW5zaXRpb24gZGF0YVxuICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcbiAgICAgICAgc2V0Um9vdChyb290KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJvb3Q7XG4gICAgfVxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBkZXYgb25seVxuICogSW4gZGV2IG1vZGUsIHRlbXBsYXRlIHJvb3QgbGV2ZWwgY29tbWVudHMgYXJlIHJlbmRlcmVkLCB3aGljaCB0dXJucyB0aGVcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XG4gKiByb290IGZvciBhdHRycyBhbmQgc2NvcGUgaWQgcHJvY2Vzc2luZy5cbiAqL1xuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XG4gICAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICAgICAgcmV0dXJuIFt2bm9kZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gICAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICAgICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcbiAgICBsZXQgc2luZ2xlUm9vdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb3JlIHRoYW4gMSBub24tY29tbWVudCBjaGlsZCwgcmV0dXJuIG5vd1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gICAgbGV0IHJlcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCBpc09uKGtleSkpIHtcbiAgICAgICAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xuICAgIHJldHVybiAodm5vZGUuc2hhcGVGbGFnICYgKDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8gfCAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLykgfHxcbiAgICAgICAgdm5vZGUudHlwZSA9PT0gQ29tbWVudCAvLyBwb3RlbnRpYWwgdi1pZiBicmFuY2ggc3dpdGNoXG4gICAgKTtcbn07XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xuICAgIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XG4gICAgLy8gUGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiB3YXMgaG90LXVwZGF0ZWQuIFNpbmNlIHRoaXMgbWF5IGhhdmVcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXG4gICAgLy8gZm9yY2UgdGhlIGNoaWxkIHRvIHVwZGF0ZSBhcyB3ZWxsLlxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGZvcmNlIGNoaWxkIHVwZGF0ZSBmb3IgcnVudGltZSBkaXJlY3RpdmUgb3IgdHJhbnNpdGlvbiBvbiBjb21wb25lbnQgdm5vZGUuXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0IC8qIFBhdGNoRmxhZ3MuRFlOQU1JQ19TTE9UUyAqLykge1xuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IHRoYXQgcmVmZXJlbmNlcyB2YWx1ZXMgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBlLmcuIGluIGEgdi1mb3JcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi8pIHtcbiAgICAgICAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgdGhpcyBmbGFnIGluZGljYXRlcyBwcm9wcyBhcmUgYWx3YXlzIG5vbi1udWxsXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgOCAvKiBQYXRjaEZsYWdzLlBST1BTICovKSB7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHBhdGggaXMgb25seSB0YWtlbiBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcbiAgICAgICAgLy8gc28gcHJlc2VuY2Ugb2YgYW55IGNoaWxkcmVuIGxlYWRzIHRvIGEgZm9yY2VkIHVwZGF0ZVxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5leHRQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcbiAgICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxuICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCAvLyBIb3N0Tm9kZVxuKSB7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcbi8vIGluIHRoZSBjb21waWxlciwgYnV0IGludGVybmFsbHkgaXQncyBhIHNwZWNpYWwgYnVpbHQtaW4gdHlwZSB0aGF0IGhvb2tzXG4vLyBkaXJlY3RseSBpbnRvIHRoZSByZW5kZXJlci5cbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgICBuYW1lOiAnU3VzcGVuc2UnLFxuICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcbiAgICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xuICAgIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAgIC8vIGludGVybmFscy5cbiAgICBfX2lzU3VzcGVuc2U6IHRydWUsXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIFxuICAgIC8vIHBsYXRmb3JtLXNwZWNpZmljIGltcGwgcGFzc2VkIGZyb20gcmVuZGVyZXJcbiAgICByZW5kZXJlckludGVybmFscykge1xuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgbW91bnRTdXNwZW5zZShuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5LFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxufTtcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXG5jb25zdCBTdXNwZW5zZSA9IChTdXNwZW5zZUltcGxcbiAgICApO1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xuICAgIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpKTtcbiAgICAvLyBzdGFydCBtb3VudGluZyB0aGUgY29udGVudCBzdWJ0cmVlIGluIGFuIG9mZi1kb20gY29udGFpbmVyXG4gICAgcGF0Y2gobnVsbCwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBoaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgIC8vIG5vdyBjaGVjayBpZiB3ZSBoYXZlIGVuY291bnRlcmVkIGFueSBhc3luYyBkZXBzXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XG4gICAgICAgIC8vIGhhcyBhc3luY1xuICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XG4gICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUGVuZGluZycpO1xuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XG4gICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLnNzRmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU3VzcGVuc2UgaGFzIG5vIGFzeW5jIGRlcHMuIEp1c3QgcmVzb2x2ZS5cbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XG4gICAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgICBuMi5lbCA9IG4xLmVsO1xuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XG4gICAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgIHBhdGNoKHBlbmRpbmdCcmFuY2gsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgYmVmb3JlIHBlbmRpbmcgdHJlZSBpcyByZXNvbHZlZFxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0b2dnbGVkIGJlZm9yZSBoeWRyYXRpb24gaXMgZmluaXNoZWQsIHRoZSBjdXJyZW50IERPTSB0cmVlIGlzXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZhbGlkLiBzZXQgaXQgYXMgdGhlIGFjdGl2ZSBicmFuY2ggc28gaXQgd2lsbCBiZSB1bm1vdW50ZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBwZW5kaW5nIElELiB0aGlzIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSBhc3luYyBjYWxsYmFja3NcbiAgICAgICAgICAgIC8vIHJlc2V0IHN1c3BlbnNlIHN0YXRlXG4gICAgICAgICAgICBzdXNwZW5zZS5kZXBzID0gMDtcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgZWZmZWN0cyBmcm9tIHBlbmRpbmcgYnJhbmNoXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIGNvbnRhaW5lclxuICAgICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBpbiBmYWxsYmFjayBzdGF0ZVxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGVkIFwiYmFja1wiIHRvIGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZXNvbHZlXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGVkIHRvIGEgM3JkIGJyYW5jaFxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxuICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcm9vdCBub2RlIHRvZ2dsZWRcbiAgICAgICAgICAgIC8vIGludm9rZSBAcGVuZGluZyBldmVudFxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG4yLCAnb25QZW5kaW5nJyk7XG4gICAgICAgICAgICAvLyBtb3VudCBwZW5kaW5nIGJyYW5jaCBpbiBvZmYtZG9tIGNvbnRhaW5lclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xuICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5jb21pbmcgYnJhbmNoIGhhcyBubyBhc3luYyBkZXBzLCByZXNvbHZlIG5vdy5cbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50LCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgYGNvbnNvbGUuaW5mb2AgY2Fubm90IGJlIG51bGwgZXJyb3JcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmApO1xuICAgIH1cbiAgICBjb25zdCB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogdW5tb3VudCwgbjogbmV4dCwgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gICAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgICB9XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgICAgIHZub2RlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGRlcHM6IDAsXG4gICAgICAgIHBlbmRpbmdJZDogMCxcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgaXNIeWRyYXRpbmcsXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICAgICAgZWZmZWN0czogW10sXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBNb3ZlVHlwZS5FTlRFUiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcbiAgICAgICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHN1c3BlbnNlO1xuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZhbGxiYWNrIHRyZWUgd2FzIG1vdW50ZWQsIGl0IG1heSBoYXZlIGJlZW4gbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGNvbnRlbnQgZnJvbSBvZmYtZG9tIGNvbnRhaW5lciB0byBhY3R1YWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogTW92ZVR5cGUuRU5URVIgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgZmx1c2ggYWxsIGpvYnNcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25SZXNvbHZlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJlxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqLyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiB1bm1vdW50ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IGZyb20gdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBkZXAgaXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUuZWwpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN1c3BlbnNlO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgbm9kZS5wYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgbnVsbCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxuICAgIC8vIC0gc3VjY2Vzczogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBET00gYXNzdW1pbmcgaXQgaGFzIHN1Y2NlZWRlZCwgYnV0IHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovO1xuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XG4gICAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuXG4gICAgICAgID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKVxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgICBsZXQgYmxvY2s7XG4gICAgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgICAgICAgLy8gZGlzYWJsZVRyYWNraW5nOiBmYWxzZVxuICAgICAgICAgICAgLy8gYWxsb3cgYmxvY2sgdHJhY2tpbmcgZm9yIGNvbXBpbGVkIHNsb3RzXG4gICAgICAgICAgICAvLyAoc2VlIC4vY29tcG9uZW50UmVuZGVyQ29udGV4dC50cylcbiAgICAgICAgICAgIHMuX2QgPSBmYWxzZTtcbiAgICAgICAgICAgIG9wZW5CbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzKCk7XG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICAgICAgICBzLl9kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHMpKSB7XG4gICAgICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhc2luZ2xlQ2hpbGQpIHtcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gICAgfVxuICAgIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKGMgPT4gYyAhPT0gcyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XG4gICAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgSE9DIGVsXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xuICAgICAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxuICAgICAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxuICAgICAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICAgICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gYGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZWAgc28gdGhhdCB0aGlzIGNhbiBiZSBjYWxsZWQgaW5cbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAvLyAjMjQwMFxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHBDb250ZXh0J3MgYHByb3ZpZGVzYCBpZiB0aGUgaW5zdGFuY2UgaXMgYXQgcm9vdFxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXG4gICAgICAgICAgICA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlc1xuICAgICAgICAgICAgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UucHJveHkpXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gICAgfVxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdwb3N0JyB9KSA6IHsgZmx1c2g6ICdwb3N0JyB9KTtcbn1cbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSA6IHsgZmx1c2g6ICdzeW5jJyB9KTtcbn1cbi8vIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzIHRvIHRyaWdnZXIgb24gdW5kZWZpbmVkIGluaXRpYWwgdmFsdWVzXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICAgICAgd2FybihgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIGAgK1xuICAgICAgICAgICAgYFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IGAgK1xuICAgICAgICAgICAgYHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XG4gICAgfVxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsIHMsIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBgICtcbiAgICAgICAgICAgIGBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRTY29wZSgpID09PSAoY3VycmVudEluc3RhbmNlID09PSBudWxsIHx8IGN1cnJlbnRJbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEluc3RhbmNlLnNjb3BlKSA/IGN1cnJlbnRJbnN0YW5jZSA6IG51bGw7XG4gICAgLy8gY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2VcbiAgICBsZXQgZ2V0dGVyO1xuICAgIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93JDEoc291cmNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZTtcbiAgICAgICAgZGVlcCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUocyA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyQxKHMpKTtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcChzID0+IHtcbiAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIEVycm9yQ29kZXMuV0FUQ0hfR0VUVEVSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMyAvKiBFcnJvckNvZGVzLldBVENIX0NBTExCQUNLICovLCBbb25DbGVhbnVwXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBOT09QO1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG4gICAgaWYgKGNiICYmIGRlZXApIHtcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgICB9XG4gICAgbGV0IGNsZWFudXA7XG4gICAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgICAgICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIDQgLyogRXJyb3JDb2Rlcy5XQVRDSF9DTEVBTlVQICovKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxuICAgIC8vIHVubGVzcyBpdCdzIGVhZ2VyIG9yIHN5bmMgZmx1c2hcbiAgICBsZXQgc3NyQ2xlYW51cDtcbiAgICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgYWxzbyBub3QgY2FsbCB0aGUgaW52YWxpZGF0ZSBjYWxsYmFjayAoKyBydW5uZXIgaXMgbm90IHNldCB1cClcbiAgICAgICAgb25DbGVhbnVwID0gTk9PUDtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgZ2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqLywgW1xuICAgICAgICAgICAgICAgIGdldHRlcigpLFxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB1c2VTU1JDb250ZXh0KCk7XG4gICAgICAgICAgICBzc3JDbGVhbnVwID0gY3R4Ll9fd2F0Y2hlckhhbmRsZXMgfHwgKGN0eC5fX3dhdGNoZXJIYW5kbGVzID0gW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE5PT1A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZVxuICAgICAgICA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSlcbiAgICAgICAgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWVmZmVjdC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgKGZhbHNlICApKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBiZWZvcmUgcnVubmluZyBjYiBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2F0Y2hFZmZlY3RcbiAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gaW1wb3J0YW50OiBtYXJrIHRoZSBqb2IgYXMgYSB3YXRjaGVyIGNhbGxiYWNrIHNvIHRoYXQgc2NoZWR1bGVyIGtub3dzXG4gICAgLy8gaXQgaXMgYWxsb3dlZCB0byBzZWxmLXRyaWdnZXIgKCMxNzI3KVxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xuICAgIGxldCBzY2hlZHVsZXI7XG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gam9iOyAvLyB0aGUgc2NoZWR1bGVyIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGRpcmVjdGx5XG4gICAgfVxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdDogJ3ByZSdcbiAgICAgICAgam9iLnByZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZSlcbiAgICAgICAgICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVKb2Ioam9iKTtcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGVmZmVjdC5vblRyYWNrID0gb25UcmFjaztcbiAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBydW5cbiAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgam9iKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xuICAgICAgICBlZmZlY3Quc3RvcCgpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc2NvcGUpIHtcbiAgICAgICAgICAgIHJlbW92ZShpbnN0YW5jZS5zY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoc3NyQ2xlYW51cClcbiAgICAgICAgc3NyQ2xlYW51cC5wdXNoKHVud2F0Y2gpO1xuICAgIHJldHVybiB1bndhdGNoO1xufVxuLy8gdGhpcy4kd2F0Y2hcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xuICAgIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxuICAgICAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSlcbiAgICAgICAgICAgIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgbGV0IGNiO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBjYiA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xuICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gICAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZXQgY3VyID0gY3R4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi9dKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2VlbiA9IHNlZW4gfHwgbmV3IFNldCgpO1xuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIHNlZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxuICAgICAgICBsZWF2aW5nVk5vZGVzOiBuZXcgTWFwKClcbiAgICB9O1xuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICAgIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbW9kZTogU3RyaW5nLFxuICAgICAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgICAgIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgICAgICAgLy8gZW50ZXJcbiAgICAgICAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgLy8gbGVhdmVcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgLy8gYXBwZWFyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgICAgIGxldCBwcmV2VHJhbnNpdGlvbktleTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWNvbW1lbnQgY2hpbGRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gbW9yZSB0aGFuIG9uZSBub24tY29tbWVudCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2sgcmVhY3Rpdml0eSBmb3IgdGhlc2UgcHJvcHMgc28gdXNlIHRoZSByYXdcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIG1vZGUgJiZcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnaW4tb3V0JyAmJlxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdvdXQtaW4nICYmXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgd2FybihgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIDx0cmFuc2l0aW9uPjxrZWVwLWFsaXZlLz48L3RyYW5zaXRpb24+LCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxuICAgICAgICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldEtlZXBBbGl2ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghaW5uZXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldEtlZXBBbGl2ZUNoaWxkKG9sZENoaWxkKTtcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgeyBnZXRUcmFuc2l0aW9uS2V5IH0gPSBpbm5lckNoaWxkLnR5cGU7XG4gICAgICAgICAgICBpZiAoZ2V0VHJhbnNpdGlvbktleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlRyYW5zaXRpb25LZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSBwcmV2VHJhbnNpdGlvbktleSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXG4gICAgICAgICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJlxuICAgICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJlxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9sZCB0cmVlJ3MgaG9va3MgaW4gY2FzZSBvZiBkeW5hbWljIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgYmV0d2VlbiBkaWZmZXJlbnQgdmlld3NcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjNjgzNVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYWxzbyBuZWVkcyB0byBiZSB1cGRhdGVkIHdoZW4gYWN0aXZlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnVwZGF0ZS5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXJseSByZW1vdmFsIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcbiAgICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xuICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuLy8gVGhlIHRyYW5zaXRpb24gaG9va3MgYXJlIGF0dGFjaGVkIHRvIHRoZSB2bm9kZSBhcyB2bm9kZS50cmFuc2l0aW9uXG4vLyBhbmQgd2lsbCBiZSBjYWxsZWQgYXQgYXBwcm9wcmlhdGUgdGltaW5nIGluIHRoZSByZW5kZXJlci5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7IGFwcGVhciwgbW9kZSwgcGVyc2lzdGVkID0gZmFsc2UsIG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uQWZ0ZXJFbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25CZWZvcmVMZWF2ZSwgb25MZWF2ZSwgb25BZnRlckxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciwgb25BcHBlYXIsIG9uQWZ0ZXJBcHBlYXIsIG9uQXBwZWFyQ2FuY2VsbGVkIH0gPSBwcm9wcztcbiAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gICAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgICAgICBob29rICYmXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBFcnJvckNvZGVzLlRSQU5TSVRJT05fSE9PSyAqLywgYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xuICAgICAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgICAgICAgaWYgKGhvb2suZXZlcnkoaG9vayA9PiBob29rLmxlbmd0aCA8PSAxKSlcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBob29rcyA9IHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgcGVyc2lzdGVkLFxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW50ZXIoZWwpIHtcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgICAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuLy8gdGhlIHBsYWNlaG9sZGVyIHJlYWxseSBvbmx5IGhhbmRsZXMgb25lIHNwZWNpYWwgY2FzZTogS2VlcEFsaXZlXG4vLyBpbiB0aGUgY2FzZSBvZiBhIEtlZXBBbGl2ZSBpbiBhIGxlYXZlIHBoYXNlIHdlIG5lZWQgdG8gcmV0dXJuIGEgS2VlcEFsaXZlXG4vLyBwbGFjZWhvbGRlciB3aXRoIGVtcHR5IGNvbnRlbnQgdG8gYXZvaWQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBmcm9tIGJlaW5nXG4vLyB1bm1vdW50ZWQuXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XG4gICAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xuICAgIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSlcbiAgICAgICAgPyB2bm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgPyB2bm9kZS5jaGlsZHJlblswXVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgOiB2bm9kZTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLyAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcbiAgICAgICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gIzUzNjAgaW5oZXJpdCBwYXJlbnQga2V5IGluIGNhc2Ugb2YgPHRlbXBsYXRlIHYtZm9yPlxuICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZC5rZXlcbiAgICAgICAgICAgIDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi8pXG4gICAgICAgICAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW1lbnQgcGxhY2Vob2xkZXJzIHNob3VsZCBiZSBza2lwcGVkLCBlLmcuIHYtaWZcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxuICAgIC8vIGZyYWdtZW50cyB3aWxsIGJlIG1lcmdlZCBpbnRvIGEgZmxhdCBjaGlsZHJlbiBhcnJheS4gU2luY2UgZWFjaCB2LWZvclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cbiAgICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgICB9XG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLCBvbkVycm9yOiB1c2VyT25FcnJvciB9ID0gc291cmNlO1xuICAgIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgbGV0IHJlc29sdmVkQ29tcDtcbiAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gbG9hZCgpO1xuICAgIH07XG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9XG4gICAgICAgICAgICAgICAgbG9hZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgICAgICBuYW1lOiAnQXN5bmNDb21wb25lbnRXcmFwcGVyJyxcbiAgICAgICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICAgICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldHVwKCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEzIC8qIEVycm9yQ29kZXMuQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqLywgIWVycm9yQ29tcG9uZW50IC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi8pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxuICAgICAgICAgICAgaWYgKChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSkgfHxcbiAgICAgICAgICAgICAgICAoaXNJblNTUkNvbXBvbmVudFNldHVwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY29tcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWQoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMga2VlcC1hbGl2ZSwgZm9yY2UgdXBkYXRlIHNvIHRoZSBsb2FkZWQgY29tcG9uZW50J3NcbiAgICAgICAgICAgICAgICAgICAgLy8gbmFtZSBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7IHJlZiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgICAvLyBlbnN1cmUgaW5uZXIgY29tcG9uZW50IGluaGVyaXRzIHRoZSBhc3luYyB3cmFwcGVyJ3MgcmVmIG93bmVyXG4gICAgdm5vZGUucmVmID0gcmVmO1xuICAgIC8vIHBhc3MgdGhlIGN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIG9uIHRvIHRoZSBpbm5lciBjb21wXG4gICAgLy8gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBhc3luYyB3cmFwcGVyXG4gICAgdm5vZGUuY2UgPSBjZTtcbiAgICBkZWxldGUgcGFyZW50LnZub2RlLmNlO1xuICAgIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gICAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgICAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcbiAgICAgICAgLy8gYW5kIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZXhwb3NlcyBhY3RpdmF0ZS9kZWFjdGl2YXRlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXG4gICAgICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXG4gICAgICAgIC8vIGZvciBLZWVwQWxpdmUsIHdlIGp1c3QgbmVlZCB0byByZW5kZXIgaXRzIGNoaWxkcmVuXG4gICAgICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICAgICAgY29uc3QgeyByZW5kZXJlcjogeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IF91bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9IH0gPSBzaGFyZWRDb250ZXh0O1xuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIE1vdmVUeXBlLkVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgcGF0Y2goaW5zdGFuY2Uudm5vZGUsIHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdm5vZGUuc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxIC8qIE1vdmVUeXBlLkxFQVZFICovLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5kYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNoYXBlRmxhZyBzbyBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkXG4gICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmICghZmlsdGVyIHx8ICFmaWx0ZXIobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8ICFpc1NhbWVWTm9kZVR5cGUoY2FjaGVkLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdW5tb3VudCBpdCBub3cgYnV0IGl0IG1pZ2h0IGJlIGxhdGVyLCBzbyByZXNldCBpdHMgZmxhZyBub3cuXG4gICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJ1bmUgY2FjaGUgb24gaW5jbHVkZS9leGNsdWRlIHByb3AgY2hhbmdlXG4gICAgICAgIHdhdGNoKCgpID0+IFtwcm9wcy5pbmNsdWRlLCBwcm9wcy5leGNsdWRlXSwgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XG4gICAgICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XG4gICAgICAgIH0sIFxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgICB7IGZsdXNoOiAncG9zdCcsIGRlZXA6IHRydWUgfSk7XG4gICAgICAgIC8vIGNhY2hlIHN1YiB0cmVlIGFmdGVyIHJlbmRlclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZml4ICMxNjIxLCB0aGUgcGVuZGluZ0NhY2hlS2V5IGNvdWxkIGJlIDBcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICAgICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKGNhY2hlZCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSAmJiBjYWNoZWQua2V5ID09PSB2bm9kZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGludm9rZSBpdHMgZGVhY3RpdmF0ZWQgaG9vayBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgICAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBjb21wb25lbnRzLCBuYW1lIGNoZWNrIHNob3VsZCBiZSBiYXNlZCBpbiBpdHMgbG9hZGVkXG4gICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpc0FzeW5jV3JhcHBlcih2bm9kZSlcbiAgICAgICAgICAgICAgICA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9XG4gICAgICAgICAgICAgICAgOiBjb21wKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxuICAgICAgICAgICAgaWYgKHZub2RlLmVsKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2ggb3Igc2NvcGVJZCwgc28gdGhlIHZub2RlIGhlcmUgbWF5IG5vdCBiZSB0aGUgZmluYWwgdm5vZGVcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxuICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQvYmVmb3JlVXBkYXRlIGhvb2tzLlxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSBvdmVyIG1vdW50ZWQgc3RhdGVcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcbiAgICAgICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICAgICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gaXNTdXNwZW5zZShyYXdWTm9kZS50eXBlKSA/IHJhd1ZOb2RlIDogdm5vZGU7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmNsdWRlcyhuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogTGlmZWN5Y2xlSG9va3MuQUNUSVZBVEVEICovLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIExpZmVjeWNsZUhvb2tzLkRFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxuICAgIC8vIGhvb2sgY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dkY1wiIHN0YW5kcyBmb3IgXCJ3aXRoXG4gICAgLy8gZGVhY3RpdmF0aW9uIGNoZWNrXCIuXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XG4gICAgICAgIChob29rLl9fd2RjID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gb25seSBmaXJlIHRoZSBob29rIGlmIHRoZSB0YXJnZXQgaW5zdGFuY2UgaXMgTk9UIGluIGEgZGVhY3RpdmF0ZWQgYnJhbmNoLlxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG9vaygpO1xuICAgICAgICB9KTtcbiAgICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xuICAgIC8vIEluIGFkZGl0aW9uIHRvIHJlZ2lzdGVyaW5nIGl0IG9uIHRoZSB0YXJnZXQgaW5zdGFuY2UsIHdlIHdhbGsgdXAgdGhlIHBhcmVudFxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXG4gICAgLy8gVGhpcyBhdm9pZHMgdGhlIG5lZWQgdG8gd2FsayB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlIHdoZW4gaW52b2tpbmcgdGhlc2VcbiAgICAvLyBob29rcywgYW5kIG1vcmUgaW1wb3J0YW50bHksIGF2b2lkcyB0aGUgbmVlZCB0byB0cmFjayBjaGlsZCBjb21wb25lbnRzIGluXG4gICAgLy8gYXJyYXlzLlxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcbiAgICAvLyB0aGUgd3JhcHBlZCB2ZXJzaW9uLlxuICAgIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayh0eXBlLCBob29rLCBrZWVwQWxpdmVSb290LCB0cnVlIC8qIHByZXBlbmQgKi8pO1xuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgICB9LCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcbiAgICAvLyBiaXR3aXNlIG9wZXJhdGlvbnMgdG8gcmVtb3ZlIGtlZXAgYWxpdmUgZmxhZ3NcbiAgICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLztcbiAgICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgICAgICAvLyBjYWNoZSB0aGUgZXJyb3IgaGFuZGxpbmcgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWUgaG9va1xuICAgICAgICAvLyBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2VoXCIgc3RhbmRzIGZvciBcIndpdGggZXJyb3JcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cbiAgICAgICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8XG4gICAgICAgICAgICAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGNhbiBwb3RlbnRpYWxseSBiZSBjYWxsZWQgaW5zaWRlIGVmZmVjdHMuXG4gICAgICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGhvb2sgZG9lcyBub3Qgc3luY2hyb25vdXNseSB0cmlnZ2VyIG90aGVyIGhvb2tzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIGZhbHNlIHdoZW4gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgcmVhbGx5IGZ1bmt5LlxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3NbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgJycpKTtcbiAgICAgICAgd2FybihgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXG4gICAgICAgICAgICBgTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgK1xuICAgICAgICAgICAgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxuICAgICAgICAgICAgICAgICkpO1xuICAgIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiBcbi8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxuKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIgLyogTGlmZWN5Y2xlSG9va3MuU0VSVkVSX1BSRUZFVENIICovKSAmJlxuICAgIGluamVjdEhvb2sobGlmZWN5Y2xlLCAoLi4uYXJncykgPT4gaG9vayguLi5hcmdzKSwgdGFyZ2V0KTtcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfTU9VTlQgKi8pO1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIiAvKiBMaWZlY3ljbGVIb29rcy5NT1VOVEVEICovKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcImJ1XCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX1VQREFURSAqLyk7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiIC8qIExpZmVjeWNsZUhvb2tzLlVQREFURUQgKi8pO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcImJ1bVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VTk1PVU5UICovKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIgLyogTGlmZWN5Y2xlSG9va3MuVU5NT1VOVEVEICovKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBMaWZlY3ljbGVIb29rcy5TRVJWRVJfUFJFRkVUQ0ggKi8pO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIgLyogTGlmZWN5Y2xlSG9va3MuUkVOREVSX1RSSUdHRVJFRCAqLyk7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIgLyogTGlmZWN5Y2xlSG9va3MuUkVOREVSX1RSQUNLRUQgKi8pO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICAgIGluamVjdEhvb2soXCJlY1wiIC8qIExpZmVjeWNsZUhvb2tzLkVSUk9SX0NBUFRVUkVEICovLCBob29rLCB0YXJnZXQpO1xufVxuXG4vKipcblJ1bnRpbWUgaGVscGVyIGZvciBhcHBseWluZyBkaXJlY3RpdmVzIHRvIGEgdm5vZGUuIEV4YW1wbGUgdXNhZ2U6XG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcbmNvbnN0IGZvbyA9IHJlc29sdmVEaXJlY3RpdmUoJ2ZvbycpXG5jb25zdCBiYXIgPSByZXNvbHZlRGlyZWN0aXZlKCdiYXInKVxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xuICBbZm9vLCB0aGlzLnhdLFxuICBbYmFyLCB0aGlzLnldXG5dKVxuKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gICAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogJyArIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXG4gKi9cbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybihgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEV4cG9zZVByb3h5KGludGVybmFsSW5zdGFuY2UpIHx8XG4gICAgICAgIGludGVybmFsSW5zdGFuY2UucHJveHk7XG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcbiAgICAgICAgICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGRpcixcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXIuZGVlcCkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XG4gICAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgIGlmIChvbGRCaW5kaW5ncykge1xuICAgICAgICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgICAgIGlmIChob29rKSB7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGNhbiBwb3RlbnRpYWxseSBiZSBjYWxsZWQgaW5zaWRlIGVmZmVjdHMuXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCAvKiBFcnJvckNvZGVzLkRJUkVDVElWRV9IT09LICovLCBbXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwsXG4gICAgICAgICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgICBwcmV2Vk5vZGVcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBDT01QT05FTlRTID0gJ2NvbXBvbmVudHMnO1xuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcbn1cbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBpbnZhbGlkIHR5cGVzIHdpbGwgZmFsbHRocm91Z2ggdG8gY3JlYXRlVk5vZGUgYW5kIHJhaXNlIHdhcm5pbmdcbiAgICAgICAgcmV0dXJuIChjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgICAgICAvLyBleHBsaWNpdCBzZWxmIG5hbWUgaGFzIGhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGZhbHNlIC8qIGRvIG5vdCBpbmNsdWRlIGluZmVycmVkIG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgZXhpc3RpbmcgY29kZSAqLyk7XG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcbiAgICAgICAgICAgICAgICAoc2VsZk5hbWUgPT09IG5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IFxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fFxuICAgICAgICAgICAgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcbiAgICAgICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZVxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UU1xuICAgICAgICAgICAgICAgID8gYFxcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gYCArXG4gICAgICAgICAgICAgICAgICAgIGBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gXG4gICAgICAgICAgICAgICAgOiBgYDtcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGAgK1xuICAgICAgICAgICAgYGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XG4gICAgcmV0dXJuIChyZWdpc3RyeSAmJlxuICAgICAgICAocmVnaXN0cnlbbmFtZV0gfHxcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fFxuICAgICAgICAgICAgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKSk7XG59XG5cbi8qKlxuICogQWN0dWFsIGltcGxlbWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcbiAgICBsZXQgcmV0O1xuICAgIGNvbnN0IGNhY2hlZCA9IChjYWNoZSAmJiBjYWNoZVtpbmRleF0pO1xuICAgIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2VbaV0sIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XG4gICAgICAgICAgICB3YXJuKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgICAgIHJldCA9IEFycmF5LmZyb20oc291cmNlLCAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgIH1cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciBjcmVhdGluZyBkeW5hbWljIHNsb3RzIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XG4gICAgICAgIC8vIGFycmF5IG9mIGR5bmFtaWMgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgI1suLi5dPlxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2xvdCkge1xuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cbiAgICAgICAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmtleVxuICAgICAgICAgICAgICAgID8gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gc2xvdC5mbiguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0YWNoIGJyYW5jaCBrZXkgc28gZWFjaCBjb25kaXRpb25hbCBicmFuY2ggaXMgY29uc2lkZXJlZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmtleSA9IHNsb3Qua2V5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHNsb3QuZm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3RzO1xufVxuXG4vKipcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgYDxzbG90Lz5gXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBcbi8vIHRoaXMgaXMgbm90IGEgdXNlci1mYWNpbmcgZnVuY3Rpb24sIHNvIHRoZSBmYWxsYmFjayBpcyBhbHdheXMgZ2VuZXJhdGVkIGJ5XG4vLyB0aGUgY29tcGlsZXIgYW5kIGd1YXJhbnRlZWQgdG8gYmUgYSBmdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXlcbmZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmlzQ0UgfHxcbiAgICAgICAgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiZcbiAgICAgICAgICAgIGlzQXN5bmNXcmFwcGVyKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQpICYmXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmlzQ0UpKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSAnZGVmYXVsdCcpXG4gICAgICAgICAgICBwcm9wcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKCdzbG90JywgcHJvcHMsIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgd2FybihgU1NSLW9wdGltaXplZCBzbG90IGZ1bmN0aW9uIGRldGVjdGVkIGluIGEgbm9uLVNTUi1vcHRpbWl6ZWQgcmVuZGVyIGAgK1xuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xuICAgICAgICAgICAgYHBhcmVudCB0ZW1wbGF0ZS5gKTtcbiAgICAgICAgc2xvdCA9ICgpID0+IFtdO1xuICAgIH1cbiAgICAvLyBhIGNvbXBpbGVkIHNsb3QgZGlzYWJsZXMgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdCB0byBhdm9pZCBtYW51YWxcbiAgICAvLyBpbnZvY2F0aW9uIGludGVyZmVyaW5nIHdpdGggdGVtcGxhdGUtYmFzZWQgYmxvY2sgdHJhY2tpbmcsIGJ1dCBpblxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXG4gICAgLy8gZW5hYmxlIGl0LlxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICAgICAgc2xvdC5fZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvcGVuQmxvY2soKTtcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcbiAgICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKEZyYWdtZW50LCB7XG4gICAgICAgIGtleTogcHJvcHMua2V5IHx8XG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgYXJyYXkgb2YgYSBkeW5hbWljIGNvbmRpdGlvbmFsIHNsb3QgbWF5IGhhdmUgYSBicmFuY2hcbiAgICAgICAgICAgIC8vIGtleSBhdHRhY2hlZCBpbiB0aGUgYGNyZWF0ZVNsb3RzYCBoZWxwZXIsIHJlc3BlY3QgdGhhdFxuICAgICAgICAgICAgKHZhbGlkU2xvdENvbnRlbnQgJiYgdmFsaWRTbG90Q29udGVudC5rZXkpIHx8XG4gICAgICAgICAgICBgXyR7bmFtZX1gXG4gICAgfSwgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLCB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgLyogU2xvdEZsYWdzLlNUQUJMRSAqL1xuICAgICAgICA/IDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovXG4gICAgICAgIDogLTIgLyogUGF0Y2hGbGFncy5CQUlMICovKTtcbiAgICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XG4gICAgICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgJy1zJ107XG4gICAgfVxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICAgICAgc2xvdC5fZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXG4gICAgICAgICAgICAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pXG4gICAgICAgID8gdm5vZGVzXG4gICAgICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHdhcm4oYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldFtwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSAmJiAvW0EtWl0vLnRlc3Qoa2V5KVxuICAgICAgICAgICAgPyBgb246JHtrZXl9YFxuICAgICAgICAgICAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiAjMjQzNyBJbiBWdWUgMywgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGEgcHVibGljIGluc3RhbmNlIHByb3h5IGJ1dFxuICogdGhleSBleGlzdCBpbiB0aGUgaW50ZXJuYWwgcGFyZW50IGNoYWluLiBGb3IgY29kZSB0aGF0IHJlbGllcyBvbiB0cmF2ZXJzaW5nXG4gKiBwdWJsaWMgJHBhcmVudCBjaGFpbnMsIHNraXAgZnVuY3Rpb25hbCBvbmVzIGFuZCBnbyB0byB0aGUgcGFyZW50IGluc3RlYWQuXG4gKi9cbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcbiAgICBpZiAoIWkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKVxuICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkoaSkgfHwgaS5wcm94eTtcbiAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xufTtcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSBcbi8vIE1vdmUgUFVSRSBtYXJrZXIgdG8gbmV3IGxpbmUgdG8gd29ya2Fyb3VuZCBjb21waWxlciBkaXNjYXJkaW5nIGl0XG4vLyBkdWUgdG8gdHlwZSBhbm5vdGF0aW9uXG4vKiNfX1BVUkVfXyovIGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogaSA9PiBpLFxuICAgICRlbDogaSA9PiBpLnZub2RlLmVsLFxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMpLFxuICAgICRhdHRyczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyksXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcbiAgICAkcmVmczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMpLFxuICAgICRwYXJlbnQ6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXG4gICAgJGVtaXQ6IGkgPT4gaS5lbWl0LFxuICAgICRvcHRpb25zOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUpLFxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXG4gICAgJG5leHRUaWNrOiBpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXG4gICAgJHdhdGNoOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUClcbn0pO1xuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gJ18nIHx8IGtleSA9PT0gJyQnO1xuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBFTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc3RhdGUsIGtleSk7XG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XG4gICAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgZm9ybWF0dGVycyB0byBrbm93IHRoYXQgdGhpcyBpcyBhIFZ1ZSBpbnN0YW5jZVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSA9PT0gJ19faXNWdWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkYXRhIC8gcHJvcHMgLyBjdHhcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcbiAgICAgICAgLy8gZHVyaW5nIHJlbmRlciBhbmQgaXMgYSBtYWpvciBob3RzcG90LiBUaGUgbW9zdCBleHBlbnNpdmUgcGFydCBvZiB0aGlzXG4gICAgICAgIC8vIGlzIHRoZSBtdWx0aXBsZSBoYXNPd24oKSBjYWxscy4gSXQncyBtdWNoIGZhc3RlciB0byBkbyBhIHNpbXBsZSBwcm9wZXJ0eVxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxuICAgICAgICAvLyBwcm90b3R5cGUpIHRvIG1lbW9pemUgd2hhdCBhY2Nlc3MgdHlwZSBhIGtleSBjb3JyZXNwb25kcyB0by5cbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcbiAgICAgICAgICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIEFjY2Vzc1R5cGVzLlNFVFVQICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIEFjY2Vzc1R5cGVzLkRBVEEgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQgLyogQWNjZXNzVHlwZXMuQ09OVEVYVCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIEFjY2Vzc1R5cGVzLlBST1BTICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIEFjY2Vzc1R5cGVzLlNFVFVQICovO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBBY2Nlc3NUeXBlcy5EQVRBICovO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXG4gICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiZcbiAgICAgICAgICAgICAgICBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogQWNjZXNzVHlwZXMuUFJPUFMgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQWNjZXNzVHlwZXMuQ09OVEVYVCAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIEFjY2Vzc1R5cGVzLk9USEVSICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcbiAgICAgICAgLy8gcHVibGljICR4eHggcHJvcGVydGllc1xuICAgICAgICBpZiAocHVibGljR2V0dGVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sIGtleSk7XG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxuICAgICAgICAgICAgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgICAgICAvLyB1c2VyIG1heSBzZXQgY3VzdG9tIHByb3BlcnRpZXMgdG8gYHRoaXNgIHRoYXQgc3RhcnQgd2l0aCBgJGBcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIEFjY2Vzc1R5cGVzLkNPTlRFWFQgKi87XG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICAgICgoZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpLFxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxuICAgICAgICAgICAgKCFpc1N0cmluZyhrZXkpIHx8XG4gICAgICAgICAgICAgICAgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcbiAgICAgICAgICAgICAgICBrZXkuaW5kZXhPZignX192JykgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGAgK1xuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiZcbiAgICAgICAgICAgIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHsgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfSB9LCBrZXkpIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICAgICAgcmV0dXJuICghIWFjY2Vzc0NhY2hlW2tleV0gfHxcbiAgICAgICAgICAgIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHx8XG4gICAgICAgICAgICBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fFxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHx8XG4gICAgICAgICAgICBoYXNPd24oY3R4LCBrZXkpIHx8XG4gICAgICAgICAgICBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fFxuICAgICAgICAgICAgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSkpO1xuICAgIH0sXG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGludmFsaWRhdGUga2V5IGNhY2hlIG9mIGEgZ2V0dGVyIGJhc2VkIHByb3BlcnR5ICM1NDE3XG4gICAgICAgICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNPd24oZGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufTtcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlKSB7XG4gICAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgICAgIHdhcm4oYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBgICtcbiAgICAgICAgICAgIGBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gKTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgIH07XG59XG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdW5zY29wYWJsZXMgd2hlbiB1c2luZyBgd2l0aGAgYmxvY2tcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XG4gICAgfSxcbiAgICBoYXMoXywga2V5KSB7XG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzO1xuICAgIH1cbn0pO1xuLy8gZGV2IG9ubHlcbi8vIEluIGRldiBtb2RlLCB0aGUgcHJveHkgdGFyZ2V0IGV4cG9zZXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBzZWVuIG9uIGB0aGlzYFxuLy8gZm9yIGVhc2llciBjb25zb2xlIGluc3BlY3Rpb24uIEluIHByb2QgbW9kZSBpdCB3aWxsIGJlIGFuIGVtcHR5IG9iamVjdCBzb1xuLy8gdGhlc2UgcHJvcGVydGllcyBkZWZpbml0aW9ucyBjYW4gYmUgc2tpcHBlZC5cbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICAvLyBleHBvc2UgaW50ZXJuYWwgaW5zdGFuY2UgZm9yIHByb3h5IGhhbmRsZXJzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2VcbiAgICB9KTtcbiAgICAvLyBleHBvc2UgcHVibGljIHByb3BlcnRpZXNcbiAgICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXG4gICAgICAgICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXG4gICAgICAgICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xuICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vLyBkZXYgb25seVxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7IGN0eCwgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBkZXYgb25seVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cbiAgICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICAgIC8vIGNhbGwgYmVmb3JlQ3JlYXRlIGZpcnN0IGJlZm9yZSBhY2Nlc3Npbmcgb3RoZXIgb3B0aW9ucyBzaW5jZVxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9DUkVBVEUgKi8pO1xuICAgIH1cbiAgICBjb25zdCB7IFxuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsIGJlZm9yZU1vdW50LCBtb3VudGVkLCBiZWZvcmVVcGRhdGUsIHVwZGF0ZWQsIGFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVubW91bnQsIGRlc3Ryb3llZCwgdW5tb3VudGVkLCByZW5kZXIsIHJlbmRlclRyYWNrZWQsIHJlbmRlclRyaWdnZXJlZCwgZXJyb3JDYXB0dXJlZCwgc2VydmVyUHJlZmV0Y2gsIFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsIGluaGVyaXRBdHRycywgXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogT3B0aW9uVHlwZXMuUFJPUFMgKi8sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3B0aW9ucyBpbml0aWFsaXphdGlvbiBvcmRlciAodG8gYmUgY29uc2lzdGVudCB3aXRoIFZ1ZSAyKTpcbiAgICAvLyAtIHByb3BzIChhbHJlYWR5IGRvbmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uKVxuICAgIC8vIC0gaW5qZWN0XG4gICAgLy8gLSBtZXRob2RzXG4gICAgLy8gLSBkYXRhIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcbiAgICAvLyAtIGNvbXB1dGVkXG4gICAgLy8gLSB3YXRjaCAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXG4gICAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnVud3JhcEluamVjdGVkUmVmKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gZGV2IG1vZGUsIHdlIHVzZSB0aGUgYGNyZWF0ZVJlbmRlckNvbnRleHRgIGZ1bmN0aW9uIHRvIGRlZmluZVxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgdG8gdGhlIHByb3h5IHRhcmdldCwgYW5kIHRob3NlIGFyZSByZWFkLW9ubHkgYnV0XG4gICAgICAgICAgICAgICAgLy8gcmVjb25maWd1cmFibGUsIHNvIGl0IG5lZWRzIHRvIGJlIHJlZGVmaW5lZCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogT3B0aW9uVHlwZXMuTUVUSE9EUyAqLywga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGFPcHRpb25zKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XG4gICAgICAgICAgICB3YXJuKGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBgICtcbiAgICAgICAgICAgICAgICBgUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICAgICAgICB3YXJuKGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgYCArXG4gICAgICAgICAgICAgICAgYGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYCArXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogT3B0aW9uVHlwZXMuREFUQSAqLywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlIGRhdGEgb24gY3R4IGR1cmluZyBkZXZcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3RhdGUgaW5pdGlhbGl6YXRpb24gY29tcGxldGUgYXQgdGhpcyBwb2ludCAtIHN0YXJ0IGNhY2hpbmcgYWNjZXNzXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuICAgIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KVxuICAgICAgICAgICAgICAgID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcbiAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ob3B0LmdldClcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBnZXQgPT09IE5PT1ApIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldClcbiAgICAgICAgICAgICAgICA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKVxuICAgICAgICAgICAgICAgIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XG4gICAgICAgICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xuICAgICAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgICAgICBzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxuICAgICAgICAgICAgICAgIHNldDogdiA9PiAoYy52YWx1ZSA9IHYpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIE9wdGlvblR5cGVzLkNPTVBVVEVEICovLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3YXRjaE9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucylcbiAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKVxuICAgICAgICAgICAgOiBwcm92aWRlT3B0aW9ucztcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIgLyogTGlmZWN5Y2xlSG9va3MuQ1JFQVRFRCAqLyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgICAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgICAgICAgaG9vay5mb3JFYWNoKF9ob29rID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChob29rKSB7XG4gICAgICAgICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcbiAgICBpZiAoaXNBcnJheShleHBvc2UpKSB7XG4gICAgICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcbiAgICAgICAgICAgIGV4cG9zZS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2YWwgPT4gKHB1YmxpY1RoaXNba2V5XSA9IHZhbClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIHdoZW4gY3JlYXRpbmcgdGhlIGluc3RhbmNlIGJ1dCBhbHNvIG5lZWQgdG8gYmVcbiAgICAvLyBhcHBsaWVkIGZyb20gbWl4aW5zXG4gICAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICAgIH1cbiAgICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcbiAgICAgICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xuICAgIH1cbiAgICAvLyBhc3NldCBvcHRpb25zLlxuICAgIGlmIChjb21wb25lbnRzKVxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICBpZiAoZGlyZWN0aXZlcylcbiAgICAgICAgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1AsIHVud3JhcFJlZiA9IGZhbHNlKSB7XG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgICAgIGxldCBpbmplY3RlZDtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gb3B0KSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0LmZyb20gfHwga2V5LCBvcHQuZGVmYXVsdCwgdHJ1ZSAvKiB0cmVhdCBkZWZhdWx0IGZ1bmN0aW9uIGFzIGZhY3RvcnkgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVmKGluamVjdGVkKSkge1xuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhlIGNoZWNrIGluIDMuM1xuICAgICAgICAgICAgaWYgKHVud3JhcFJlZikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHNldDogdiA9PiAoaW5qZWN0ZWQudmFsdWUgPSB2KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBpbmplY3RlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGEgcmVmIGFuZCB3aWxsIGJlIGF1dG8tdW53cmFwcGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGFuZCBubyBsb25nZXIgbmVlZHMgXFxgLnZhbHVlXFxgIGluIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFRvIG9wdC1pbiB0byB0aGUgbmV3IGJlaGF2aW9yIG5vdywgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgc2V0IFxcYGFwcC5jb25maWcudW53cmFwSW5qZWN0ZWRSZWYgPSB0cnVlXFxgICh0aGlzIGNvbmZpZyBpcyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0ZW1wb3JhcnkgYW5kIHdpbGwgbm90IGJlIG5lZWRlZCBpbiB0aGUgZnV0dXJlLilgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogT3B0aW9uVHlwZXMuSU5KRUNUICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhpc0FycmF5KGhvb2spXG4gICAgICAgID8gaG9vay5tYXAoaCA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKVxuICAgICAgICA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksIGluc3RhbmNlLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xuICAgIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcygnLicpXG4gICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xuICAgIGlmIChpc1N0cmluZyhyYXcpKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoKHIgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpXG4gICAgICAgICAgICAgICAgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpXG4gICAgICAgICAgICAgICAgOiBjdHhbcmF3LmhhbmRsZXJdO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICAgIH1cbn1cbi8qKlxuICogUmVzb2x2ZSBtZXJnZWQgb3B0aW9ucyBhbmQgY2FjaGUgaXQgb24gdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgaXMgZG9uZSBvbmx5IG9uY2UgcGVyLWNvbXBvbmVudCBzaW5jZSB0aGUgbWVyZ2luZyBkb2VzIG5vdCBpbnZvbHZlXG4gKiBpbnN0YW5jZXMuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICAgIGNvbnN0IHsgbWl4aW5zOiBnbG9iYWxNaXhpbnMsIG9wdGlvbnNDYWNoZTogY2FjaGUsIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfSB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gICAgbGV0IHJlc29sdmVkO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB7fTtcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKG0gPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChiYXNlKSkge1xuICAgICAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xuICAgIGlmIChleHRlbmRzT3B0aW9ucykge1xuICAgICAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xuICAgIH1cbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICAgIG1peGlucy5mb3JFYWNoKChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICAgIGlmIChhc01peGluICYmIGtleSA9PT0gJ2V4cG9zZScpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHdhcm4oYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgKHN0cmF0cyAmJiBzdHJhdHNba2V5XSk7XG4gICAgICAgICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XG4gICAgZGF0YTogbWVyZ2VEYXRhRm4sXG4gICAgcHJvcHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICBlbWl0czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIC8vIG9iamVjdHNcbiAgICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXG4gICAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gICAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXG4gICAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXG4gICAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXG4gICAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gICAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gICAgZGVhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gICAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcbiAgICAvLyBhc3NldHNcbiAgICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIC8vIHdhdGNoXG4gICAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAgIC8vIHByb3ZpZGUgLyBpbmplY3RcbiAgICBwcm92aWRlOiBtZXJnZURhdGFGbixcbiAgICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgICBpZiAoIWZyb20pIHtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBpZiAoIXRvKSB7XG4gICAgICAgIHJldHVybiBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgICByZXR1cm4gKGV4dGVuZCkoaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XG4gICAgcmV0dXJuIHRvID8gZXh0ZW5kKGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byksIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gICAgaWYgKCF0bylcbiAgICAgICAgcmV0dXJuIGZyb207XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gdG87XG4gICAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIC8vIHJlc3VsdCBvZiBiaXR3aXNlIGZsYWcgY29tcGFyaXNvblxuaXNTU1IgPSBmYWxzZSkge1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBkZWYoYXR0cnMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcbiAgICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xuICAgIC8vIGVuc3VyZSBhbGwgZGVjbGFyZWQgcHJvcCBrZXlzIGFyZSBwcmVzZW50XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdmFsaWRhdGlvblxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKGlzU3RhdGVmdWwpIHtcbiAgICAgICAgLy8gc3RhdGVmdWxcbiAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBvcHRpb25hbCBwcm9wcywgcHJvcHMgPT09IGF0dHJzXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBkZWNsYXJlZCBwcm9wc1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xufVxuZnVuY3Rpb24gaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUuX19obXJJZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XG4gICAgY29uc3QgeyBwcm9wcywgYXR0cnMsIHZub2RlOiB7IHBhdGNoRmxhZyB9IH0gPSBpbnN0YW5jZTtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgW29wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XG4gICAgISgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpKSAmJlxuICAgICAgICAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmXG4gICAgICAgICEocGF0Y2hGbGFnICYgMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovKSkge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQYXRjaEZsYWdzLlBST1BTICovKSB7XG4gICAgICAgICAgICAvLyBDb21waWxlci1nZW5lcmF0ZWQgcHJvcHMgJiBubyBrZXlzIGNoYW5nZSwganVzdCBzZXQgdGhlIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIHRoZSBwcm9wcy5cbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHRoZSBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQUk9QUyBmbGFnIGd1YXJhbnRlZXMgcmF3UHJvcHMgdG8gYmUgbm9uLW51bGxcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ciAvIHByb3BzIHNlcGFyYXRpb24gd2FzIGRvbmUgb24gaW5pdCBhbmQgd2lsbCBiZSBjb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY29kZSBwYXRoLCBzbyBqdXN0IGNoZWNrIGlmIGF0dHJzIGhhdmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywgY2FtZWxpemVkS2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGZhbHNlIC8qIGlzQWJzZW50ICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmdWxsIHByb3BzIHVwZGF0ZS5cbiAgICAgICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBvZiBkeW5hbWljIHByb3BzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSBrZXlzIGZyb21cbiAgICAgICAgLy8gdGhlIHByb3BzIG9iamVjdFxuICAgICAgICBsZXQga2ViYWJLZXk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fFxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAgICAgICAoIWhhc093bihyYXdQcm9wcywga2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoZSBvcmlnaW5hbCBwcm9wcyB3YXMgcGFzc2VkIGluIGFzIGtlYmFiLWNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAgICAgICAgICAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgdW5kZWZpbmVkLCBpbnN0YW5jZSwgdHJ1ZSAvKiBpc0Fic2VudCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBmdW5jdGlvbmFsIGNvbXBvbmVudCB3L28gcHJvcHMgZGVjbGFyYXRpb24sIHByb3BzIGFuZFxuICAgICAgICAvLyBhdHRycyBwb2ludCB0byB0aGUgc2FtZSBvYmplY3Qgc28gaXQgc2hvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIHVwZGF0ZWQuXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghZmFsc2UgKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgdXBkYXRlcyBmb3IgJGF0dHJzIGluIGNhc2UgaXQncyB1c2VkIGluIGNvbXBvbmVudCBzbG90c1xuICAgIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sICckYXR0cnMnKTtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICAgIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgICBpZiAocmF3UHJvcHMpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICAgICAgICAvLyBrZXksIHJlZiBhcmUgcmVzZXJ2ZWQgYW5kIG5ldmVyIHBhc3NlZCBkb3duXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cbiAgICAgICAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAoY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChyYXdDYXN0VmFsdWVzIHx8IChyYXdDYXN0VmFsdWVzID0ge30pKVtjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICAgICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgY2FzdFZhbHVlc1trZXldLCBpbnN0YW5jZSwgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgJ2RlZmF1bHQnKTtcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICAgICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChudWxsLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gICAgICAgIGlmIChvcHRbMCAvKiBCb29sZWFuRmxhZ3Muc2hvdWxkQ2FzdCAqL10pIHtcbiAgICAgICAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBCb29sZWFuRmxhZ3Muc2hvdWxkQ2FzdFRydWUgKi9dICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQucHJvcHNDYWNoZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcpID0+IHtcbiAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcbiAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICAgICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRU1QVFlfQVJSO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgICAgICAgICAgd2FybihgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyYXcpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gKG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPVxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IE9iamVjdC5hc3NpZ24oe30sIG9wdCkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BbMCAvKiBCb29sZWFuRmxhZ3Muc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFsxIC8qIEJvb2xlYW5GbGFncy5zaG91bGRDYXN0VHJ1ZSAqL10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBuZWVkcyBib29sZWFuIGNhc3Rpbmcgb3IgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEgfHwgaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXG4vLyBzbyB0aGF0IGl0IHdvcmtzIGFjcm9zcyB2bXMgLyBpZnJhbWVzLlxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccyooZnVuY3Rpb258Y2xhc3MpIChcXHcrKS8pO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzJdIDogY3RvciA9PT0gbnVsbCA/ICdudWxsJyA6ICcnO1xufVxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZFR5cGVzLmZpbmRJbmRleCh0ID0+IGlzU2FtZVR5cGUodCwgdHlwZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgICAgICBpZiAob3B0ID09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFsaWRhdGVQcm9wKGtleSwgcmVzb2x2ZWRWYWx1ZXNba2V5XSwgb3B0LCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmICFoYXNPd24ocmF3UHJvcHMsIGh5cGhlbmF0ZShrZXkpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIGlzQWJzZW50KSB7XG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xuICAgIC8vIHJlcXVpcmVkIVxuICAgIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdHlwZSBjaGVja1xuICAgIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSkge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY3VzdG9tIHZhbGlkYXRvclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xuICAgIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnQnKTtcbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgIGxldCB2YWxpZDtcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICAgIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICAgICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnbnVsbCcpIHtcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZCxcbiAgICAgICAgZXhwZWN0ZWRUeXBlXG4gICAgfTtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcbiAgICAgICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJyB8ICcpfWA7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgICB9XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3Muc29tZShlbGVtID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gJ18nIHx8IGtleSA9PT0gJyRzdGFibGUnO1xuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKVxuICAgID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKVxuICAgIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gICAgaWYgKHJhd1Nsb3QuX24pIHtcbiAgICAgICAgLy8gYWxyZWFkeSBub3JtYWxpemVkIC0gIzUzNTNcbiAgICAgICAgcmV0dXJuIHJhd1Nsb3Q7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICB3YXJuKGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IGAgK1xuICAgICAgICAgICAgICAgIGB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBgICtcbiAgICAgICAgICAgICAgICBgSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcbiAgICB9LCBjdHgpO1xuICAgIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xuICAgICAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiZcbiAgICAgICAgIShmYWxzZSApKSB7XG4gICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcbiAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XG4gICAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICAgIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgLy8gdXNlcnMgY2FuIGdldCB0aGUgc2hhbGxvdyByZWFkb25seSB2ZXJzaW9uIG9mIHRoZSBzbG90cyBvYmplY3QgdGhyb3VnaCBgdGhpcy4kc2xvdHNgLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGF2b2lkIHRoZSBwcm94eSBvYmplY3QgcG9sbHV0aW5nIHRoZSBzbG90cyBvZiB0aGUgaW50ZXJuYWwgaW5zdGFuY2VcbiAgICAgICAgICAgIGluc3RhbmNlLnNsb3RzID0gdG9SYXcoY2hpbGRyZW4pO1xuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAgIGRlZihjaGlsZHJlbiwgJ18nLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCAoaW5zdGFuY2Uuc2xvdHMgPSB7fSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9O1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWYoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICAgIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBjb21waWxlZCBzbG90cy5cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIFBhcmVudCB3YXMgSE1SIHVwZGF0ZWQgc28gc2xvdCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHNsb3RzIGFuZCBtYXJrIGluc3RhbmNlIGZvciBobXIgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU2xvdEZsYWdzLlNUQUJMRSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIEFORCBzdGFibGUuXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUsIGFuZCBza2lwIHN0YWxlIHNsb3RzIHJlbW92YWwuXG4gICAgICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIGJ1dCBkeW5hbWljICh2LWlmL3YtZm9yIG9uIHNsb3RzKSAtIHVwZGF0ZSBzbG90cywgYnV0IHNraXBcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIC8vICMyODkzXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgdGhlIG9wdGltaXplZCBzbG90cyBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgYHNsb3RzLl9gIGZsYWcgaWYgbmVjZXNzYXJ5IHRvIG1ha2Ugc3Vic2VxdWVudCB1cGRhdGVzIHJlbGlhYmxlLFxuICAgICAgICAgICAgICAgIC8vIGkuZS4gbGV0IHRoZSBgcmVuZGVyU2xvdGAgY3JlYXRlIHRoZSBiYWlsZWQgRnJhZ21lbnRcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzLl87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIG5vbiBzbG90IG9iamVjdCBjaGlsZHJlbiAoZGlyZWN0IHZhbHVlKSBwYXNzZWQgdG8gYSBjb21wb25lbnRcbiAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgICB9XG4gICAgLy8gZGVsZXRlIHN0YWxlIHNsb3RzXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiAhKGtleSBpbiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFwcDogbnVsbCxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICBpc05hdGl2ZVRhZzogTk8sXG4gICAgICAgICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICAgICAgICBlcnJvckhhbmRsZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHdhcm5IYW5kbGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIG1peGluczogW10sXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxuICAgICAgICBkaXJlY3RpdmVzOiB7fSxcbiAgICAgICAgcHJvdmlkZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIG9wdGlvbnNDYWNoZTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgcHJvcHNDYWNoZTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgZW1pdHNDYWNoZTogbmV3IFdlYWtNYXAoKVxuICAgIH07XG59XG5sZXQgdWlkJDEgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJvb3RDb21wb25lbnQgPSBPYmplY3QuYXNzaWduKHt9LCByb290Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICAgICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XG4gICAgICAgICAgICBfdWlkOiB1aWQkMSsrLFxuICAgICAgICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGZ1bmN0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1peGluKG1peGluKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogJycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgaXNTVkcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAjNTU3MVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgSWYgeW91IHdhbnQgdG8gbW91bnQgYW5vdGhlciBhcHAgb24gdGhlIHNhbWUgaG9zdCBjb250YWluZXIsYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBzZXQgb24gdGhlIHJvb3QgaW5zdGFuY2Ugb24gaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bm1vdW50KCkge1xuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBmb3IgaGFuZGxpbmcgYSB0ZW1wbGF0ZSByZWZcbiAqL1xuZnVuY3Rpb24gc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xuICAgICAgICByYXdSZWYuZm9yRWFjaCgociwgaSkgPT4gc2V0UmVmKHIsIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcbiAgICAgICAgLy8gd2hlbiBtb3VudGluZyBhc3luYyBjb21wb25lbnRzLCBub3RoaW5nIG5lZWRzIHRvIGJlIGRvbmUsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHRlbXBsYXRlIHJlZiBpcyBmb3J3YXJkZWQgdG8gaW5uZXIgY29tcG9uZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovXG4gICAgICAgID8gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHlcbiAgICAgICAgOiB2bm9kZS5lbDtcbiAgICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFvd25lcikge1xuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xuICAgICAgICAgICAgYEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcbiAgICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gKG93bmVyLnJlZnMgPSB7fSkgOiBvd25lci5yZWZzO1xuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xuICAgIC8vIGR5bmFtaWMgcmVmIGNoYW5nZWQuIHVuc2V0IG9sZCByZWZcbiAgICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgICAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIG9sZFJlZikpIHtcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcbiAgICAgICAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIgLyogRXJyb3JDb2Rlcy5GVU5DVElPTl9SRUYgKi8sIFt2YWx1ZSwgcmVmc10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcbiAgICAgICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcbiAgICAgICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0dXBTdGF0ZVtyZWZdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZWZzW3JlZl1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb1NldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09ICdmb3JlaWduT2JqZWN0JztcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIERPTU5vZGVUeXBlcy5DT01NRU5UICovO1xuLy8gTm90ZTogaHlkcmF0aW9uIGlzIERPTS1zcGVjaWZpY1xuLy8gQnV0IHdlIGhhdmUgdG8gcGxhY2UgaXQgaW4gY29yZSBkdWUgdG8gdGlnaHQgY291cGxpbmcgd2l0aCBjb3JlIC0gc3BsaXR0aW5nXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxuLy8gSHlkcmF0aW9uIGFsc28gZGVwZW5kcyBvbiBzb21lIHJlbmRlcmVyIGludGVybmFsIGxvZ2ljIHdoaWNoIG5lZWRzIHRvIGJlXG4vLyBwYXNzZWQgaW4gdmlhIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICAgIGNvbnN0IHsgbXQ6IG1vdW50Q29tcG9uZW50LCBwOiBwYXRjaCwgbzogeyBwYXRjaFByb3AsIGNyZWF0ZVRleHQsIG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCByZW1vdmUsIGluc2VydCwgY3JlYXRlQ29tbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcbiAgICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYCk7XG4gICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgIWZhbHNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJztcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnRTdGFydCk7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgdm5vZGUuZWwgPSBub2RlO1xuICAgICAgICBpZiAocGF0Y2hGbGFnID09PSAtMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi8pIHtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBET01Ob2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyAjNTcyOCBlbXB0eSB0ZXh0IG5vZGUgaW5zaWRlIGEgc2xvdCBjYW4gY2F1c2UgaHlkcmF0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgd29uJ3QgY29udGFpbiBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQoKHZub2RlLmVsID0gY3JlYXRlVGV4dCgnJykpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogRE9NTm9kZVR5cGVzLkNPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZSB0ZW1wbGF0ZSBpcyBzdGF0aWMgYnV0IFNTUmVkIGFzIGEgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgLyogRE9NTm9kZVR5cGVzLkVMRU1FTlQgKi8gfHwgZG9tVHlwZSA9PT0gMyAvKiBET01Ob2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRpYyB2bm9kZSBoYXMgaXRzIGNvbnRlbnQgc3RyaXBwZWQgZHVyaW5nIGJ1aWxkLFxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlLm5vZGVUeXBlID09PSAxIC8qIERPTU5vZGVUeXBlcy5FTEVNRU5UICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLm91dGVySFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIERPTU5vZGVUeXBlcy5FTEVNRU5UICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIHVwIHRoZSByZW5kZXIgZWZmZWN0LCBpZiB0aGUgaW5pdGlhbCB2bm9kZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBpdHMgc3ViLXRyZWUuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQodm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGNvbXBvbmVudCdzIHJlbmRlcmVkIG91dHB1dCB0byBkZXRlcm1pbmUgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCwgd2UgZG8gYSBsb29rYWhlYWQgdG8gZmluZCB0aGUgZW5kIGFuY2hvciBub2RlLlxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vICM0MjkzIHRlbGVwb3J0IGFzIGNvbXBvbmVudCByb290XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21tZW50KG5leHROb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUuZGF0YSA9PT0gJ3RlbGVwb3J0IGVuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICMzNzg3XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbXBvbmVudCBpcyBhc3luYywgaXQgbWF5IGdldCBtb3ZlZCAvIHVubW91bnRlZCBiZWZvcmUgaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpcyBsb2FkZWQsIHNvIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIHRoYXQgbWF0Y2hlcyBpdHMgYWRvcHRlZCBET00uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLnByZXZpb3VzU2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZSgnJykgOiBjcmVhdGVWTm9kZSgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIERPTU5vZGVUeXBlcy5DT01NRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XG4gICAgICAgIC8vICM0MDA2IGZvciBmb3JtIGVsZW1lbnRzIHdpdGggbm9uLXN0cmluZyB2LW1vZGVsIHZhbHVlIGJpbmRpbmdzXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiA6dmFsdWU9XCJvYmpcIj4sIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiA6dHJ1ZS12YWx1ZT1cIjFcIj5cbiAgICAgICAgY29uc3QgZm9yY2VQYXRjaFZhbHVlID0gKHR5cGUgPT09ICdpbnB1dCcgJiYgZGlycykgfHwgdHlwZSA9PT0gJ29wdGlvbic7XG4gICAgICAgIC8vIHNraXAgcHJvcHMgJiBjaGlsZHJlbiBpZiB0aGlzIGlzIGhvaXN0ZWQgc3RhdGljIG5vZGVzXG4gICAgICAgIC8vICM1NDA1IGluIGRldiwgYWx3YXlzIGh5ZHJhdGUgY2hpbGRyZW4gZm9yIEhNUlxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLykge1xuICAgICAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2hWYWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAhb3B0aW1pemVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmICgxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi8gfCAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGZhbHNlLCB1bmRlZmluZWQsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGNsaWNrIGxpc3RlbmVycyAod2hpY2ggaXMgbW9zdCBvZnRlbikgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW5nIHRocm91Z2ggcHJvcHMuXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwgJ29uQ2xpY2snLCBudWxsLCBwcm9wcy5vbkNsaWNrLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZub2RlIC8gZGlyZWN0aXZlIGhvb2tzXG4gICAgICAgICAgICBsZXQgdm5vZGVIb29rcztcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xuICAgICAgICAgICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xuICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLyAmJlxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICAgICAgICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFNTUmVkIERPTSBjb250YWlucyBtb3JlIG5vZGVzIHRoYW4gaXQgc2hvdWxkLiBSZW1vdmUgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDggLyogU2hhcGVGbGFncy5URVhUX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46XFxuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIFNlcnZlcjogJHt2bm9kZS5jaGlsZHJlbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xuICAgIH07XG4gICAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICAgICAgOiAoY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFRleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBTU1JlZCBET00gZGlkbid0IGNvbnRhaW4gZW5vdWdoIG5vZGVzLiBNb3VudCB0aGUgbWlzc2luZyBvbmVzLlxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXG4gICAgICAgICAgICAgICAgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKVxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSAnXScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZygodm5vZGUuYW5jaG9yID0gbmV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJhZ21lbnQgZGlkbid0IGh5ZHJhdGUgc3VjY2Vzc2Z1bGx5LCBzaW5jZSB3ZSBkaWRuJ3QgZ2V0IGEgZW5kIGFuY2hvclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cbiAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBhbmNob3IgaXMgbWlzc2luZywgd2UgbmVlZCB0byBjcmVhdGUgb25lIGFuZCBpbnNlcnQgaXRcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XG4gICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcXG4tIENsaWVudCB2bm9kZTpgLCB2bm9kZS50eXBlLCBgXFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsIG5vZGUsIG5vZGUubm9kZVR5cGUgPT09IDMgLyogRE9NTm9kZVR5cGVzLlRFWFQgKi9cbiAgICAgICAgICAgICAgICA/IGAodGV4dClgXG4gICAgICAgICAgICAgICAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWydcbiAgICAgICAgICAgICAgICAgICAgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWBcbiAgICAgICAgICAgICAgICAgICAgOiBgYCk7XG4gICAgICAgIHZub2RlLmVsID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGNlc3NpdmUgZnJhZ21lbnQgbm9kZXNcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgICAgICByZW1vdmUobm9kZSk7XG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG5leHQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gICAgY29uc3QgbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yID0gKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoID0gMDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICdbJylcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2grKztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgICAgICBwZXJmLm1hcmsoZW5kVGFnKTtcbiAgICAgICAgcGVyZi5tZWFzdXJlKGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5cbi8qKlxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXG4gKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHJlbmRlcmVyIGlzIGNyZWF0ZWQsIGluIGBiYXNlQ3JlYXRlUmVuZGVyZXJgIHNvIHRoYXRcbiAqIGltcG9ydGluZyBydW50aW1lLWNvcmUgaXMgc2lkZS1lZmZlY3RzIGZyZWUuXG4gKlxuICogaXN0YW5idWwtaWdub3JlLW5leHRcbiAqL1xuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICdib29sZWFuJykge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbXVsdGkgPSBuZWVkV2Fybi5sZW5ndGggPiAxO1xuICAgICAgICBjb25zb2xlLndhcm4oYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKCcsICcpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgYCArXG4gICAgICAgICAgICBgd2hpY2ggZXhwZWN0cyB0aGVzZSBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyB0byBiZSBnbG9iYWxseSBpbmplY3RlZCBgICtcbiAgICAgICAgICAgIGB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBgICtcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uIGJ1bmRsZS5cXG5cXG5gICtcbiAgICAgICAgICAgIGBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmApO1xuICAgIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcbiAgICA7XG4vKipcbiAqIFRoZSBjcmVhdGVSZW5kZXJlciBmdW5jdGlvbiBhY2NlcHRzIHR3byBnZW5lcmljIGFyZ3VtZW50czpcbiAqIEhvc3ROb2RlIGFuZCBIb3N0RWxlbWVudCwgY29ycmVzcG9uZGluZyB0byBOb2RlIGFuZCBFbGVtZW50IHR5cGVzIGluIHRoZVxuICogaG9zdCBlbnZpcm9ubWVudC4gRm9yIGV4YW1wbGUsIGZvciBydW50aW1lLWRvbSwgSG9zdE5vZGUgd291bGQgYmUgdGhlIERPTVxuICogYE5vZGVgIGludGVyZmFjZSBhbmQgSG9zdEVsZW1lbnQgd291bGQgYmUgdGhlIERPTSBgRWxlbWVudGAgaW50ZXJmYWNlLlxuICpcbiAqIEN1c3RvbSByZW5kZXJlcnMgY2FuIHBhc3MgaW4gdGhlIHBsYXRmb3JtIHNwZWNpZmljIHR5cGVzIGxpa2UgdGhpczpcbiAqXG4gKiBgYGAganNcbiAqIGNvbnN0IHsgcmVuZGVyLCBjcmVhdGVBcHAgfSA9IGNyZWF0ZVJlbmRlcmVyPE5vZGUsIEVsZW1lbnQ+KHtcbiAqICAgcGF0Y2hQcm9wLFxuICogICAuLi5ub2RlT3BzXG4gKiB9KVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuLy8gU2VwYXJhdGUgQVBJIGZvciBjcmVhdGluZyBoeWRyYXRpb24tZW5hYmxlZCByZW5kZXJlci5cbi8vIEh5ZHJhdGlvbiBsb2dpYyBpcyBvbmx5IHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG1ha2luZyBpdFxuLy8gdHJlZS1zaGFrYWJsZS5cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG4vLyBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgIC8vIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIGNoZWNrXG4gICAge1xuICAgICAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xuICAgIH1cbiAgICBjb25zdCB7IGluc2VydDogaG9zdEluc2VydCwgcmVtb3ZlOiBob3N0UmVtb3ZlLCBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LCBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsIHNldFRleHQ6IGhvc3RTZXRUZXh0LCBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LCBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSwgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZywgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLCBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudCB9ID0gb3B0aW9ucztcbiAgICAvLyBOb3RlOiBmdW5jdGlvbnMgaW5zaWRlIHRoaXMgY2xvc3VyZSBzaG91bGQgdXNlIGBjb25zdCB4eHggPSAoKSA9PiB7fWBcbiAgICAvLyBzdHlsZSBpbiBvcmRlciB0byBwcmV2ZW50IGJlaW5nIGlubGluZWQgYnkgbWluaWZpZXJzLlxuICAgIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xuICAgICAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGF0Y2hpbmcgJiBub3Qgc2FtZSB0eXBlLCB1bm1vdW50IG9sZCB0cmVlXG4gICAgICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICAgICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgIG4xID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi8pIHtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRleHQ6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgICAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgICAgICAgICBwcm9jZXNzRnJhZ21lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHJlZlxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbikpLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCAnJykpLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIHN1cHBvcnQgZm9yIGR5bmFtaWMgY29tbWVudHNcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKSA9PiB7XG4gICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG4yLmVsLCBuMi5hbmNob3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV2IC8gSE1SIG9ubHlcbiAgICAgKi9cbiAgICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XG4gICAgICAgIC8vIHN0YXRpYyBub2RlcyBhcmUgb25seSBwYXRjaGVkIGR1cmluZyBkZXYgZm9yIEhNUlxuICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XG4gICAgICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGVsID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgICAgICAgIGVsID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBuMi50eXBlID09PSAnc3ZnJztcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdW50RWxlbWVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRjaEVsZW1lbnQobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgbGV0IGVsO1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIGRpcnMgfSA9IHZub2RlO1xuICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzLCBwcm9wcyk7XG4gICAgICAgIC8vIG1vdW50IGNoaWxkcmVuIGZpcnN0LCBzaW5jZSBzb21lIHByb3BzIG1heSByZWx5IG9uIGNoaWxkIGNvbnRlbnRcbiAgICAgICAgLy8gYmVpbmcgYWxyZWFkeSByZW5kZXJlZCwgZS5nLiBgPHNlbGVjdCB2YWx1ZT5gXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgbW91bnRDaGlsZHJlbih2bm9kZS5jaGlsZHJlbiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHICYmIHR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NvcGVJZFxuICAgICAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAvLyBwcm9wc1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3ZhbHVlJyAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBmb3Igc2V0dGluZyB2YWx1ZSBvbiBET00gZWxlbWVudHM6XG4gICAgICAgICAgICAgKiAtIGl0IGNhbiBiZSBvcmRlci1zZW5zaXRpdmUgKGUuZy4gc2hvdWxkIGJlIHNldCAqYWZ0ZXIqIG1pbi9tYXgsICMyMzI1LCAjNDAyNClcbiAgICAgICAgICAgICAqIC0gaXQgbmVlZHMgdG8gYmUgZm9yY2VkICgjMTQ3MSlcbiAgICAgICAgICAgICAqICMyMzUzIHByb3Bvc2VzIGFkZGluZyBhbm90aGVyIHJlbmRlcmVyIG9wdGlvbiB0byBjb25maWd1cmUgdGhpcywgYnV0XG4gICAgICAgICAgICAgKiB0aGUgcHJvcGVydGllcyBhZmZlY3RzIGFyZSBzbyBmaW5pdGUgaXQgaXMgd29ydGggc3BlY2lhbCBjYXNpbmcgaXRcbiAgICAgICAgICAgICAqIGhlcmUgdG8gcmVkdWNlIHRoZSBjb21wbGV4aXR5LiAoU3BlY2lhbCBjYXNpbmcgaXQgYWxzbyBzaG91bGQgbm90XG4gICAgICAgICAgICAgKiBhZmZlY3Qgbm9uLURPTSByZW5kZXJlcnMpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgbnVsbCwgcHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdm5vZGUnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZub2RlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdnVlUGFyZW50Q29tcG9uZW50Jywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vICMxNTgzIEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSBub3QgcmVzb2x2ZWQgY2FzZSwgZW50ZXIgaG9vayBzaG91bGQgY2FsbCB3aGVuIHN1c3BlbnNlIHJlc29sdmVkXG4gICAgICAgIC8vICMxNjg5IEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSByZXNvbHZlZCBjYXNlLCBqdXN0IGNhbGwgaXRcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fFxuICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHxcbiAgICAgICAgICAgIGRpcnMpIHtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgcGFyZW50Vk5vZGUsIHBhcmVudFZOb2RlLnNjb3BlSWQsIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50LnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIGNoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XG4gICAgICAgIC8vICMxNDI2IHRha2UgdGhlIG9sZCB2bm9kZSdzIHBhdGNoIGZsYWcgaW50byBhY2NvdW50IHNpbmNlIHVzZXIgbWF5IGNsb25lIGFcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcbiAgICAgICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLztcbiAgICAgICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAvLyBkaXNhYmxlIHJlY3Vyc2UgaW4gYmVmb3JlVXBkYXRlIGhvb2tzXG4gICAgICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAvLyBmdWxsIGRpZmZcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyIGFuZCBjYW4gdGFrZSB0aGUgZmFzdCBwYXRoLlxuICAgICAgICAgICAgLy8gaW4gdGhpcyBwYXRoIG9sZCBub2RlIGFuZCBuZXcgbm9kZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLykge1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgcHJvcHMgY29udGFpbiBkeW5hbWljIGtleXMsIGZ1bGwgZGlmZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjbGFzc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIgLyogUGF0Y2hGbGFncy5DTEFTUyAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnY2xhc3MnLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN0eWxlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3N0eWxlJywgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByb3BzXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBwcm9wL2F0dHIgYmluZGluZ3NcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0aGFuIGNsYXNzIGFuZCBzdHlsZS4gVGhlIGtleXMgb2YgZHluYW1pYyBwcm9wL2F0dHJzIGFyZSBzYXZlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgZHluYW1pYyBrZXlzIGxpa2UgOltmb29dPVwiYmFyXCIgd2lsbCBjYXVzZSB0aGlzIG9wdGltaXphdGlvbiB0b1xuICAgICAgICAgICAgICAgIC8vIGJhaWwgb3V0IGFuZCBnbyB0aHJvdWdoIGEgZnVsbCBkaWZmIGJlY2F1c2Ugd2UgbmVlZCB0byB1bnNldCB0aGUgb2xkIGtleVxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjMTQ3MSBmb3JjZSBwYXRjaCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgbjEuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBvbmx5IGR5bmFtaWMgdGV4dCBjaGlsZHJlbi5cbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVub3B0aW1pemVkLCBmdWxsIGRpZmZcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAndXBkYXRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGUgZmFzdCBwYXRoIGZvciBibG9ja3MuXG4gICAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBcbiAgICAgICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxuICAgICAgICAgICAgb2xkVk5vZGUuZWwgJiZcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovIHwgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykpXG4gICAgICAgICAgICAgICAgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbClcbiAgICAgICAgICAgICAgICA6IC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyO1xuICAgICAgICAgICAgcGF0Y2gob2xkVk5vZGUsIG5ld1ZOb2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCB2bm9kZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRykgPT4ge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgb2xkUHJvcHNba2V5XSwgbnVsbCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IHZhbGlkIHByb3BcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gZGVmZXIgcGF0Y2hpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiAmJiBrZXkgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAndmFsdWUnLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSAobjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIC8vICM1NTIzIGRldiByb290IGZyYWdtZW50IG1heSBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLykpIHtcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkIC8gRGV2IHJvb3QgZnJhZ21lbnQgKHcvIGNvbW1lbnRzKSwgZm9yY2UgZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYSBzbG90IGZyYWdtZW50IHdpdGggOnNsb3R0ZWQgc2NvcGUgaWRzXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXG4gICAgICAgICAgICAgICAgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKVxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgLy8gYSBmcmFnbWVudCBjYW4gb25seSBoYXZlIGFycmF5IGNoaWxkcmVuXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciwgb3IgaW1wbGljaXRseSBjcmVhdGVkXG4gICAgICAgICAgICAvLyBmcm9tIGFycmF5cy5cbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4objIuY2hpbGRyZW4sIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJlxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovICYmXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuICYmXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAgICAgICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBjaGlsZHJlbiBvcmRlciwgYnV0IGl0IG1heSBjb250YWluIGR5bmFtaWNDaGlsZHJlbi5cbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxuICAgICAgICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXG4gICAgICAgICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cbiAgICAgICAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAocGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8ga2V5ZWQgLyB1bmtleWVkLCBvciBtYW51YWwgZnJhZ21lbnRzLlxuICAgICAgICAgICAgICAgIC8vIGZvciBrZXllZCAmIHVua2V5ZWQsIHNpbmNlIHRoZXkgYXJlIGNvbXBpbGVyIGdlbmVyYXRlZCBmcm9tIHYtZm9yLFxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBkeW5hbWljQ2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIgLyogU2hhcGVGbGFncy5DT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShpbml0aWFsVk5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5qZWN0IHJlbmRlcmVyIGludGVybmFscyBmb3Iga2VlcEFsaXZlXG4gICAgICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9wcyBhbmQgc2xvdHMgZm9yIHNldHVwIGNvbnRleHRcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwKCkgaXMgYXN5bmMuIFRoaXMgY29tcG9uZW50IHJlbGllcyBvbiBhc3luYyBsb2dpYyB0byBiZSByZXNvbHZlZFxuICAgICAgICAvLyBiZWZvcmUgcHJvY2VlZGluZ1xuICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCk7XG4gICAgICAgICAgICAvLyBHaXZlIGl0IGEgcGxhY2Vob2xkZXIgaWYgdGhpcyBpcyBub3QgaHlkcmF0aW9uXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBzZWxmLWRlZmluZWQgZmFsbGJhY2tcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQpO1xuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY29tcG9uZW50J3MgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXIgaXNuJ3Qgc2V0LXVwIHlldFxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgY29tcG9uZW50IGlzIGFsc28gcXVldWVkLCByZW1vdmUgaXQgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxuICAgICAgICAgICAgICAgIGludmFsaWRhdGVKb2IoaW5zdGFuY2UudXBkYXRlKTtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS51cGRhdGUgaXMgdGhlIHJlYWN0aXZlIGVmZmVjdC5cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZSBuZWVkZWQuIGp1c3QgY29weSBvdmVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIGhhcyBhZG9wdGVkIGhvc3Qgbm9kZSAtIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlTm9kZShlbCwgaW5zdGFuY2Uuc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLnR5cGUuX19hc3luY0xvYWRlcigpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgd29uJ3QgdHJhY2sgZGVwZW5kZW5jaWVzIC0gYnV0IGl0J3Mgb2sgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBzZXJ2ZXItcmVuZGVyZWQgYXN5bmMgd3JhcHBlciBpcyBhbHJlYWR5IGluIHJlc29sdmVkIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBoeWRyYXRlU3ViVHJlZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvblZub2RlTW91bnRlZFxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cbiAgICAgICAgICAgICAgICAvLyAjMTc0MiBhY3RpdmF0ZWQgaG9vayBtdXN0IGJlIGFjY2Vzc2VkIGFmdGVyIGZpcnN0IHJlbmRlclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBob29rIG1heSBiZSBpbmplY3RlZCBieSBhIGNoaWxkIGtlZXAtYWxpdmVcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAocGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FzeW5jV3JhcHBlcihwYXJlbnQudm5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdHJpZ2dlcmVkIGJ5IG11dGF0aW9uIG9mIGNvbXBvbmVudCdzIG93biBzdGF0ZSAobmV4dDogbnVsbClcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcbiAgICAgICAgICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERpc2FsbG93IGNvbXBvbmVudCBlZmZlY3QgcmVjdXJzaW9uIGR1cmluZyBwcmUtbGlmZWN5Y2xlIGhvb2tzLlxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlVXBkYXRlXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSwgXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYtdHJpZ2dlcmVkIHVwZGF0ZS4gSW4gY2FzZSBvZiBIT0MsIHVwZGF0ZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIGVsLiBIT0MgaXMgaW5kaWNhdGVkIGJ5IHBhcmVudCBpbnN0YW5jZSdzIHN1YlRyZWUgcG9pbnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xuICAgICAgICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVVcGRhdGVkXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gKGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbiwgKCkgPT4gcXVldWVKb2IodXBkYXRlKSwgaW5zdGFuY2Uuc2NvcGUgLy8gdHJhY2sgaXQgaW4gY29tcG9uZW50J3MgZWZmZWN0IHNjb3BlXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCB1cGRhdGUgPSAoaW5zdGFuY2UudXBkYXRlID0gKCkgPT4gZWZmZWN0LnJ1bigpKTtcbiAgICAgICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICAvLyBhbGxvd1JlY3Vyc2VcbiAgICAgICAgLy8gIzE4MDEsICMyMDQzIGNvbXBvbmVudCByZW5kZXIgZWZmZWN0cyBzaG91bGQgYWxsb3cgcmVjdXJzaXZlIHVwZGF0ZXNcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSlcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBpbnN0YW5jZS5ydGdcbiAgICAgICAgICAgICAgICA/IGUgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgdXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXG4gICAgICAgIC8vIGZsdXNoIHRoZW0gYmVmb3JlIHRoZSByZW5kZXIgdXBkYXRlLlxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9O1xuICAgIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgICAgIC8vIGZhc3QgcGF0aFxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCAvKiBQYXRjaEZsYWdzLktFWUVEX0ZSQUdNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBlaXRoZXIgZnVsbHkta2V5ZWQgb3IgbWl4ZWQgKHNvbWUga2V5ZWQgc29tZSBub3QpXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgcGF0Y2hGbGFnIG1lYW5zIGNoaWxkcmVuIGFyZSBndWFyYW50ZWVkIHRvIGJlIGFycmF5c1xuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyB1bmtleWVkXG4gICAgICAgICAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hpbGRyZW4gaGFzIDMgcG9zc2liaWxpdGllczogdGV4dCwgYXJyYXkgb3Igbm8gY2hpbGRyZW4uXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgLy8gdGV4dCBjaGlsZHJlbiBmYXN0IHBhdGhcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0d28gYXJyYXlzLCBjYW5ub3QgYXNzdW1lIGFueXRoaW5nLCBkbyBmdWxsIGRpZmZcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZXcgY2hpbGRyZW4sIGp1c3QgdW5tb3VudCBvbGRcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcbiAgICAgICAgICAgICAgICAvLyBuZXcgY2hpbGRyZW4gaXMgYXJyYXkgT1IgbnVsbFxuICAgICAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXcgaWYgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcbiAgICAgICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xuICAgICAgICAgICAgcGF0Y2goYzFbaV0sIG5leHRDaGlsZCwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgZmFsc2UsIGNvbW1vbkxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBtb3VudCBuZXdcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGNvbW1vbkxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGNhbiBiZSBhbGwta2V5ZWQgb3IgbWl4ZWRcbiAgICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7IC8vIHByZXYgZW5kaW5nIGluZGV4XG4gICAgICAgIGxldCBlMiA9IGwyIC0gMTsgLy8gbmV4dCBlbmRpbmcgaW5kZXhcbiAgICAgICAgLy8gMS4gc3luYyBmcm9tIHN0YXJ0XG4gICAgICAgIC8vIChhIGIpIGNcbiAgICAgICAgLy8gKGEgYikgZCBlXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICAgICAgICBjb25zdCBuMiA9IChjMltpXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xuICAgICAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXG4gICAgICAgIC8vIGEgKGIgYylcbiAgICAgICAgLy8gZCBlIChiIGMpXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbZTJdID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltlMl0pKTtcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlMS0tO1xuICAgICAgICAgICAgZTItLTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBjb21tb24gc2VxdWVuY2UgKyBtb3VudFxuICAgICAgICAvLyAoYSBiKVxuICAgICAgICAvLyAoYSBiKSBjXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDEsIGUyID0gMlxuICAgICAgICAvLyAoYSBiKVxuICAgICAgICAvLyBjIChhIGIpXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IC0xLCBlMiA9IDBcbiAgICAgICAgaWYgKGkgPiBlMSkge1xuICAgICAgICAgICAgaWYgKGkgPD0gZTIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIChjMltpXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxuICAgICAgICAvLyAoYSBiKSBjXG4gICAgICAgIC8vIChhIGIpXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxuICAgICAgICAvLyBhIChiIGMpXG4gICAgICAgIC8vIChiIGMpXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcbiAgICAgICAgZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICAgICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA1LiB1bmtub3duIHNlcXVlbmNlXG4gICAgICAgIC8vIFtpIC4uLiBlMSArIDFdOiBhIGIgW2MgZCBlXSBmIGdcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDQsIGUyID0gNVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxuICAgICAgICAgICAgY29uc3QgczIgPSBpOyAvLyBuZXh0IHN0YXJ0aW5nIGluZGV4XG4gICAgICAgICAgICAvLyA1LjEgYnVpbGQga2V5OmluZGV4IG1hcCBmb3IgbmV3Q2hpbGRyZW5cbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCwgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBub2RlcyAmIHJlbW92ZSBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudFxuICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XG4gICAgICAgICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXG4gICAgICAgICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XG4gICAgICAgICAgICAvLyB3b3JrcyBhcyBNYXA8bmV3SW5kZXgsIG9sZEluZGV4PlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxuICAgICAgICAgICAgLy8gYW5kIG9sZEluZGV4ID0gMCBpcyBhIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGluZyB0aGUgbmV3IG5vZGUgaGFzXG4gICAgICAgICAgICAvLyBubyBjb3JyZXNwb25kaW5nIG9sZCBub2RlLlxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9CZVBhdGNoZWQ7IGkrKylcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBuZXcgY2hpbGRyZW4gaGF2ZSBiZWVuIHBhdGNoZWQgc28gdGhpcyBjYW4gb25seSBiZSBhIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtleS1sZXNzIG5vZGUsIHRyeSB0byBsb2NhdGUgYSBrZXktbGVzcyBub2RlIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gczI7IGogPD0gZTI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1LjMgbW92ZSBhbmQgbW91bnRcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlIG9ubHkgd2hlbiBub2RlcyBoYXZlIG1vdmVkXG4gICAgICAgICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkXG4gICAgICAgICAgICAgICAgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9BUlI7XG4gICAgICAgICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIC8vIGxvb3BpbmcgYmFja3dhcmRzIHNvIHRoYXQgd2UgY2FuIHVzZSBsYXN0IHBhdGNoZWQgbm9kZSBhcyBhbmNob3JcbiAgICAgICAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ld1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGlmOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxuICAgICAgICAgICAgICAgICAgICAvLyBPUiBjdXJyZW50IG5vZGUgaXMgbm90IGFtb25nIHRoZSBzdGFibGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogTW92ZVR5cGUuUkVPUkRFUiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICAgICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpbmdsZSBub2Rlc1xuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIE1vdmVUeXBlLlJFT1JERVIgKi8gJiZcbiAgICAgICAgICAgIHNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uO1xuICAgICAgICBpZiAobmVlZFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBNb3ZlVHlwZS5FTlRFUiAqLykge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcbiAgICAgICAgLy8gdW5zZXQgcmVmXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJiBkaXJzO1xuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVbm1vdW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIGludGVybmFscywgZG9SZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmXG4gICAgICAgICAgICAgICAgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggZm9yIGJsb2NrIG5vZGVzOiBvbmx5IG5lZWQgdG8gdW5tb3VudCBkeW5hbWljIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihkeW5hbWljQ2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSBGcmFnbWVudCAmJlxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmXG4gICAgICAgICAgICAgICAgICAgICgxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqLyB8IDI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxuICAgICAgICAgICAgICAgICghb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZSh2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiZcbiAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSkgfHxcbiAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAndW5tb3VudGVkJyk7XG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IHZub2RlID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnID4gMCAmJlxuICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyAmIDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xuICAgICAgICAvLyBGb3IgZnJhZ21lbnRzLCBkaXJlY3RseSByZW1vdmUgYWxsIGNvbnRhaW5lZCBET00gbm9kZXMuXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGN1cik7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgICB9O1xuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBidW0sIHNjb3BlLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgLy8gYmVmb3JlVW5tb3VudCBob29rXG4gICAgICAgIGlmIChidW0pIHtcbiAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcCBlZmZlY3RzIGluIGNvbXBvbmVudCBzY29wZVxuICAgICAgICBzY29wZS5zdG9wKCk7XG4gICAgICAgIC8vIHVwZGF0ZSBtYXkgYmUgbnVsbCBpZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIGl0cyBhc3luY1xuICAgICAgICAvLyBzZXR1cCBoYXMgcmVzb2x2ZWQuXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgc2NoZWR1bGVyIHdpbGwgbm8gbG9uZ2VyIGludm9rZSBpdFxuICAgICAgICAgICAgdXBkYXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xuICAgICAgICBpZiAodW0pIHtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgLy8gQSBjb21wb25lbnQgd2l0aCBhc3luYyBkZXAgaW5zaWRlIGEgcGVuZGluZyBzdXNwZW5zZSBpcyB1bm1vdW50ZWQgYmVmb3JlXG4gICAgICAgIC8vIGl0cyBhc3luYyBkZXAgcmVzb2x2ZXMuIFRoaXMgc2hvdWxkIHJlbW92ZSB0aGUgZGVwIGZyb20gdGhlIHN1c3BlbnNlLCBhbmRcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiZcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiZcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxuICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgJiZcbiAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvc3ROZXh0U2libGluZygodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcbiAgICAgICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgbnVsbCwgbnVsbCwgaXNTVkcpO1xuICAgICAgICB9XG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgdW06IHVubW91bnQsXG4gICAgICAgIG06IG1vdmUsXG4gICAgICAgIHI6IHJlbW92ZSxcbiAgICAgICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgICAgIG86IG9wdGlvbnNcbiAgICB9O1xuICAgIGxldCBoeWRyYXRlO1xuICAgIGxldCBoeWRyYXRlTm9kZTtcbiAgICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVJlY3Vyc2UoeyBlZmZlY3QsIHVwZGF0ZSB9LCBhbGxvd2VkKSB7XG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xufVxuLyoqXG4gKiAjMTE1NlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXG4gKiBpbnNpZGUgYSBibG9jayBhbHNvIGluaGVyaXQgdGhlIERPTSBlbGVtZW50IGZyb20gdGhlIHByZXZpb3VzIHRyZWUgc28gdGhhdFxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXG4gKlxuICogIzIwODBcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBiZSBtb3ZlZC4gVGhlcmVmb3JlLCBpbiBvcmRlciB0byBlbnN1cmUgY29ycmVjdCBtb3ZlXG4gKiBwb3NpdGlvbiwgZWwgc2hvdWxkIGJlIGluaGVyaXRlZCBmcm9tIHByZXZpb3VzIG5vZGVzLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gICAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBjYWxsZWQgaW4gdGhlIG9wdGltaXplZCBwYXRoIHNvIGFycmF5IGNoaWxkcmVuIGFyZVxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSB2bm9kZXNcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93KVxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAjNjg1MiBhbHNvIGluaGVyaXQgZm9yIHRleHQgbm9kZXNcbiAgICAgICAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gaW5oZXJpdCBmb3IgY29tbWVudCBub2RlcywgYnV0IG5vdCBwbGFjZWhvbGRlcnMgKGUuZy4gdi1pZiB3aGljaFxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSByZWNlaXZlZCAuZWwgZHVyaW5nIGJsb2NrIHBhdGNoKVxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjMi50eXBlID09PSBDb21tZW50ICYmICFjMi5lbCkge1xuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb25nZXN0X2luY3JlYXNpbmdfc3Vic2VxdWVuY2VcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgICBjb25zdCByZXN1bHQgPSBbMF07XG4gICAgbGV0IGksIGosIHUsIHYsIGM7XG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcbiAgICAgICAgICAgIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHUgPSAwO1xuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgICAgICAgICAgYyA9ICh1ICsgdikgPj4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgICAgICAgICAgIHUgPSBjICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFt1XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgdiA9IHJlc3VsdFt1IC0gMV07XG4gICAgd2hpbGUgKHUtLSA+IDApIHtcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcbiAgICAgICAgdiA9IHBbdl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gJycpO1xuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xuICAgICAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XG4gICAgfVxufTtcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xuICAgICAgICBjb25zdCB7IG1jOiBtb3VudENoaWxkcmVuLCBwYzogcGF0Y2hDaGlsZHJlbiwgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH0gfSA9IGludGVybmFscztcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xuICAgICAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xuICAgICAgICAvLyAjMzMwMlxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChuMi5lbCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgc3RhcnQnKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IGVuZCcpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8vICMyNjUyIHdlIGNvdWxkIGJlIHRlbGVwb3J0aW5nIGZyb20gYSBub24tU1ZHIHRyZWUgaW50byBhbiBTVkcgdHJlZVxuICAgICAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgKmFsd2F5cyogaGFzIEFycmF5IGNoaWxkcmVuLiBUaGlzIGlzIGVuZm9yY2VkIGluIGJvdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZXIgYW5kIHZub2RlIGNoaWxkcmVuIG5vcm1hbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gbjEuYW5jaG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCB3aGVuIHRoZSB0ZWxlcG9ydCBoYXBwZW5zIHRvIGJlIGEgYmxvY2sgcm9vdFxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY3VycmVudENvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgdGVsZXBvcnQgaW5oZXJpdCBwcmV2aW91cyBET00gcmVmZXJlbmNlcyBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgICAgICAgICAgLy8gYmUgbW92ZWQgaW4gZnV0dXJlIHBhdGNoZXMuXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZWQgLT4gZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIG1haW4gY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVGVsZXBvcnRNb3ZlVHlwZXMuVE9HR0xFICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCBuZXh0VGFyZ2V0LCBudWxsLCBpbnRlcm5hbHMsIDAgLyogVGVsZXBvcnRNb3ZlVHlwZXMuVEFSR0VUX0NIQU5HRSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiB1cGRhdGU6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gdGVsZXBvcnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgdGFyZ2V0LCB0YXJnZXRBbmNob3IsIGludGVybmFscywgMSAvKiBUZWxlcG9ydE1vdmVUeXBlcy5UT0dHTEUgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDc3NWYXJzKG4yKTtcbiAgICB9LFxuICAgIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKHRhcmdldEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW4gdW5tb3VudGVkIHRlbGVwb3J0IHNob3VsZCBhbHdheXMgcmVtb3ZlIGl0cyBjaGlsZHJlbiBpZiBub3QgZGlzYWJsZWRcbiAgICAgICAgaWYgKGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChjaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgISFjaGlsZC5keW5hbWljQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW92ZTogbW92ZVRlbGVwb3J0LFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIgLyogVGVsZXBvcnRNb3ZlVHlwZXMuUkVPUkRFUiAqLykge1xuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cbiAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogVGVsZXBvcnRNb3ZlVHlwZXMuVEFSR0VUX0NIQU5HRSAqLykge1xuICAgICAgICBpbnNlcnQodm5vZGUudGFyZ2V0QW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gICAgfVxuICAgIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICAgIGNvbnN0IGlzUmVvcmRlciA9IG1vdmVUeXBlID09PSAyIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlJFT1JERVIgKi87XG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cbiAgICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbiAgICAvLyBpZiB0aGlzIGlzIGEgcmUtb3JkZXIgYW5kIHRlbGVwb3J0IGlzIGVuYWJsZWQgKGNvbnRlbnQgaXMgaW4gdGFyZ2V0KVxuICAgIC8vIGRvIG5vdCBtb3ZlIGNoaWxkcmVuLiBTbyB0aGUgb3Bwb3NpdGUgaXM6IG9ubHkgbW92ZSBjaGlsZHJlbiBpZiB0aGlzXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXG4gICAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAvLyBUZWxlcG9ydCBoYXMgZWl0aGVyIEFycmF5IGNoaWxkcmVuIG9yIG5vIGNoaWxkcmVuLlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCAyIC8qIE1vdmVUeXBlLlJFT1JERVIgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXG4gICAgaWYgKGlzUmVvcmRlcikge1xuICAgICAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH0gfSwgaHlkcmF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gKHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQodm5vZGUucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlIHRlbGVwb3J0cyByZW5kZXJlZCB0byB0aGUgc2FtZSB0YXJnZXQgZWxlbWVudCwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBwaWNrIHVwIGZyb20gd2hlcmUgdGhlIGxhc3QgdGVsZXBvcnQgZmluaXNoZWQgaW5zdGVhZCBvZiB0aGUgZmlyc3Qgbm9kZVxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIHBhcmVudE5vZGUobm9kZSksIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gbG9va2FoZWFkIHVudGlsIHdlIGZpbmQgdGhlIHRhcmdldCBhbmNob3JcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgcmVseSBvbiByZXR1cm4gdmFsdWUgb2YgaHlkcmF0ZUNoaWxkcmVuKCkgYmVjYXVzZSB0aGVyZVxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIGJlIG5lc3RlZCB0ZWxlcG9ydHNcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5ub2RlVHlwZSA9PT0gOCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLmRhdGEgPT09ICd0ZWxlcG9ydCBhbmNob3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX2xwYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNzc1ZhcnModm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5mdW5jdGlvbiB1cGRhdGVDc3NWYXJzKHZub2RlKSB7XG4gICAgLy8gcHJlc2VuY2Ugb2YgLnV0IG1ldGhvZCBpbmRpY2F0ZXMgb3duZXIgY29tcG9uZW50IHVzZXMgY3NzIHZhcnMuXG4gICAgLy8gY29kZSBwYXRoIGhlcmUgY2FuIGFzc3VtZSBicm93c2VyIGVudmlyb25tZW50LlxuICAgIGNvbnN0IGN0eCA9IHZub2RlLmN0eDtcbiAgICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgICAgICBsZXQgbm9kZSA9IHZub2RlLmNoaWxkcmVuWzBdLmVsO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gdm5vZGUudGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSlcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS12LW93bmVyJywgY3R4LnVpZCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBjdHgudXQoKTtcbiAgICB9XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdGcmFnbWVudCcgOiB1bmRlZmluZWQpO1xuY29uc3QgVGV4dCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnVGV4dCcgOiB1bmRlZmluZWQpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnQ29tbWVudCcgOiB1bmRlZmluZWQpO1xuY29uc3QgU3RhdGljID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdTdGF0aWMnIDogdW5kZWZpbmVkKTtcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XG4vLyBjaGFuZ2UsIG9uY2Ugd2UgY29uc2lkZXIgdi1pZiBicmFuY2hlcyBhbmQgZWFjaCB2LWZvciBmcmFnbWVudCBhIGJsb2NrLCB3ZVxuLy8gY2FuIGRpdmlkZSBhIHRlbXBsYXRlIGludG8gbmVzdGVkIGJsb2NrcywgYW5kIHdpdGhpbiBlYWNoIGJsb2NrIHRoZSBub2RlXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xuLy8gYW5kIG9ubHkgd29ycnkgYWJvdXQgdGhlIGR5bmFtaWMgbm9kZXMgKGluZGljYXRlZCBieSBwYXRjaCBmbGFncykuXG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbi8qKlxuICogT3BlbiBhIGJsb2NrLlxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxuICogYmVjYXVzZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGJsb2NrIGFyZSBldmFsdWF0ZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AgaXRzZWxmXG4gKiBpcyBjYWxsZWQuIFRoZSBnZW5lcmF0ZWQgY29kZSB0eXBpY2FsbHkgbG9va3MgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcbiAqIH1cbiAqIGBgYFxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXG4gKiBmcmFnbWVudCBhbHdheXMgZGlmZnMgaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XG59XG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xuICAgIGJsb2NrU3RhY2sucG9wKCk7XG4gICAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxuLy8gT25seSB0cmFja3Mgd2hlbiB0aGlzIHZhbHVlIGlzID4gMFxuLy8gV2UgYXJlIG5vdCB1c2luZyBhIHNpbXBsZSBib29sZWFuIGJlY2F1c2UgdGhpcyB2YWx1ZSBtYXkgbmVlZCB0byBiZVxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XG4vKipcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxuICogY3JlYXRpb24gb2YgYSB0cmVlIHRoYXQgbmVlZHMgdG8gYmUgY2FjaGVkIGJ5IHYtb25jZS4gVGhlIGNvbXBpbGVyIGdlbmVyYXRlc1xuICogY29kZSBsaWtlIHRoaXM6XG4gKlxuICogYGBgIGpzXG4gKiBfY2FjaGVbMV0gfHwgKFxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcbiAqICAgX2NhY2hlWzFdID0gY3JlYXRlVk5vZGUoLi4uKSxcbiAqICAgc2V0QmxvY2tUcmFja2luZygxKSxcbiAqICAgX2NhY2hlWzFdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XG4gICAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICAgIC8vIHNhdmUgY3VycmVudCBibG9jayBjaGlsZHJlbiBvbiB0aGUgYmxvY2sgdm5vZGVcbiAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPVxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gICAgLy8gY2xvc2UgYmxvY2tcbiAgICBjbG9zZUJsb2NrKCk7XG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcbiAgICAvLyBwYXJlbnQgYmxvY2tcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnLCB0cnVlIC8qIGlzQmxvY2sgKi8pKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgYmxvY2sgcm9vdCB2bm9kZS4gVGFrZXMgdGhlIHNhbWUgZXhhY3QgYXJndW1lbnRzIGFzIGBjcmVhdGVWTm9kZWAuXG4gKiBBIGJsb2NrIHJvb3Qga2VlcHMgdHJhY2sgb2YgZHluYW1pYyBub2RlcyB3aXRoaW4gdGhlIGJsb2NrIGluIHRoZVxuICogYGR5bmFtaWNDaGlsZHJlbmAgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiBzZXR1cEJsb2NrKGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHRydWUgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovKSk7XG59XG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8gJiZcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xuICAgICAgICAvLyAjNzA0MiwgZW5zdXJlIHRoZSB2bm9kZSBiZWluZyB1bm1vdW50ZWQgZHVyaW5nIEhNUlxuICAgICAgICAvLyBiaXR3aXNlIG9wZXJhdGlvbnMgdG8gcmVtb3ZlIGtlZXAgYWxpdmUgZmxhZ3NcbiAgICAgICAgbjEuc2hhcGVGbGFnICY9IH4yNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XG4gICAgICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbi8qKlxuICogSW50ZXJuYWwgQVBJIGZvciByZWdpc3RlcmluZyBhbiBhcmd1bWVudHMgdHJhbnNmb3JtIGZvciBjcmVhdGVWTm9kZVxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcbiAqIHR5cGluZ3NcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XG4gICAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBfY3JlYXRlVk5vZGUoLi4uKHZub2RlQXJnc1RyYW5zZm9ybWVyXG4gICAgICAgID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKVxuICAgICAgICA6IGFyZ3MpKTtcbn07XG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHsgcmVmLCByZWZfa2V5LCByZWZfZm9yIH0pID0+IHtcbiAgICByZXR1cm4gKHJlZiAhPSBudWxsXG4gICAgICAgID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKVxuICAgICAgICAgICAgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfVxuICAgICAgICAgICAgOiByZWZcbiAgICAgICAgOiBudWxsKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgdm5vZGUgPSB7XG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICAgICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxuICAgICAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcbiAgICAgICAgc3NDb250ZW50OiBudWxsLFxuICAgICAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgICAgICBkaXJzOiBudWxsLFxuICAgICAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgYW5jaG9yOiBudWxsLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICAgICAgc3RhdGljQ291bnQ6IDAsXG4gICAgICAgIHNoYXBlRmxhZyxcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcHMsXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICAgICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgICB9O1xuICAgIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgICAgICAvLyBub3JtYWxpemUgc3VzcGVuc2UgY2hpbGRyZW5cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gY29tcGlsZWQgZWxlbWVudCB2bm9kZSAtIGlmIGNoaWxkcmVuIGlzIHBhc3NlZCwgb25seSBwb3NzaWJsZSB0eXBlcyBhcmVcbiAgICAgICAgLy8gc3RyaW5nIG9yIEFycmF5LlxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pXG4gICAgICAgICAgICA/IDggLyogU2hhcGVGbGFncy5URVhUX0NISUxEUkVOICovXG4gICAgICAgICAgICA6IDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi87XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlIGtleVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcbiAgICAgICAgd2FybihgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvLyB0cmFjayB2bm9kZSBmb3IgYmxvY2sgdHJlZVxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmXG4gICAgICAgIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAgICAgICAhaXNCbG9ja05vZGUgJiZcbiAgICAgICAgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXG4gICAgICAgIGN1cnJlbnRCbG9jayAmJlxuICAgICAgICAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxuICAgICAgICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXG4gICAgICAgIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cbiAgICAgICAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykgJiZcbiAgICAgICAgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXG4gICAgICAgIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXG4gICAgICAgIHZub2RlLnBhdGNoRmxhZyAhPT0gMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqLykge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGUpO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhdHlwZSkge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IENvbW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgICAgIC8vIGNyZWF0ZVZOb2RlIHJlY2VpdmluZyBhbiBleGlzdGluZyB2bm9kZS4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cbiAgICAgICAgLy8gIzIwNzggbWFrZSBzdXJlIHRvIG1lcmdlIHJlZnMgZHVyaW5nIHRoZSBjbG9uZSBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nIGl0XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodHlwZSwgcHJvcHMsIHRydWUgLyogbWVyZ2VSZWY6IHRydWUgKi8pO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmICFpc0Jsb2NrTm9kZSAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgICAgICAgIGlmIChjbG9uZWQuc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsb25lZC5wYXRjaEZsYWcgfD0gLTIgLyogUGF0Y2hGbGFncy5CQUlMICovO1xuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cbiAgICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgICAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XG4gICAgfVxuICAgIC8vIGNsYXNzICYgc3R5bGUgbm9ybWFsaXphdGlvbi5cbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgLy8gZm9yIHJlYWN0aXZlIG9yIHByb3h5IG9iamVjdHMsIHdlIG5lZWQgdG8gY2xvbmUgaXQgdG8gZW5hYmxlIG11dGF0aW9uLlxuICAgICAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgICAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xuICAgICAgICAgICAgLy8gcmVhY3RpdmUgc3RhdGUgb2JqZWN0cyBuZWVkIHRvIGJlIGNsb25lZCBzaW5jZSB0aGV5IGFyZSBsaWtlbHkgdG8gYmVcbiAgICAgICAgICAgIC8vIG11dGF0ZWRcbiAgICAgICAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZW5jb2RlIHRoZSB2bm9kZSB0eXBlIGluZm9ybWF0aW9uIGludG8gYSBiaXRtYXBcbiAgICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKVxuICAgICAgICA/IDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovXG4gICAgICAgIDogaXNTdXNwZW5zZSh0eXBlKVxuICAgICAgICAgICAgPyAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqL1xuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXG4gICAgICAgICAgICAgICAgPyA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovXG4gICAgICAgICAgICAgICAgOiBpc09iamVjdCh0eXBlKVxuICAgICAgICAgICAgICAgICAgICA/IDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDIgLyogU2hhcGVGbGFncy5GVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqLyAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgICAgIHR5cGUgPSB0b1Jhdyh0eXBlKTtcbiAgICAgICAgd2FybihgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBgICtcbiAgICAgICAgICAgIGBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgYCArXG4gICAgICAgICAgICBgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGAgK1xuICAgICAgICAgICAgYGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsIGBcXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnLCBpc0Jsb2NrTm9kZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaXNQcm94eShwcm9wcykgfHwgSW50ZXJuYWxPYmplY3RLZXkgaW4gcHJvcHNcbiAgICAgICAgPyBleHRlbmQoe30sIHByb3BzKVxuICAgICAgICA6IHByb3BzO1xufVxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBOT1QgdXNpbmcgc3ByZWFkIG9yIGV4dGVuZCB0byBhdm9pZCB0aGUgcnVudGltZVxuICAgIC8vIGtleSBlbnVtZXJhdGlvbiBjb3N0LlxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcbiAgICBjb25zdCBjbG9uZWQgPSB7XG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICAgICAgdHlwZTogdm5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxuICAgICAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZlxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxuICAgICAgICAgICAgICAgICAgICA/IGlzQXJyYXkocmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxuICAgICAgICAgICAgOiByZWYsXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXG4gICAgICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBjaGlsZHJlbjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhdGNoRmxhZyA9PT0gLTEgLyogUGF0Y2hGbGFncy5IT0lTVEVEICovICYmIGlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSlcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXG4gICAgICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgICAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAgICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cbiAgICAgICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgICAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxuICAgICAgICAgICAgICAgID8gMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXG4gICAgICAgICAgICAgICAgOiBwYXRjaEZsYWcgfCAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi9cbiAgICAgICAgICAgIDogcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgICAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgICAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICAgICAgZWw6IHZub2RlLmVsLFxuICAgICAgICBhbmNob3I6IHZub2RlLmFuY2hvcixcbiAgICAgICAgY3R4OiB2bm9kZS5jdHgsXG4gICAgICAgIGNlOiB2bm9kZS5jZVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbi8qKlxuICogRGV2IG9ubHksIGZvciBITVIgb2YgaG9pc3RlZCB2bm9kZXMgcmV1c2VkIGluIHYtZm9yXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzIwMjJcbiAqL1xuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSAnICcsIGZsYWcgPSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XG4gICAgLy8gQSBzdGF0aWMgdm5vZGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgc3RyaW5naWZpZWQgZWxlbWVudHMsIGFuZCB0aGUgbnVtYmVyXG4gICAgLy8gb2YgZWxlbWVudHMgaXMgbmVjZXNzYXJ5IGZvciBoeWRyYXRpb24uXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xuICAgIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgICByZXR1cm4gdm5vZGU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gJycsIFxuLy8gd2hlbiB1c2VkIGFzIHRoZSB2LWVsc2UgYnJhbmNoLCB0aGUgY29tbWVudCBub2RlIG11c3QgYmUgY3JlYXRlZCBhcyBhXG4vLyBibG9jayB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzLlxuYXNCbG9jayA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGFzQmxvY2tcbiAgICAgICAgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKVxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09ICdib29sZWFuJykge1xuICAgICAgICAvLyBlbXB0eSBwbGFjZWhvbGRlclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIC8vIGZyYWdtZW50XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShGcmFnbWVudCwgbnVsbCwgXG4gICAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgICBjaGlsZC5zbGljZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBhbHJlYWR5IHZub2RlLCB0aGlzIHNob3VsZCBiZSB0aGUgbW9zdCBjb21tb24gc2luY2UgY29tcGlsZWQgdGVtcGxhdGVzXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcbiAgICAgICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xuICAgIH1cbn1cbi8vIG9wdGltaXplZCBub3JtYWxpemF0aW9uIGZvciB0ZW1wbGF0ZS1jb21waWxlZCByZW5kZXIgZm5zXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xuICAgIHJldHVybiAoY2hpbGQuZWwgPT09IG51bGwgJiYgY2hpbGQucGF0Y2hGbGFnICE9PSAtMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi8pIHx8XG4gICAgICAgIGNoaWxkLm1lbW9cbiAgICAgICAgPyBjaGlsZFxuICAgICAgICA6IGNsb25lVk5vZGUoY2hpbGQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XG4gICAgbGV0IHR5cGUgPSAwO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHR5cGUgPSAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gfCA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovKSkge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHNsb3QgdG8gcGxhaW4gY2hpbGRyZW4gZm9yIHBsYWluIGVsZW1lbnQgYW5kIFRlbGVwb3J0XG4gICAgICAgICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcbiAgICAgICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICAgICAgLy8gX2MgbWFya2VyIGlzIGFkZGVkIGJ5IHdpdGhDdHgoKSBpbmRpY2F0aW5nIHRoaXMgaXMgYSBjb21waWxlZCBzbG90XG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gMzIgLyogU2hhcGVGbGFncy5TTE9UU19DSElMRFJFTiAqLztcbiAgICAgICAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqLyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBhIGNoaWxkIGNvbXBvbmVudCByZWNlaXZlcyBmb3J3YXJkZWQgc2xvdHMgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMiAvKiBTbG90RmxhZ3MuRFlOQU1JQyAqLztcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgICAgICB0eXBlID0gMzIgLyogU2hhcGVGbGFncy5TTE9UU19DSElMRFJFTiAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgLy8gZm9yY2UgdGVsZXBvcnQgY2hpbGRyZW4gdG8gYXJyYXkgc28gaXQgY2FuIGJlIG1vdmVkIGFyb3VuZFxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi87XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jb21pbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcgIT09IGluY29taW5nICYmXG4gICAgICAgICAgICAgICAgICAgICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluY29taW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3IC8qIEVycm9yQ29kZXMuVk5PREVfSE9PSyAqLywgW1xuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgXSk7XG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcbiAgICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcbiAgICAvLyBpbmhlcml0IHBhcmVudCBhcHAgY29udGV4dCAtIG9yIC0gaWYgcm9vdCwgYWRvcHQgZnJvbSByb290IHZub2RlXG4gICAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgICAgdWlkOiB1aWQrKyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgYXBwQ29udGV4dCxcbiAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcbiAgICAgICAgZWZmZWN0OiBudWxsLFxuICAgICAgICB1cGRhdGU6IG51bGwsXG4gICAgICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyksXG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgcHJveHk6IG51bGwsXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXG4gICAgICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgICAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgICAgICAvLyBlbWl0XG4gICAgICAgIGVtaXQ6IG51bGwsXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxuICAgICAgICAvLyBpbmhlcml0QXR0cnNcbiAgICAgICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgY3R4OiBFTVBUWV9PQkosXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcbiAgICAgICAgcHJvcHM6IEVNUFRZX09CSixcbiAgICAgICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcbiAgICAgICAgcmVmczogRU1QVFlfT0JKLFxuICAgICAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgICAgICBhc3luY0RlcDogbnVsbCxcbiAgICAgICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgICBiYzogbnVsbCxcbiAgICAgICAgYzogbnVsbCxcbiAgICAgICAgYm06IG51bGwsXG4gICAgICAgIG06IG51bGwsXG4gICAgICAgIGJ1OiBudWxsLFxuICAgICAgICB1OiBudWxsLFxuICAgICAgICB1bTogbnVsbCxcbiAgICAgICAgYnVtOiBudWxsLFxuICAgICAgICBkYTogbnVsbCxcbiAgICAgICAgYTogbnVsbCxcbiAgICAgICAgcnRnOiBudWxsLFxuICAgICAgICBydGM6IG51bGwsXG4gICAgICAgIGVjOiBudWxsLFxuICAgICAgICBzcDogbnVsbFxuICAgIH07XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgICB9XG4gICAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gICAgLy8gYXBwbHkgY3VzdG9tIGVsZW1lbnQgc3BlY2lhbCBoYW5kbGluZ1xuICAgIGlmICh2bm9kZS5jZSkge1xuICAgICAgICB2bm9kZS5jZShpbnN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XG59O1xuY29uc3QgdW5zZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiB7XG4gICAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xufTtcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcbiAgICBjb25zdCBhcHBJc05hdGl2ZVRhZyA9IGNvbmZpZy5pc05hdGl2ZVRhZyB8fCBOTztcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6ICcgKyBuYW1lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi87XG59XG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGlzU1NSO1xuICAgIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XG4gICAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xuICAgIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bFxuICAgICAgICA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbiAgICByZXR1cm4gc2V0dXBSZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgICAgICAgIHdhcm4oYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGAgK1xuICAgICAgICAgICAgICAgIGBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBgICtcbiAgICAgICAgICAgICAgICBgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAwLiBjcmVhdGUgcmVuZGVyIHByb3h5IHByb3BlcnR5IGFjY2VzcyBjYWNoZVxuICAgIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvLyAxLiBjcmVhdGUgcHVibGljIGluc3RhbmNlIC8gcmVuZGVyIHByb3h5XG4gICAgLy8gYWxzbyBtYXJrIGl0IHJhdyBzbyBpdCdzIG5ldmVyIG9ic2VydmVkXG4gICAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgICAvLyAyLiBjYWxsIHNldHVwKClcbiAgICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gICAgaWYgKHNldHVwKSB7XG4gICAgICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IChpbnN0YW5jZS5zZXR1cENvbnRleHQgPVxuICAgICAgICAgICAgc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsKTtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzZXR1cCwgaW5zdGFuY2UsIDAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqLywgWyhwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XSk7XG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmIChpc1NTUikge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqLyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxuICAgICAgICAgICAgICAgIC8vIGJhaWwgaGVyZSBhbmQgd2FpdCBmb3IgcmUtZW50cnkuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdBbm9ueW1vdXMnO1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZnVuY3Rpb24ncyBuYW1lIGlzIGBzc3JSZW5kZXJgIChjb21waWxlZCBieSBTRkMgaW5saW5lIG1vZGUpLFxuICAgICAgICAgICAgLy8gc2V0IGl0IGFzIHNzclJlbmRlciBpbnN0ZWFkLlxuICAgICAgICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSBgICtcbiAgICAgICAgICAgICAgICBgcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYmluZGluZ3MuXG4gICAgICAgIC8vIGFzc3VtaW5nIGEgcmVuZGVyIGZ1bmN0aW9uIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaXMgcHJlc2VudC5cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcbiAgICB9XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbn1cbmxldCBjb21waWxlO1xubGV0IGluc3RhbGxXaXRoUHJveHk7XG4vKipcbiAqIEZvciBydW50aW1lLWRvbSB0byByZWdpc3RlciB0aGUgY29tcGlsZXIuXG4gKiBOb3RlIHRoZSBleHBvcnRlZCBtZXRob2QgdXNlcyBhbnkgdG8gYXZvaWQgZC50cyByZWx5aW5nIG9uIHRoZSBjb21waWxlciB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgICBjb21waWxlID0gX2NvbXBpbGU7XG4gICAgaW5zdGFsbFdpdGhQcm94eSA9IGkgPT4ge1xuICAgICAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICAgICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBkZXYgb25seVxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gICAgLy8gdGVtcGxhdGUgLyByZW5kZXIgZnVuY3Rpb24gbm9ybWFsaXphdGlvblxuICAgIC8vIGNvdWxkIGJlIGFscmVhZHkgc2V0IHdoZW4gcmV0dXJuZWQgZnJvbSBzZXR1cCgpXG4gICAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcbiAgICAgICAgLy8gb25seSBkbyBvbi10aGUtZmx5IGNvbXBpbGUgaWYgbm90IGluIFNTUiAtIFNTUiBvbi10aGUtZmx5IGNvbXBpbGF0aW9uXG4gICAgICAgIC8vIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlcmVyXG4gICAgICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGUgfHxcbiAgICAgICAgICAgICAgICByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkudGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgICAgIH0sIGNvbXBpbGVyT3B0aW9ucyksIGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xuICAgICAgICAvLyBmb3IgcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9ja3MsIHRoZSByZW5kZXJcbiAgICAgICAgLy8gcHJveHkgdXNlZCBuZWVkcyBhIGRpZmZlcmVudCBgaGFzYCBoYW5kbGVyIHdoaWNoIGlzIG1vcmUgcGVyZm9ybWFudCBhbmRcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxuICAgICAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xuICAgICAgICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKGZhbHNlICkpIHtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgfVxuICAgIC8vIHdhcm4gbWlzc2luZyB0ZW1wbGF0ZS9yZW5kZXJcbiAgICAvLyB0aGUgcnVudGltZSBjb21waWxhdGlvbiBvZiB0ZW1wbGF0ZSBpbiBTU1IgaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgK1xuICAgICAgICAgICAgICAgIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmBcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCAnJGF0dHJzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCAnJGF0dHJzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xuICAgIGNvbnN0IGV4cG9zZSA9IGV4cG9zZWQgPT4ge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cG9zZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICAgICAgICAgIGlmIChleHBvc2VkVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSAncmVmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcbiAgICB9O1xuICAgIGxldCBhdHRycztcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIC8vIFdlIHVzZSBnZXR0ZXJzIGluIGRldiBpbiBjYXNlIGxpYnMgbGlrZSB0ZXN0LXV0aWxzIG92ZXJ3cml0ZSBpbnN0YW5jZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzIHx8IChhdHRycyA9IGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5zbG90cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnMgfHwgKGF0dHJzID0gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcbiAgICAgICAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXG4gICAgICAgICAgICBleHBvc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHJldHVybiAoaW5zdGFuY2UuZXhwb3NlUHJveHkgfHxcbiAgICAgICAgICAgIChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldCB8fCBrZXkgaW4gcHVibGljUHJvcGVydGllc01hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbn1cbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csICcnKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KVxuICAgICAgICA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZVxuICAgICAgICA6IENvbXBvbmVudC5uYW1lIHx8IChpbmNsdWRlSW5mZXJyZWQgJiYgQ29tcG9uZW50Ll9fbmFtZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xuICAgIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xuICAgIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICAgIC8vIHRyeSB0byBpbmZlciB0aGUgbmFtZSBiYXNlZCBvbiByZXZlcnNlIHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbmFtZSA9XG4gICAgICAgICAgICBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5jb21wb25lbnRzIHx8XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50cykgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XG59XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmICdfX3ZjY09wdHMnIGluIHZhbHVlO1xufVxuXG5jb25zdCBjb21wdXRlZCA9ICgoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG59KTtcblxuLy8gZGV2IG9ubHlcbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuKGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIGAgK1xuICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXG4gICAgYGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmApO1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogVnVlIGA8c2NyaXB0IHNldHVwPmAgY29tcGlsZXIgbWFjcm8gZm9yIGRlY2xhcmluZyBhIGNvbXBvbmVudCdzIGV4cG9zZWRcbiAqIGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBpdCBpcyBhY2Nlc3NlZCBieSBhIHBhcmVudCBjb21wb25lbnQgdmlhIHRlbXBsYXRlXG4gKiByZWZzLlxuICpcbiAqIGA8c2NyaXB0IHNldHVwPmAgY29tcG9uZW50cyBhcmUgY2xvc2VkIGJ5IGRlZmF1bHQgLSBpLmUuIHZhcmlhYmxlcyBpbnNpZGVcbiAqIHRoZSBgPHNjcmlwdCBzZXR1cD5gIHNjb3BlIGlzIG5vdCBleHBvc2VkIHRvIHBhcmVudCB1bmxlc3MgZXhwbGljaXRseSBleHBvc2VkXG4gKiB2aWEgYGRlZmluZUV4cG9zZWAuXG4gKlxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGVcbiAqIG91dHB1dCBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcbiAgICB9XG59XG4vKipcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBwcm92aWRpbmcgcHJvcHMgZGVmYXVsdCB2YWx1ZXMgd2hlblxuICogdXNpbmcgdHlwZS1iYXNlZCBgZGVmaW5lUHJvcHNgIGRlY2xhcmF0aW9uLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiBgYGB0c1xuICogd2l0aERlZmF1bHRzKGRlZmluZVByb3BzPHtcbiAqICAgc2l6ZT86IG51bWJlclxuICogICBsYWJlbHM/OiBzdHJpbmdbXVxuICogfT4oKSwge1xuICogICBzaXplOiAzLFxuICogICBsYWJlbHM6ICgpID0+IFsnZGVmYXVsdCBsYWJlbCddXG4gKiB9KVxuICogYGBgXG4gKlxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGUgb3V0cHV0XG4gKiBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaSkge1xuICAgICAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIH1cbiAgICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcbn1cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcbiAqIG9ubHkuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBpc0FycmF5KHJhdylcbiAgICAgICAgPyByYXcucmVkdWNlKChub3JtYWxpemVkLCBwKSA9PiAoKG5vcm1hbGl6ZWRbcF0gPSB7fSksIG5vcm1hbGl6ZWQpLCB7fSlcbiAgICAgICAgOiByYXc7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIHByb3h5IGZvciB0aGUgcmVzdCBlbGVtZW50IHdoZW4gZGVzdHJ1Y3R1cmluZyBwcm9wcyB3aXRoXG4gKiBkZWZpbmVQcm9wcygpLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogYDxzY3JpcHQgc2V0dXA+YCBoZWxwZXIgZm9yIHBlcnNpc3RpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2UgY29udGV4dCBvdmVyXG4gKiBhc3luYy9hd2FpdCBmbG93cy5cbiAqXG4gKiBgQHZ1ZS9jb21waWxlci1zZmNgIGNvbnZlcnRzIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHggPSBhd2FpdCBmb28oKVxuICogYGBgXG4gKlxuICogaW50bzpcbiAqXG4gKiBgYGB0c1xuICogbGV0IF9fdGVtcCwgX19yZXN0b3JlXG4gKiBjb25zdCB4ID0gKChbX190ZW1wLCBfX3Jlc3RvcmVdID0gd2l0aEFzeW5jQ29udGV4dCgoKSA9PiBmb28oKSkpLF9fdGVtcD1hd2FpdCBfX3RlbXAsX19yZXN0b3JlKCksX190ZW1wKVxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjdHgpIHtcbiAgICAgICAgd2Fybihgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gYCArXG4gICAgICAgICAgICBgVGhpcyBpcyBsaWtlbHkgYSBidWcuYCk7XG4gICAgfVxuICAgIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xuICAgICAgICBhd2FpdGFibGUgPSBhd2FpdGFibGUuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xufVxuXG4vLyBBY3R1YWwgaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsID09PSAyKSB7XG4gICAgICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2bm9kZSB3aXRob3V0IHByb3BzXG4gICAgICAgICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3BzIHdpdGhvdXQgY2hpbGRyZW5cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChsID4gMykge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XG4gICAgfVxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzc3JDb250ZXh0YCA6IGBgKTtcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XG4gICAge1xuICAgICAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi9dKTtcbn1cblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMzYmE3NzYnIH07XG4gICAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzBiMWJjOScgfTtcbiAgICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojYjYyZTI0JyB9O1xuICAgIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojOWQyODhjJyB9O1xuICAgIC8vIGN1c3RvbSBmb3JtYXR0ZXIgZm9yIENocm9tZVxuICAgIC8vIGh0dHBzOi8vd3d3Lm1hdHR6ZXVuZXJ0LmNvbS8yMDE2LzAyLzE5L2N1c3RvbS1jaHJvbWUtZGV2dG9vbHMtb2JqZWN0LWZvcm1hdHRlcnMuaHRtbFxuICAgIGNvbnN0IGZvcm1hdHRlciA9IHtcbiAgICAgICAgaGVhZGVyKG9iaikge1xuICAgICAgICAgICAgLy8gVE9ETyBhbHNvIGZvcm1hdCBDb21wb25lbnRQdWJsaWNJbnN0YW5jZSAmIGN0eC5zbG90cy9hdHRycyBpbiBzZXR1cFxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBgPmBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWN0aXZlJyA6ICdSZWFjdGl2ZSddLFxuICAgICAgICAgICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/ICdTaGFsbG93UmVhZG9ubHknIDogJ1JlYWRvbmx5J10sXG4gICAgICAgICAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICAgICAgICAgICAgJz4nXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBoYXNCb2R5KG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgYm9keShvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygncHJvcHMnLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdzZXR1cCcsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdkYXRhJywgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnY29tcHV0ZWQnKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdjb21wdXRlZCcsIGNvbXB1dGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2luamVjdCcpO1xuICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2luamVjdGVkJywgaW5qZWN0ZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3MucHVzaChbXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyAnO29wYWNpdHk6MC42NidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckIChpbnRlcm5hbCk6ICdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbJ29iamVjdCcsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywge31dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgc3R5bGU6ICdsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbScgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29sb3I6IzQ3NjU4MidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3BhZGRpbmctbGVmdDoxLjI1ZW0nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIGtleXdvcmRTdHlsZSwga2V5ICsgJzogJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBudW1iZXJTdHlsZSwgdl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywga2V5d29yZFN0eWxlLCB2XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnb2JqZWN0JywgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcbiAgICAgICAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XG4gICAgICAgIGlmICgoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XG4gICAgICAgICAgICAoaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUobSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XG4gICAgICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgICAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYuZWZmZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFJlZmA7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gICAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcmVuZGVyKCk7XG4gICAgLy8gc2hhbGxvdyBjbG9uZVxuICAgIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xuICAgIHJldHVybiAoY2FjaGVbaW5kZXhdID0gcmV0KTtcbn1cbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XG4gICAgY29uc3QgcHJldiA9IGNhY2hlZC5tZW1vO1xuICAgIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byBsZXQgcGFyZW50IGJsb2NrIHRyYWNrIGl0IHdoZW4gcmV0dXJuaW5nIGNhY2hlZFxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQ29yZSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCB2ZXJzaW9uID0gXCIzLjIuNDdcIjtcbmNvbnN0IF9zc3JVdGlscyA9IHtcbiAgICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgICBzZXR1cENvbXBvbmVudCxcbiAgICByZW5kZXJDb21wb25lbnRSb290LFxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgICBpc1ZOb2RlLFxuICAgIG5vcm1hbGl6ZVZOb2RlXG59O1xuLyoqXG4gKiBTU1IgdXRpbHMgZm9yIFxcQHZ1ZS9zZXJ2ZXItcmVuZGVyZXIuIE9ubHkgZXhwb3NlZCBpbiBzc3ItcG9zc2libGUgYnVpbGRzLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHNzclV0aWxzID0gKF9zc3JVdGlscyApO1xuLyoqXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHNcbiAqL1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG4vKipcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkcy5cbiAqL1xuY29uc3QgY29tcGF0VXRpbHMgPSAobnVsbCk7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVQcm9wcywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiJdLCJuYW1lcyI6WyJwYXVzZVRyYWNraW5nIiwicmVzZXRUcmFja2luZyIsImlzUmVmIiwidG9SYXciLCJnZXRDdXJyZW50U2NvcGUiLCJpc1NoYWxsb3ciLCJpc1NoYWxsb3ckMSIsImlzUmVhY3RpdmUiLCJSZWFjdGl2ZUVmZmVjdCIsInJlZiIsInNoYWxsb3dSZWFkb25seSIsInRyYWNrIiwicmVhY3RpdmUiLCJzaGFsbG93UmVhY3RpdmUiLCJ0cmlnZ2VyIiwiaXNQcm94eSIsInByb3h5UmVmcyIsIm1hcmtSYXciLCJFZmZlY3RTY29wZSIsImNvbXB1dGVkIiwiY29tcHV0ZWQkMSIsImlzUmVhZG9ubHkiLCJjdXN0b21SZWYiLCJlZmZlY3QiLCJlZmZlY3RTY29wZSIsIm9uU2NvcGVEaXNwb3NlIiwicmVhZG9ubHkiLCJzaGFsbG93UmVmIiwic3RvcCIsInRvUmVmIiwidG9SZWZzIiwidHJpZ2dlclJlZiIsInVucmVmIiwiaXNTdHJpbmciLCJpc0Z1bmN0aW9uIiwiaXNQcm9taXNlIiwiaXNBcnJheSIsIk5PT1AiLCJnZXRHbG9iYWxUaGlzIiwiZXh0ZW5kIiwiRU1QVFlfT0JKIiwidG9IYW5kbGVyS2V5IiwibG9vc2VUb051bWJlciIsImh5cGhlbmF0ZSIsImNhbWVsaXplIiwiaXNPYmplY3QiLCJpc09uIiwiaGFzT3duIiwiaXNNb2RlbExpc3RlbmVyIiwidG9OdW1iZXIiLCJoYXNDaGFuZ2VkIiwicmVtb3ZlIiwiaXNTZXQiLCJpc01hcCIsImlzUGxhaW5PYmplY3QiLCJpbnZva2VBcnJheUZucyIsImlzUmVnRXhwIiwiaXNCdWlsdEluRGlyZWN0aXZlIiwiY2FwaXRhbGl6ZSIsImlzR2xvYmFsbHlXaGl0ZWxpc3RlZCIsImRlZiIsImlzUmVzZXJ2ZWRQcm9wIiwiRU1QVFlfQVJSIiwidG9SYXdUeXBlIiwibWFrZU1hcCIsIk5PIiwibm9ybWFsaXplQ2xhc3MiLCJub3JtYWxpemVTdHlsZSIsIm5vcm1hbGl6ZVByb3BzIiwidG9EaXNwbGF5U3RyaW5nIiwic3RhY2siLCJwdXNoV2FybmluZ0NvbnRleHQiLCJ2bm9kZSIsInB1c2giLCJwb3BXYXJuaW5nQ29udGV4dCIsInBvcCIsIndhcm4iLCJtc2ciLCJhcmdzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaW5zdGFuY2UiLCJsZW5ndGgiLCJjb21wb25lbnQiLCJhcHBXYXJuSGFuZGxlciIsImFwcENvbnRleHQiLCJjb25maWciLCJ3YXJuSGFuZGxlciIsInRyYWNlIiwiZ2V0Q29tcG9uZW50VHJhY2UiLCJjYWxsV2l0aEVycm9ySGFuZGxpbmciLCJqb2luIiwicHJveHkiLCJtYXAiLCJmb3JtYXRDb21wb25lbnROYW1lIiwidHlwZSIsIndhcm5BcmdzIiwiZm9ybWF0VHJhY2UiLCJjb25zb2xlIiwiY3VycmVudFZOb2RlIiwibm9ybWFsaXplZFN0YWNrIiwibGFzdCIsInJlY3Vyc2VDb3VudCIsInBhcmVudEluc3RhbmNlIiwicGFyZW50IiwibG9ncyIsImZvckVhY2giLCJlbnRyeSIsImkiLCJmb3JtYXRUcmFjZUVudHJ5IiwicG9zdGZpeCIsImlzUm9vdCIsIm9wZW4iLCJjbG9zZSIsInByb3BzIiwiZm9ybWF0UHJvcHMiLCJyZXMiLCJrZXlzIiwiT2JqZWN0Iiwic2xpY2UiLCJrZXkiLCJmb3JtYXRQcm9wIiwidmFsdWUiLCJyYXciLCJKU09OIiwic3RyaW5naWZ5IiwibmFtZSIsImFzc2VydE51bWJlciIsInZhbCIsInVuZGVmaW5lZCIsImlzTmFOIiwiRXJyb3JUeXBlU3RyaW5ncyIsImZuIiwiZXJyIiwiaGFuZGxlRXJyb3IiLCJjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyIsImNhdGNoIiwidmFsdWVzIiwidGhyb3dJbkRldiIsImNvbnRleHRWTm9kZSIsImN1ciIsImV4cG9zZWRJbnN0YW5jZSIsImVycm9ySW5mbyIsImVycm9yQ2FwdHVyZWRIb29rcyIsImVjIiwiYXBwRXJyb3JIYW5kbGVyIiwiZXJyb3JIYW5kbGVyIiwibG9nRXJyb3IiLCJpbmZvIiwiZXJyb3IiLCJpc0ZsdXNoaW5nIiwiaXNGbHVzaFBlbmRpbmciLCJxdWV1ZSIsImZsdXNoSW5kZXgiLCJwZW5kaW5nUG9zdEZsdXNoQ2JzIiwiYWN0aXZlUG9zdEZsdXNoQ2JzIiwicG9zdEZsdXNoSW5kZXgiLCJyZXNvbHZlZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImN1cnJlbnRGbHVzaFByb21pc2UiLCJSRUNVUlNJT05fTElNSVQiLCJuZXh0VGljayIsInAiLCJ0aGVuIiwiYmluZCIsImZpbmRJbnNlcnRpb25JbmRleCIsImlkIiwic3RhcnQiLCJlbmQiLCJtaWRkbGUiLCJtaWRkbGVKb2JJZCIsImdldElkIiwicXVldWVKb2IiLCJqb2IiLCJpbmNsdWRlcyIsImFsbG93UmVjdXJzZSIsInNwbGljZSIsInF1ZXVlRmx1c2giLCJmbHVzaEpvYnMiLCJpbnZhbGlkYXRlSm9iIiwiaW5kZXhPZiIsInF1ZXVlUG9zdEZsdXNoQ2IiLCJjYiIsImZsdXNoUHJlRmx1c2hDYnMiLCJzZWVuIiwiTWFwIiwicHJlIiwiY2hlY2tSZWN1cnNpdmVVcGRhdGVzIiwiZmx1c2hQb3N0Rmx1c2hDYnMiLCJkZWR1cGVkIiwiU2V0Iiwic29ydCIsImEiLCJiIiwiSW5maW5pdHkiLCJjb21wYXJhdG9yIiwiZGlmZiIsImNoZWNrIiwiYWN0aXZlIiwiaGFzIiwic2V0IiwiY291bnQiLCJnZXQiLCJvd25lckluc3RhbmNlIiwiY29tcG9uZW50TmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJpc0htclVwZGF0aW5nIiwiaG1yRGlydHlDb21wb25lbnRzIiwiX19WVUVfSE1SX1JVTlRJTUVfXyIsImNyZWF0ZVJlY29yZCIsInRyeVdyYXAiLCJyZXJlbmRlciIsInJlbG9hZCIsInJlZ2lzdGVySE1SIiwiX19obXJJZCIsInJlY29yZCIsImluc3RhbmNlcyIsImFkZCIsInVucmVnaXN0ZXJITVIiLCJkZWxldGUiLCJpbml0aWFsRGVmIiwibm9ybWFsaXplQ2xhc3NDb21wb25lbnQiLCJpc0NsYXNzQ29tcG9uZW50IiwiX192Y2NPcHRzIiwibmV3UmVuZGVyIiwicmVuZGVyIiwicmVuZGVyQ2FjaGUiLCJ1cGRhdGUiLCJuZXdDb21wIiwidXBkYXRlQ29tcG9uZW50RGVmIiwib2xkQ29tcCIsIm9wdGlvbnNDYWNoZSIsImNlUmVsb2FkIiwic3R5bGVzIiwid2luZG93IiwibG9jYXRpb24iLCJhcmciLCJlIiwiZGV2dG9vbHMiLCJidWZmZXIiLCJkZXZ0b29sc05vdEluc3RhbGxlZCIsImVtaXQkMSIsImV2ZW50IiwiZW1pdCIsInNldERldnRvb2xzSG9vayIsImhvb2siLCJ0YXJnZXQiLCJfYSIsIl9iIiwiZW5hYmxlZCIsIkhUTUxFbGVtZW50IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicmVwbGF5IiwiX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyIsIm5ld0hvb2siLCJzZXRUaW1lb3V0IiwiZGV2dG9vbHNJbml0QXBwIiwiYXBwIiwidmVyc2lvbiIsIkZyYWdtZW50IiwiVGV4dCIsIkNvbW1lbnQiLCJTdGF0aWMiLCJkZXZ0b29sc1VubW91bnRBcHAiLCJkZXZ0b29sc0NvbXBvbmVudEFkZGVkIiwiY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rIiwiZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkIiwiX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCIsImRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCIsImNsZWFudXBCdWZmZXIiLCJ1aWQiLCJkZXZ0b29sc1BlcmZTdGFydCIsImNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rIiwiZGV2dG9vbHNQZXJmRW5kIiwidGltZSIsImRldnRvb2xzQ29tcG9uZW50RW1pdCIsInBhcmFtcyIsInJhd0FyZ3MiLCJpc1VubW91bnRlZCIsImVtaXRzT3B0aW9ucyIsInByb3BzT3B0aW9ucyIsInZhbGlkYXRvciIsImlzVmFsaWQiLCJzdGFydHNXaXRoIiwibW9kZWxBcmciLCJtb2RpZmllcnNLZXkiLCJudW1iZXIiLCJ0cmltIiwiX19WVUVfUFJPRF9ERVZUT09MU19fIiwibG93ZXJDYXNlRXZlbnQiLCJ0b0xvd2VyQ2FzZSIsImhhbmRsZXJOYW1lIiwiaGFuZGxlciIsIm9uY2VIYW5kbGVyIiwiZW1pdHRlZCIsIm5vcm1hbGl6ZUVtaXRzT3B0aW9ucyIsImNvbXAiLCJhc01peGluIiwiY2FjaGUiLCJlbWl0c0NhY2hlIiwiY2FjaGVkIiwiZW1pdHMiLCJub3JtYWxpemVkIiwiaGFzRXh0ZW5kcyIsIl9fVlVFX09QVElPTlNfQVBJX18iLCJleHRlbmRFbWl0cyIsIm5vcm1hbGl6ZWRGcm9tRXh0ZW5kIiwibWl4aW5zIiwiZXh0ZW5kcyIsImlzRW1pdExpc3RlbmVyIiwib3B0aW9ucyIsInJlcGxhY2UiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJjdXJyZW50U2NvcGVJZCIsInNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInByZXYiLCJfX3Njb3BlSWQiLCJwdXNoU2NvcGVJZCIsInBvcFNjb3BlSWQiLCJ3aXRoU2NvcGVJZCIsIl9pZCIsIndpdGhDdHgiLCJjdHgiLCJpc05vblNjb3BlZFNsb3QiLCJfbiIsInJlbmRlckZuV2l0aENvbnRleHQiLCJfZCIsInNldEJsb2NrVHJhY2tpbmciLCJwcmV2SW5zdGFuY2UiLCJfYyIsImFjY2Vzc2VkQXR0cnMiLCJtYXJrQXR0cnNBY2Nlc3NlZCIsInJlbmRlckNvbXBvbmVudFJvb3QiLCJDb21wb25lbnQiLCJ3aXRoUHJveHkiLCJzbG90cyIsImF0dHJzIiwiZGF0YSIsInNldHVwU3RhdGUiLCJpbmhlcml0QXR0cnMiLCJyZXN1bHQiLCJmYWxsdGhyb3VnaEF0dHJzIiwic2hhcGVGbGFnIiwicHJveHlUb1VzZSIsIm5vcm1hbGl6ZVZOb2RlIiwiY2FsbCIsImdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCIsImJsb2NrU3RhY2siLCJjcmVhdGVWTm9kZSIsInJvb3QiLCJzZXRSb290IiwicGF0Y2hGbGFnIiwiZ2V0Q2hpbGRSb290Iiwic29tZSIsImZpbHRlck1vZGVsTGlzdGVuZXJzIiwiY2xvbmVWTm9kZSIsImFsbEF0dHJzIiwiZXZlbnRBdHRycyIsImV4dHJhQXR0cnMiLCJsIiwiZGlycyIsImlzRWxlbWVudFJvb3QiLCJjb25jYXQiLCJ0cmFuc2l0aW9uIiwicmF3Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImR5bmFtaWNDaGlsZHJlbiIsImNoaWxkUm9vdCIsImZpbHRlclNpbmdsZVJvb3QiLCJpbmRleCIsImR5bmFtaWNJbmRleCIsInVwZGF0ZWRSb290Iiwic2luZ2xlUm9vdCIsImNoaWxkIiwiaXNWTm9kZSIsInNob3VsZFVwZGF0ZUNvbXBvbmVudCIsInByZXZWTm9kZSIsIm5leHRWTm9kZSIsIm9wdGltaXplZCIsInByZXZQcm9wcyIsInByZXZDaGlsZHJlbiIsIm5leHRQcm9wcyIsIm5leHRDaGlsZHJlbiIsImhhc1Byb3BzQ2hhbmdlZCIsImR5bmFtaWNQcm9wcyIsIiRzdGFibGUiLCJuZXh0S2V5cyIsInVwZGF0ZUhPQ0hvc3RFbCIsImVsIiwic3ViVHJlZSIsImlzU3VzcGVuc2UiLCJfX2lzU3VzcGVuc2UiLCJTdXNwZW5zZUltcGwiLCJuMSIsIm4yIiwiY29udGFpbmVyIiwiYW5jaG9yIiwicGFyZW50Q29tcG9uZW50IiwicGFyZW50U3VzcGVuc2UiLCJpc1NWRyIsInNsb3RTY29wZUlkcyIsInJlbmRlcmVySW50ZXJuYWxzIiwibW91bnRTdXNwZW5zZSIsInBhdGNoU3VzcGVuc2UiLCJoeWRyYXRlIiwiaHlkcmF0ZVN1c3BlbnNlIiwiY3JlYXRlIiwiY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSIsIm5vcm1hbGl6ZSIsIm5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4iLCJTdXNwZW5zZSIsInRyaWdnZXJFdmVudCIsImV2ZW50TGlzdGVuZXIiLCJwYXRjaCIsIm8iLCJjcmVhdGVFbGVtZW50IiwiaGlkZGVuQ29udGFpbmVyIiwic3VzcGVuc2UiLCJwZW5kaW5nQnJhbmNoIiwic3NDb250ZW50IiwiZGVwcyIsInNzRmFsbGJhY2siLCJzZXRBY3RpdmVCcmFuY2giLCJ1bSIsInVubW91bnQiLCJuZXdCcmFuY2giLCJuZXdGYWxsYmFjayIsImFjdGl2ZUJyYW5jaCIsImlzSW5GYWxsYmFjayIsImlzSHlkcmF0aW5nIiwiaXNTYW1lVk5vZGVUeXBlIiwicGVuZGluZ0lkIiwiZWZmZWN0cyIsInRpbWVvdXQiLCJmYWxsYmFjayIsImhhc1dhcm5lZCIsIm0iLCJtb3ZlIiwibiIsIm5leHQiLCJwYXJlbnROb2RlIiwicmVzdW1lIiwiRXJyb3IiLCJkZWxheUVudGVyIiwibW9kZSIsImFmdGVyTGVhdmUiLCJoYXNVbnJlc29sdmVkQW5jZXN0b3IiLCJmYWxsYmFja1ZOb2RlIiwibW91bnRGYWxsYmFjayIsInJlZ2lzdGVyRGVwIiwic2V0dXBSZW5kZXJFZmZlY3QiLCJpc0luUGVuZGluZ1N1c3BlbnNlIiwiaHlkcmF0ZWRFbCIsImFzeW5jRGVwIiwiYXN5bmNTZXR1cFJlc3VsdCIsInN1c3BlbnNlSWQiLCJhc3luY1Jlc29sdmVkIiwiaGFuZGxlU2V0dXBSZXN1bHQiLCJwbGFjZWhvbGRlciIsImRvUmVtb3ZlIiwibm9kZSIsImh5ZHJhdGVOb2RlIiwiZG9jdW1lbnQiLCJpc1Nsb3RDaGlsZHJlbiIsIm5vcm1hbGl6ZVN1c3BlbnNlU2xvdCIsImRlZmF1bHQiLCJzIiwiYmxvY2siLCJ0cmFja0Jsb2NrIiwiaXNCbG9ja1RyZWVFbmFibGVkIiwib3BlbkJsb2NrIiwiY3VycmVudEJsb2NrIiwiY2xvc2VCbG9jayIsInNpbmdsZUNoaWxkIiwiZmlsdGVyIiwiYyIsInF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIiwiYnJhbmNoIiwicHJvdmlkZSIsImN1cnJlbnRJbnN0YW5jZSIsInByb3ZpZGVzIiwicGFyZW50UHJvdmlkZXMiLCJpbmplY3QiLCJkZWZhdWx0VmFsdWUiLCJ0cmVhdERlZmF1bHRBc0ZhY3RvcnkiLCJhcmd1bWVudHMiLCJTdHJpbmciLCJ3YXRjaEVmZmVjdCIsImRvV2F0Y2giLCJ3YXRjaFBvc3RFZmZlY3QiLCJhc3NpZ24iLCJmbHVzaCIsIndhdGNoU3luY0VmZmVjdCIsIklOSVRJQUxfV0FUQ0hFUl9WQUxVRSIsIndhdGNoIiwic291cmNlIiwiaW1tZWRpYXRlIiwiZGVlcCIsIm9uVHJhY2siLCJvblRyaWdnZXIiLCJ3YXJuSW52YWxpZFNvdXJjZSIsInNjb3BlIiwiZ2V0dGVyIiwiZm9yY2VUcmlnZ2VyIiwiaXNNdWx0aVNvdXJjZSIsInRyYXZlcnNlIiwiY2xlYW51cCIsIm9uQ2xlYW51cCIsImJhc2VHZXR0ZXIiLCJvblN0b3AiLCJzc3JDbGVhbnVwIiwiaXNJblNTUkNvbXBvbmVudFNldHVwIiwidXNlU1NSQ29udGV4dCIsIl9fd2F0Y2hlckhhbmRsZXMiLCJvbGRWYWx1ZSIsIkFycmF5IiwiZmlsbCIsIm5ld1ZhbHVlIiwicnVuIiwidiIsInNjaGVkdWxlciIsInF1ZXVlUG9zdFJlbmRlckVmZmVjdCIsInVud2F0Y2giLCJpbnN0YW5jZVdhdGNoIiwicHVibGljVGhpcyIsImNyZWF0ZVBhdGhHZXR0ZXIiLCJzZXRDdXJyZW50SW5zdGFuY2UiLCJ1bnNldEN1cnJlbnRJbnN0YW5jZSIsInBhdGgiLCJzZWdtZW50cyIsInNwbGl0IiwidXNlVHJhbnNpdGlvblN0YXRlIiwic3RhdGUiLCJpc01vdW50ZWQiLCJpc0xlYXZpbmciLCJpc1VubW91bnRpbmciLCJsZWF2aW5nVk5vZGVzIiwib25Nb3VudGVkIiwib25CZWZvcmVVbm1vdW50IiwiVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IiLCJGdW5jdGlvbiIsIkJhc2VUcmFuc2l0aW9uSW1wbCIsImFwcGVhciIsIkJvb2xlYW4iLCJwZXJzaXN0ZWQiLCJvbkJlZm9yZUVudGVyIiwib25FbnRlciIsIm9uQWZ0ZXJFbnRlciIsIm9uRW50ZXJDYW5jZWxsZWQiLCJvbkJlZm9yZUxlYXZlIiwib25MZWF2ZSIsIm9uQWZ0ZXJMZWF2ZSIsIm9uTGVhdmVDYW5jZWxsZWQiLCJvbkJlZm9yZUFwcGVhciIsIm9uQXBwZWFyIiwib25BZnRlckFwcGVhciIsIm9uQXBwZWFyQ2FuY2VsbGVkIiwic2V0dXAiLCJnZXRDdXJyZW50SW5zdGFuY2UiLCJwcmV2VHJhbnNpdGlvbktleSIsImdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiIsImhhc0ZvdW5kIiwicmF3UHJvcHMiLCJlbXB0eVBsYWNlaG9sZGVyIiwiaW5uZXJDaGlsZCIsImdldEtlZXBBbGl2ZUNoaWxkIiwiZW50ZXJIb29rcyIsInJlc29sdmVUcmFuc2l0aW9uSG9va3MiLCJzZXRUcmFuc2l0aW9uSG9va3MiLCJvbGRDaGlsZCIsIm9sZElubmVyQ2hpbGQiLCJ0cmFuc2l0aW9uS2V5Q2hhbmdlZCIsImdldFRyYW5zaXRpb25LZXkiLCJsZWF2aW5nSG9va3MiLCJkZWxheUxlYXZlIiwiZWFybHlSZW1vdmUiLCJkZWxheWVkTGVhdmUiLCJsZWF2aW5nVk5vZGVzQ2FjaGUiLCJnZXRMZWF2aW5nTm9kZXNGb3JUeXBlIiwiX2xlYXZlQ2IiLCJCYXNlVHJhbnNpdGlvbiIsImNhbGxIb29rIiwiY2FsbEFzeW5jSG9vayIsImRvbmUiLCJldmVyeSIsImhvb2tzIiwiYmVmb3JlRW50ZXIiLCJsZWF2aW5nVk5vZGUiLCJlbnRlciIsImFmdGVySG9vayIsImNhbmNlbEhvb2siLCJjYWxsZWQiLCJfZW50ZXJDYiIsImNhbmNlbGxlZCIsImxlYXZlIiwiY2xvbmUiLCJpc0tlZXBBbGl2ZSIsImtlZXBDb21tZW50IiwicGFyZW50S2V5IiwicmV0Iiwia2V5ZWRGcmFnbWVudENvdW50IiwiZGVmaW5lQ29tcG9uZW50IiwiaXNBc3luY1dyYXBwZXIiLCJfX2FzeW5jTG9hZGVyIiwiZGVmaW5lQXN5bmNDb21wb25lbnQiLCJsb2FkZXIiLCJsb2FkaW5nQ29tcG9uZW50IiwiZXJyb3JDb21wb25lbnQiLCJkZWxheSIsInN1c3BlbnNpYmxlIiwib25FcnJvciIsInVzZXJPbkVycm9yIiwicGVuZGluZ1JlcXVlc3QiLCJyZXNvbHZlZENvbXAiLCJyZXRyaWVzIiwicmV0cnkiLCJsb2FkIiwidGhpc1JlcXVlc3QiLCJyZWplY3QiLCJ1c2VyUmV0cnkiLCJ1c2VyRmFpbCIsIl9fZXNNb2R1bGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9fYXN5bmNSZXNvbHZlZCIsImNyZWF0ZUlubmVyQ29tcCIsImxvYWRlZCIsImRlbGF5ZWQiLCJjZSIsIl9faXNLZWVwQWxpdmUiLCJLZWVwQWxpdmVJbXBsIiwiaW5jbHVkZSIsIlJlZ0V4cCIsImV4Y2x1ZGUiLCJtYXgiLCJOdW1iZXIiLCJzaGFyZWRDb250ZXh0IiwicmVuZGVyZXIiLCJjdXJyZW50IiwiX192X2NhY2hlIiwiX3VubW91bnQiLCJzdG9yYWdlQ29udGFpbmVyIiwiYWN0aXZhdGUiLCJpc0RlYWN0aXZhdGVkIiwidm5vZGVIb29rIiwib25Wbm9kZU1vdW50ZWQiLCJpbnZva2VWTm9kZUhvb2siLCJkZWFjdGl2YXRlIiwiZGEiLCJvblZub2RlVW5tb3VudGVkIiwicmVzZXRTaGFwZUZsYWciLCJwcnVuZUNhY2hlIiwicHJ1bmVDYWNoZUVudHJ5IiwibWF0Y2hlcyIsInBlbmRpbmdDYWNoZUtleSIsImNhY2hlU3VidHJlZSIsImdldElubmVyQ2hpbGQiLCJvblVwZGF0ZWQiLCJyYXdWTm9kZSIsImNhY2hlZFZOb2RlIiwic2l6ZSIsInBhcnNlSW50IiwiS2VlcEFsaXZlIiwicGF0dGVybiIsInRlc3QiLCJvbkFjdGl2YXRlZCIsInJlZ2lzdGVyS2VlcEFsaXZlSG9vayIsIm9uRGVhY3RpdmF0ZWQiLCJ3cmFwcGVkSG9vayIsIl9fd2RjIiwiaW5qZWN0SG9vayIsImluamVjdFRvS2VlcEFsaXZlUm9vdCIsImtlZXBBbGl2ZVJvb3QiLCJpbmplY3RlZCIsIm9uVW5tb3VudGVkIiwicHJlcGVuZCIsIl9fd2VoIiwidW5zaGlmdCIsImFwaU5hbWUiLCJjcmVhdGVIb29rIiwibGlmZWN5Y2xlIiwib25CZWZvcmVNb3VudCIsIm9uQmVmb3JlVXBkYXRlIiwib25TZXJ2ZXJQcmVmZXRjaCIsIm9uUmVuZGVyVHJpZ2dlcmVkIiwib25SZW5kZXJUcmFja2VkIiwib25FcnJvckNhcHR1cmVkIiwidmFsaWRhdGVEaXJlY3RpdmVOYW1lIiwid2l0aERpcmVjdGl2ZXMiLCJkaXJlY3RpdmVzIiwiaW50ZXJuYWxJbnN0YW5jZSIsImdldEV4cG9zZVByb3h5IiwiYmluZGluZ3MiLCJkaXIiLCJtb2RpZmllcnMiLCJtb3VudGVkIiwidXBkYXRlZCIsImludm9rZURpcmVjdGl2ZUhvb2siLCJvbGRCaW5kaW5ncyIsImJpbmRpbmciLCJDT01QT05FTlRTIiwiRElSRUNUSVZFUyIsInJlc29sdmVDb21wb25lbnQiLCJtYXliZVNlbGZSZWZlcmVuY2UiLCJyZXNvbHZlQXNzZXQiLCJOVUxMX0RZTkFNSUNfQ09NUE9ORU5UIiwicmVzb2x2ZUR5bmFtaWNDb21wb25lbnQiLCJyZXNvbHZlRGlyZWN0aXZlIiwid2Fybk1pc3NpbmciLCJzZWxmTmFtZSIsImV4dHJhIiwicmVnaXN0cnkiLCJyZW5kZXJMaXN0IiwicmVuZGVySXRlbSIsImlzSW50ZWdlciIsIml0ZXJhdG9yIiwiZnJvbSIsIml0ZW0iLCJjcmVhdGVTbG90cyIsImR5bmFtaWNTbG90cyIsInNsb3QiLCJqIiwicmVuZGVyU2xvdCIsIm5vU2xvdHRlZCIsImlzQ0UiLCJ2YWxpZFNsb3RDb250ZW50IiwiZW5zdXJlVmFsaWRWTm9kZSIsInJlbmRlcmVkIiwiY3JlYXRlQmxvY2siLCJfIiwic2NvcGVJZCIsInZub2RlcyIsInRvSGFuZGxlcnMiLCJvYmoiLCJwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSIsImdldFB1YmxpY0luc3RhbmNlIiwiaXNTdGF0ZWZ1bENvbXBvbmVudCIsInB1YmxpY1Byb3BlcnRpZXNNYXAiLCIkIiwiJGVsIiwiJGRhdGEiLCIkcHJvcHMiLCIkYXR0cnMiLCIkc2xvdHMiLCIkcmVmcyIsInJlZnMiLCIkcGFyZW50IiwiJHJvb3QiLCIkZW1pdCIsIiRvcHRpb25zIiwicmVzb2x2ZU1lcmdlZE9wdGlvbnMiLCIkZm9yY2VVcGRhdGUiLCJmIiwiJG5leHRUaWNrIiwiJHdhdGNoIiwiaXNSZXNlcnZlZFByZWZpeCIsImhhc1NldHVwQmluZGluZyIsIl9faXNTY3JpcHRTZXR1cCIsIlB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyIsImFjY2Vzc0NhY2hlIiwibm9ybWFsaXplZFByb3BzIiwic2hvdWxkQ2FjaGVBY2Nlc3MiLCJwdWJsaWNHZXR0ZXIiLCJjc3NNb2R1bGUiLCJnbG9iYWxQcm9wZXJ0aWVzIiwiX19jc3NNb2R1bGVzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZGVzY3JpcHRvciIsIlJlZmxlY3QiLCJvd25LZXlzIiwiUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzIiwidW5zY29wYWJsZXMiLCJjcmVhdGVEZXZSZW5kZXJDb250ZXh0IiwiZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQiLCJleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0IiwiY3JlYXRlRHVwbGljYXRlQ2hlY2tlciIsImFwcGx5T3B0aW9ucyIsImJlZm9yZUNyZWF0ZSIsImRhdGFPcHRpb25zIiwiY29tcHV0ZWRPcHRpb25zIiwibWV0aG9kcyIsIndhdGNoT3B0aW9ucyIsInByb3ZpZGVPcHRpb25zIiwiaW5qZWN0T3B0aW9ucyIsImNyZWF0ZWQiLCJiZWZvcmVNb3VudCIsImJlZm9yZVVwZGF0ZSIsImFjdGl2YXRlZCIsImRlYWN0aXZhdGVkIiwiYmVmb3JlRGVzdHJveSIsImJlZm9yZVVubW91bnQiLCJkZXN0cm95ZWQiLCJ1bm1vdW50ZWQiLCJyZW5kZXJUcmFja2VkIiwicmVuZGVyVHJpZ2dlcmVkIiwiZXJyb3JDYXB0dXJlZCIsInNlcnZlclByZWZldGNoIiwiZXhwb3NlIiwiY29tcG9uZW50cyIsImZpbHRlcnMiLCJjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMiLCJyZXNvbHZlSW5qZWN0aW9ucyIsInVud3JhcEluamVjdGVkUmVmIiwibWV0aG9kSGFuZGxlciIsIndyaXRhYmxlIiwib3B0IiwiY3JlYXRlV2F0Y2hlciIsInJlZ2lzdGVyTGlmZWN5Y2xlSG9vayIsInJlZ2lzdGVyIiwiX2hvb2siLCJleHBvc2VkIiwidW53cmFwUmVmIiwibm9ybWFsaXplSW5qZWN0IiwiaCIsInIiLCJiYXNlIiwiZXh0ZW5kc09wdGlvbnMiLCJnbG9iYWxNaXhpbnMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJyZXNvbHZlZCIsIm1lcmdlT3B0aW9ucyIsInRvIiwic3RyYXRzIiwic3RyYXQiLCJpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzIiwibWVyZ2VEYXRhRm4iLCJtZXJnZU9iamVjdE9wdGlvbnMiLCJtZXJnZUFzQXJyYXkiLCJtZXJnZVdhdGNoT3B0aW9ucyIsIm1lcmdlSW5qZWN0IiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkIiwiaW5pdFByb3BzIiwiaXNTdGF0ZWZ1bCIsImlzU1NSIiwiSW50ZXJuYWxPYmplY3RLZXkiLCJwcm9wc0RlZmF1bHRzIiwic2V0RnVsbFByb3BzIiwidmFsaWRhdGVQcm9wcyIsImlzSW5IbXJDb250ZXh0IiwidXBkYXRlUHJvcHMiLCJyYXdQcmV2UHJvcHMiLCJyYXdDdXJyZW50UHJvcHMiLCJoYXNBdHRyc0NoYW5nZWQiLCJwcm9wc1RvVXBkYXRlIiwiY2FtZWxpemVkS2V5IiwicmVzb2x2ZVByb3BWYWx1ZSIsImtlYmFiS2V5IiwibmVlZENhc3RLZXlzIiwicmF3Q2FzdFZhbHVlcyIsImNhbWVsS2V5IiwiY2FzdFZhbHVlcyIsImlzQWJzZW50IiwiaGFzRGVmYXVsdCIsIm5vcm1hbGl6ZVByb3BzT3B0aW9ucyIsInByb3BzQ2FjaGUiLCJleHRlbmRQcm9wcyIsIm5vcm1hbGl6ZWRLZXkiLCJ2YWxpZGF0ZVByb3BOYW1lIiwicHJvcCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsInN0cmluZ0luZGV4IiwiZ2V0VHlwZSIsImN0b3IiLCJtYXRjaCIsInRvU3RyaW5nIiwiaXNTYW1lVHlwZSIsImV4cGVjdGVkVHlwZXMiLCJmaW5kSW5kZXgiLCJ0IiwicmVzb2x2ZWRWYWx1ZXMiLCJ2YWxpZGF0ZVByb3AiLCJyZXF1aXJlZCIsInR5cGVzIiwidmFsaWQiLCJleHBlY3RlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZ2V0SW52YWxpZFR5cGVNZXNzYWdlIiwiaXNTaW1wbGVUeXBlIiwibWVzc2FnZSIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsImV4cGxpY2l0VHlwZXMiLCJlbGVtIiwiaXNJbnRlcm5hbEtleSIsIm5vcm1hbGl6ZVNsb3RWYWx1ZSIsIm5vcm1hbGl6ZVNsb3QiLCJyYXdTbG90Iiwibm9ybWFsaXplT2JqZWN0U2xvdHMiLCJyYXdTbG90cyIsIl9jdHgiLCJub3JtYWxpemVWTm9kZVNsb3RzIiwiaW5pdFNsb3RzIiwidXBkYXRlU2xvdHMiLCJuZWVkRGVsZXRpb25DaGVjayIsImRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCIsImNyZWF0ZUFwcENvbnRleHQiLCJpc05hdGl2ZVRhZyIsInBlcmZvcm1hbmNlIiwiY29tcGlsZXJPcHRpb25zIiwiV2Vha01hcCIsInVpZCQxIiwiY3JlYXRlQXBwQVBJIiwiY3JlYXRlQXBwIiwicm9vdENvbXBvbmVudCIsInJvb3RQcm9wcyIsImNvbnRleHQiLCJpbnN0YWxsZWRQbHVnaW5zIiwiX3VpZCIsIl9jb21wb25lbnQiLCJfcHJvcHMiLCJfY29udGFpbmVyIiwiX2NvbnRleHQiLCJfaW5zdGFuY2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsIiwibWl4aW4iLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJkaXJlY3RpdmUiLCJtb3VudCIsInJvb3RDb250YWluZXIiLCJpc0h5ZHJhdGUiLCJfX3Z1ZV9hcHBfXyIsInNldFJlZiIsInJhd1JlZiIsIm9sZFJhd1JlZiIsImlzVW5tb3VudCIsInJlZlZhbHVlIiwib3duZXIiLCJvbGRSZWYiLCJfaXNTdHJpbmciLCJfaXNSZWYiLCJkb1NldCIsImV4aXN0aW5nIiwiayIsImhhc01pc21hdGNoIiwiaXNTVkdDb250YWluZXIiLCJuYW1lc3BhY2VVUkkiLCJ0YWdOYW1lIiwiaXNDb21tZW50Iiwibm9kZVR5cGUiLCJjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMiLCJtdCIsIm1vdW50Q29tcG9uZW50IiwicGF0Y2hQcm9wIiwiY3JlYXRlVGV4dCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0IiwiY3JlYXRlQ29tbWVudCIsImhhc0NoaWxkTm9kZXMiLCJfdm5vZGUiLCJmaXJzdENoaWxkIiwiaXNGcmFnbWVudFN0YXJ0Iiwib25NaXNtYXRjaCIsImhhbmRsZU1pc21hdGNoIiwiZG9tVHlwZSIsIm5leHROb2RlIiwibmVlZFRvQWRvcHRDb250ZW50Iiwic3RhdGljQ291bnQiLCJvdXRlckhUTUwiLCJoeWRyYXRlRnJhZ21lbnQiLCJoeWRyYXRlRWxlbWVudCIsImxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciIsInByZXZpb3VzU2libGluZyIsImxhc3RDaGlsZCIsImNyZWF0ZVRleHRWTm9kZSIsImh5ZHJhdGVDaGlsZHJlbiIsImZvcmNlUGF0Y2hWYWx1ZSIsImVuZHNXaXRoIiwib25DbGljayIsInZub2RlSG9va3MiLCJvblZub2RlQmVmb3JlTW91bnQiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudCIsInBhcmVudFZOb2RlIiwiZnJhZ21lbnRTbG90U2NvcGVJZHMiLCJpc0ZyYWdtZW50Iiwic3VwcG9ydGVkIiwicGVyZiIsInN0YXJ0TWVhc3VyZSIsImlzU3VwcG9ydGVkIiwibWFyayIsIm5vdyIsIkRhdGUiLCJlbmRNZWFzdXJlIiwic3RhcnRUYWciLCJlbmRUYWciLCJtZWFzdXJlIiwiY2xlYXJNYXJrcyIsImluaXRGZWF0dXJlRmxhZ3MiLCJuZWVkV2FybiIsIm11bHRpIiwiY3JlYXRlUmVuZGVyZXIiLCJiYXNlQ3JlYXRlUmVuZGVyZXIiLCJjcmVhdGVIeWRyYXRpb25SZW5kZXJlciIsImNyZWF0ZUh5ZHJhdGlvbkZucyIsIl9fVlVFX18iLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaG9zdEluc2VydCIsImhvc3RSZW1vdmUiLCJob3N0UGF0Y2hQcm9wIiwiaG9zdENyZWF0ZUVsZW1lbnQiLCJob3N0Q3JlYXRlVGV4dCIsImhvc3RDcmVhdGVDb21tZW50Iiwic2V0VGV4dCIsImhvc3RTZXRUZXh0Iiwic2V0RWxlbWVudFRleHQiLCJob3N0U2V0RWxlbWVudFRleHQiLCJob3N0UGFyZW50Tm9kZSIsImhvc3ROZXh0U2libGluZyIsInNldFNjb3BlSWQiLCJob3N0U2V0U2NvcGVJZCIsImluc2VydFN0YXRpY0NvbnRlbnQiLCJob3N0SW5zZXJ0U3RhdGljQ29udGVudCIsImdldE5leHRIb3N0Tm9kZSIsInByb2Nlc3NUZXh0IiwicHJvY2Vzc0NvbW1lbnROb2RlIiwibW91bnRTdGF0aWNOb2RlIiwicGF0Y2hTdGF0aWNOb2RlIiwicHJvY2Vzc0ZyYWdtZW50IiwicHJvY2Vzc0VsZW1lbnQiLCJwcm9jZXNzQ29tcG9uZW50IiwiaW50ZXJuYWxzIiwicmVtb3ZlU3RhdGljTm9kZSIsIm1vdmVTdGF0aWNOb2RlIiwibW91bnRFbGVtZW50IiwicGF0Y2hFbGVtZW50IiwiaXMiLCJtb3VudENoaWxkcmVuIiwidW5tb3VudENoaWxkcmVuIiwibmVlZENhbGxUcmFuc2l0aW9uSG9va3MiLCJjbG9uZUlmTW91bnRlZCIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJ0b2dnbGVSZWN1cnNlIiwib25Wbm9kZUJlZm9yZVVwZGF0ZSIsImFyZUNoaWxkcmVuU1ZHIiwicGF0Y2hCbG9ja0NoaWxkcmVuIiwidHJhdmVyc2VTdGF0aWNDaGlsZHJlbiIsInBhdGNoQ2hpbGRyZW4iLCJwYXRjaFByb3BzIiwiY2xhc3MiLCJzdHlsZSIsIm9uVm5vZGVVcGRhdGVkIiwib2xkQ2hpbGRyZW4iLCJuZXdDaGlsZHJlbiIsImZhbGxiYWNrQ29udGFpbmVyIiwib2xkVk5vZGUiLCJuZXdWTm9kZSIsImZyYWdtZW50U3RhcnRBbmNob3IiLCJmcmFnbWVudEVuZEFuY2hvciIsInVwZGF0ZUNvbXBvbmVudCIsImluaXRpYWxWTm9kZSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlIiwic2V0dXBDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIiLCJjb21wb25lbnRVcGRhdGVGbiIsImJtIiwiaXNBc3luY1dyYXBwZXJWTm9kZSIsImh5ZHJhdGVTdWJUcmVlIiwic2NvcGVkSW5pdGlhbFZOb2RlIiwiYnUiLCJ1Iiwib3JpZ2luTmV4dCIsIm5leHRUcmVlIiwicHJldlRyZWUiLCJydGMiLCJydGciLCJjMSIsInByZXZTaGFwZUZsYWciLCJjMiIsInBhdGNoS2V5ZWRDaGlsZHJlbiIsInBhdGNoVW5rZXllZENoaWxkcmVuIiwib2xkTGVuZ3RoIiwibmV3TGVuZ3RoIiwiY29tbW9uTGVuZ3RoIiwiTWF0aCIsIm1pbiIsIm5leHRDaGlsZCIsInBhcmVudEFuY2hvciIsImwyIiwiZTEiLCJlMiIsIm5leHRQb3MiLCJzMSIsInMyIiwia2V5VG9OZXdJbmRleE1hcCIsInBhdGNoZWQiLCJ0b0JlUGF0Y2hlZCIsIm1vdmVkIiwibWF4TmV3SW5kZXhTb0ZhciIsIm5ld0luZGV4VG9PbGRJbmRleE1hcCIsInByZXZDaGlsZCIsIm5ld0luZGV4IiwiaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UiLCJnZXRTZXF1ZW5jZSIsIm5leHRJbmRleCIsIm1vdmVUeXBlIiwibmVlZFRyYW5zaXRpb24iLCJwZXJmb3JtTGVhdmUiLCJzaG91bGRJbnZva2VEaXJzIiwic2hvdWxkSW52b2tlVm5vZGVIb29rIiwib25Wbm9kZUJlZm9yZVVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50IiwicmVtb3ZlRnJhZ21lbnQiLCJwZXJmb3JtUmVtb3ZlIiwiYnVtIiwibWMiLCJwYyIsInBiYyIsImFsbG93ZWQiLCJzaGFsbG93IiwiY2gxIiwiY2gyIiwiYXJyIiwibGVuIiwiYXJySSIsImlzVGVsZXBvcnQiLCJfX2lzVGVsZXBvcnQiLCJpc1RlbGVwb3J0RGlzYWJsZWQiLCJkaXNhYmxlZCIsImlzVGFyZ2V0U1ZHIiwiU1ZHRWxlbWVudCIsInJlc29sdmVUYXJnZXQiLCJzZWxlY3QiLCJ0YXJnZXRTZWxlY3RvciIsIlRlbGVwb3J0SW1wbCIsInF1ZXJ5U2VsZWN0b3IiLCJtYWluQW5jaG9yIiwidGFyZ2V0QW5jaG9yIiwid2FzRGlzYWJsZWQiLCJjdXJyZW50Q29udGFpbmVyIiwiY3VycmVudEFuY2hvciIsIm1vdmVUZWxlcG9ydCIsIm5leHRUYXJnZXQiLCJ1cGRhdGVDc3NWYXJzIiwiaHlkcmF0ZVRlbGVwb3J0IiwiaXNSZW9yZGVyIiwidGFyZ2V0Tm9kZSIsIl9scGEiLCJUZWxlcG9ydCIsInV0Iiwic2V0QXR0cmlidXRlIiwiZGlzYWJsZVRyYWNraW5nIiwic2V0dXBCbG9jayIsImNyZWF0ZUVsZW1lbnRCbG9jayIsImNyZWF0ZUJhc2VWTm9kZSIsIl9fdl9pc1ZOb2RlIiwidm5vZGVBcmdzVHJhbnNmb3JtZXIiLCJ0cmFuc2Zvcm1WTm9kZUFyZ3MiLCJ0cmFuc2Zvcm1lciIsImNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0iLCJfY3JlYXRlVk5vZGUiLCJub3JtYWxpemVLZXkiLCJub3JtYWxpemVSZWYiLCJyZWZfa2V5IiwicmVmX2ZvciIsImlzQmxvY2tOb2RlIiwibmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24iLCJfX3Zfc2tpcCIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwiY2xvbmVkIiwiZ3VhcmRSZWFjdGl2ZVByb3BzIiwia2xhc3MiLCJleHRyYVByb3BzIiwibWVyZ2VSZWYiLCJtZXJnZWRQcm9wcyIsIm1lcmdlUHJvcHMiLCJkZWVwQ2xvbmVWTm9kZSIsInRleHQiLCJmbGFnIiwiY3JlYXRlU3RhdGljVk5vZGUiLCJjb250ZW50IiwibnVtYmVyT2ZOb2RlcyIsImNyZWF0ZUNvbW1lbnRWTm9kZSIsImFzQmxvY2siLCJtZW1vIiwic2xvdEZsYWciLCJ0b01lcmdlIiwiaW5jb21pbmciLCJlbXB0eUFwcENvbnRleHQiLCJleHBvc2VQcm94eSIsInNldHVwQ29udGV4dCIsImJjIiwic3AiLCJvbiIsIm9mZiIsImlzQnVpbHRJblRhZyIsImFwcElzTmF0aXZlVGFnIiwic2V0dXBSZXN1bHQiLCJzZXR1cFN0YXRlZnVsQ29tcG9uZW50IiwibmFtZXMiLCJpc1J1bnRpbWVPbmx5IiwiUHJveHkiLCJjcmVhdGVTZXR1cENvbnRleHQiLCJyZXNvbHZlZFJlc3VsdCIsImZpbmlzaENvbXBvbmVudFNldHVwIiwiX19zc3JJbmxpbmVSZW5kZXIiLCJzc3JSZW5kZXIiLCJkZXZ0b29sc1Jhd1NldHVwU3RhdGUiLCJjb21waWxlIiwiaW5zdGFsbFdpdGhQcm94eSIsInJlZ2lzdGVyUnVudGltZUNvbXBpbGVyIiwiX2NvbXBpbGUiLCJfcmMiLCJza2lwT3B0aW9ucyIsInRlbXBsYXRlIiwiaXNDdXN0b21FbGVtZW50IiwiZGVsaW1pdGVycyIsImNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyIsImZpbmFsQ29tcGlsZXJPcHRpb25zIiwiY3JlYXRlQXR0cnNQcm94eSIsImRlbGV0ZVByb3BlcnR5IiwiZXhwb3NlZFR5cGUiLCJmcmVlemUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJzdHIiLCJ0b1VwcGVyQ2FzZSIsImluY2x1ZGVJbmZlcnJlZCIsImRpc3BsYXlOYW1lIiwiX19uYW1lIiwiX19maWxlIiwiaW5mZXJGcm9tUmVnaXN0cnkiLCJnZXR0ZXJPck9wdGlvbnMiLCJkZWJ1Z09wdGlvbnMiLCJ3YXJuUnVudGltZVVzYWdlIiwibWV0aG9kIiwiZGVmaW5lUHJvcHMiLCJkZWZpbmVFbWl0cyIsImRlZmluZUV4cG9zZSIsIndpdGhEZWZhdWx0cyIsImRlZmF1bHRzIiwidXNlU2xvdHMiLCJnZXRDb250ZXh0IiwidXNlQXR0cnMiLCJtZXJnZURlZmF1bHRzIiwicmVkdWNlIiwiY3JlYXRlUHJvcHNSZXN0UHJveHkiLCJleGNsdWRlZEtleXMiLCJ3aXRoQXN5bmNDb250ZXh0IiwiZ2V0QXdhaXRhYmxlIiwiYXdhaXRhYmxlIiwicHJvcHNPckNoaWxkcmVuIiwicHJvdG90eXBlIiwic3NyQ29udGV4dEtleSIsImluaXRDdXN0b21Gb3JtYXR0ZXIiLCJ2dWVTdHlsZSIsIm51bWJlclN0eWxlIiwic3RyaW5nU3R5bGUiLCJrZXl3b3JkU3R5bGUiLCJmb3JtYXR0ZXIiLCJoZWFkZXIiLCJfX2lzVnVlIiwiZ2VuUmVmRmxhZyIsImZvcm1hdFZhbHVlIiwiaGFzQm9keSIsImJvZHkiLCJmb3JtYXRJbnN0YW5jZSIsImJsb2NrcyIsImNyZWF0ZUluc3RhbmNlQmxvY2siLCJleHRyYWN0S2V5cyIsIm9iamVjdCIsImFzUmF3IiwiQ29tcCIsImV4dHJhY3RlZCIsImlzS2V5T2ZUeXBlIiwib3B0cyIsImRldnRvb2xzRm9ybWF0dGVycyIsIndpdGhNZW1vIiwiaXNNZW1vU2FtZSIsIl9zc3JVdGlscyIsInNzclV0aWxzIiwicmVzb2x2ZUZpbHRlciIsImNvbXBhdFV0aWxzIiwiY3JlYXRlRWxlbWVudFZOb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3396\n")},9242:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"D2\": function() { return /* binding */ withKeys; },\n/* harmony export */   \"F8\": function() { return /* binding */ vShow; },\n/* harmony export */   \"e8\": function() { return /* binding */ vModelCheckbox; },\n/* harmony export */   \"iM\": function() { return /* binding */ withModifiers; },\n/* harmony export */   \"nr\": function() { return /* binding */ vModelText; },\n/* harmony export */   \"ri\": function() { return /* binding */ createApp; }\n/* harmony export */ });\n/* unused harmony exports Transition, TransitionGroup, VueElement, createSSRApp, defineCustomElement, defineSSRCustomElement, hydrate, initDirectivesForSSR, render, useCssModule, useCssVars, vModelDynamic, vModelRadio, vModelSelect */\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7139);\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3396);\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4870);\n\n\n\n\nconst svgNS = 'http://www.w3.org/2000/svg';\nconst doc = typeof document !== 'undefined' ? document : null;\nconst templateContainer = doc && /*#__PURE__*/doc.createElement('template');\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: child => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, isSVG, is, props) => {\n    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {\n      is\n    } : undefined);\n    if (tag === 'select' && props && props.multiple != null) {\n      el.setAttribute('multiple', props.multiple);\n    }\n    return el;\n  },\n  createText: text => doc.createTextNode(text),\n  createComment: text => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: node => node.parentNode,\n  nextSibling: node => node.nextSibling,\n  querySelector: selector => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, '');\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, isSVG, start, end) {\n    // <parent> before | first ... last | anchor </parent>\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    // #5308 can only take cached path if:\n    // - has a single root node\n    // - nextSibling info is still available\n    if (start && (start === end || start.nextSibling)) {\n      // cached\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling)) break;\n      }\n    } else {\n      // fresh insert\n      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\n      const template = templateContainer.content;\n      if (isSVG) {\n        // remove outer svg wrapper\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n    // first\n    before ? before.nextSibling : parent.firstChild,\n    // last\n    anchor ? anchor.previousSibling : parent.lastChild];\n  }\n};\n\n// compiler should normalize class + :class bindings on the same element\n// into a single binding ['staticClass', dynamic]\nfunction patchClass(el, value, isSVG) {\n  // directly setting className should be faster than setAttribute in theory\n  // if this is an element during a transition, take the temporary transition\n  // classes into account.\n  const transitionClasses = el._vtc;\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\n  }\n  if (value == null) {\n    el.removeAttribute('class');\n  } else if (isSVG) {\n    el.setAttribute('class', value);\n  } else {\n    el.className = value;\n  }\n}\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .HD)(next);\n  if (next && !isCssString) {\n    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .HD)(prev)) {\n      for (const key in prev) {\n        if (next[key] == null) {\n          setStyle(style, key, '');\n        }\n      }\n    }\n    for (const key in next) {\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    const currentDisplay = style.display;\n    if (isCssString) {\n      if (prev !== next) {\n        style.cssText = next;\n      }\n    } else if (prev) {\n      el.removeAttribute('style');\n    }\n    // indicates that the `display` of the element is controlled by `v-show`,\n    // so we always keep the current `display` value regardless of the `style`\n    // value, thus handing over control to `v-show`.\n    if ('_vod' in el) {\n      style.display = currentDisplay;\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(val)) {\n    val.forEach(v => setStyle(style, name, v));\n  } else {\n    if (val == null) val = '';\n    if (false) {}\n    if (name.startsWith('--')) {\n      // custom property definition\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        // !important\n        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .rs)(prefixed), val.replace(importantRE, ''), 'important');\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = ['Webkit', 'Moz', 'ms'];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ ._A)(rawName);\n  if (name !== 'filter' && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .capitalize */ .kC)(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nfunction patchAttr(el, key, value, isSVG, instance) {\n  if (isSVG && key.startsWith('xlink:')) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    // note we are only checking boolean attributes that don't have a\n    // corresponding dom prop of the same name here.\n    const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSpecialBooleanAttr */ .Pq)(key);\n    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .includeBooleanAttr */ .yA)(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, isBoolean ? '' : value);\n    }\n  }\n}\n\n// __UNSAFE__\n// functions. The user is responsible for using them with only trusted content.\nfunction patchDOMProp(el, key, value,\n// the following args are passed only due to potential innerHTML/textContent\n// overriding existing VNodes, in which case the old tree must be properly\n// unmounted.\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\n  if (key === 'innerHTML' || key === 'textContent') {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense);\n    }\n    el[key] = value == null ? '' : value;\n    return;\n  }\n  if (key === 'value' && el.tagName !== 'PROGRESS' &&\n  // custom elements may use _value internally\n  !el.tagName.includes('-')) {\n    // store value as _value as well since\n    // non-string values will be stringified.\n    el._value = value;\n    const newValue = value == null ? '' : value;\n    if (el.value !== newValue ||\n    // #4956: always set for OPTION elements because its value falls back to\n    // textContent if no value attribute is present. And setting .value for\n    // OPTION has no side effect\n    el.tagName === 'OPTION') {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    return;\n  }\n  let needRemove = false;\n  if (value === '' || value == null) {\n    const type = typeof el[key];\n    if (type === 'boolean') {\n      // e.g. <select multiple> compiles to { multiple: '' }\n      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .includeBooleanAttr */ .yA)(value);\n    } else if (value == null && type === 'string') {\n      // e.g. <div :id=\"null\">\n      value = '';\n      needRemove = true;\n    } else if (type === 'number') {\n      // e.g. <img :width=\"null\">\n      value = 0;\n      needRemove = true;\n    }\n  }\n  // some properties perform value validation and throw,\n  // some properties has getter, no setter, will error in 'use strict'\n  // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\n  try {\n    el[key] = value;\n  } catch (e) {\n    // do not warn if value is auto-coerced from nullish values\n    if (false) {}\n  }\n  needRemove && el.removeAttribute(key);\n}\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  // vei = vue event invokers\n  const invokers = el._vei || (el._vei = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    // patch\n    existingInvoker.value = nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      // add\n      const invoker = invokers[rawName] = createInvoker(nextValue, instance);\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      // remove\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = undefined;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === ':' ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .rs)(name.slice(2));\n  return [event, options];\n}\n// To avoid the overhead of repeatedly calling Date.now(), we cache\n// and use the same timestamp for all event listeners attached in the same tick.\nlet cachedNow = 0;\nconst p = /*#__PURE__*/Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = e => {\n    // async edge case vuejs/vue#6566\n    // inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // this no longer happens for templates in Vue 3, but could still be\n    // theoretically possible for hand-written render functions.\n    // the solution: we save the timestamp when a handler is attached,\n    // and also attach the timestamp to any event that was handled by vue\n    // for the first time (to avoid inconsistent event timestamp implementations\n    // or events fired from iframes, e.g. #2513)\n    // The handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .callWithAsyncErrorHandling */ .$d)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* ErrorCodes.NATIVE_EVENT_HANDLER */, [e]);\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(fn => e => !e._stopped && fn && fn(e));\n  } else {\n    return value;\n  }\n}\nconst nativeOnRE = /^on[a-z]/;\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n  if (key === 'class') {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === 'style') {\n    patchStyle(el, prevValue, nextValue);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isOn */ .F7)(key)) {\n    // ignore v-model listeners\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isModelListener */ .tR)(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === '.' ? (key = key.slice(1), true) : key[0] === '^' ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n  } else {\n    // special case for <input v-model type=\"checkbox\"> with\n    // :true-value & :false-value\n    // store value as dom properties since non-string values will be\n    // stringified.\n    if (key === 'true-value') {\n      el._trueValue = nextValue;\n    } else if (key === 'false-value') {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    // most keys must be set as attribute on svg elements to work\n    // ...except innerHTML & textContent\n    if (key === 'innerHTML' || key === 'textContent') {\n      return true;\n    }\n    // or native onclick with function values\n    if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(value)) {\n      return true;\n    }\n    return false;\n  }\n  // these are enumerated attrs, however their corresponding DOM properties\n  // are actually booleans - this leads to setting it with a string \"false\"\n  // value leading it to be coerced to `true`, so we need to always treat\n  // them as attributes.\n  // Note that `contentEditable` doesn't have this problem: its DOM\n  // property is also enumerated string values.\n  if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\n    return false;\n  }\n  // #1787, #2840 form property on form elements is readonly and must be set as\n  // attribute.\n  if (key === 'form') {\n    return false;\n  }\n  // #1526 <input list> must be set as attribute\n  if (key === 'list' && el.tagName === 'INPUT') {\n    return false;\n  }\n  // #2766 <textarea type> must be set as attribute\n  if (key === 'type' && el.tagName === 'TEXTAREA') {\n    return false;\n  }\n  // native onclick with string value, must be set as attribute\n  if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .HD)(value)) {\n    return false;\n  }\n  return key in el;\n}\nfunction defineCustomElement(options, hydrate) {\n  const Comp = defineComponent(options);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, hydrate);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\nconst defineSSRCustomElement = options => {\n  // @ts-ignore\n  return defineCustomElement(options, hydrate);\n};\nconst BaseClass = typeof HTMLElement !== 'undefined' ? HTMLElement : class {};\nclass VueElement extends (/* unused pure expression or super */ null && (BaseClass)) {\n  constructor(_def, _props = {}, hydrate) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    if (this.shadowRoot && hydrate) {\n      hydrate(this._createVNode(), this.shadowRoot);\n    } else {\n      if (false) {}\n      this.attachShadow({\n        mode: 'open'\n      });\n      if (!this._def.__asyncLoader) {\n        // for sync component defs we can immediately resolve props\n        this._resolveProps(this._def);\n      }\n    }\n  }\n  connectedCallback() {\n    this._connected = true;\n    if (!this._instance) {\n      if (this._resolved) {\n        this._update();\n      } else {\n        this._resolveDef();\n      }\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    nextTick(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot);\n        this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    this._resolved = true;\n    // set initial attrs\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    // watch future attr changes\n    new MutationObserver(mutations => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    }).observe(this, {\n      attributes: true\n    });\n    const resolve = (def, isAsync = false) => {\n      const {\n        props,\n        styles\n      } = def;\n      // cast Number-type props set before resolve\n      let numberProps;\n      if (props && !isArray(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = toNumber(this._props[key]);\n            }\n            (numberProps || (numberProps = Object.create(null)))[camelize$1(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      if (isAsync) {\n        // defining getter/setters on prototype\n        // for sync defs, this already happened in the constructor\n        this._resolveProps(def);\n      }\n      // apply CSS\n      this._applyStyles(styles);\n      // initial render\n      this._update();\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      asyncDef().then(def => resolve(def, true));\n    } else {\n      resolve(this._def);\n    }\n  }\n  _resolveProps(def) {\n    const {\n      props\n    } = def;\n    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});\n    // check if there are props set pre-upgrade or connect\n    for (const key of Object.keys(this)) {\n      if (key[0] !== '_' && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key], true, false);\n      }\n    }\n    // defining getter/setters on prototype\n    for (const key of declaredPropKeys.map(camelize$1)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    let value = this.getAttribute(key);\n    const camelKey = camelize$1(key);\n    if (this._numberProps && this._numberProps[camelKey]) {\n      value = toNumber(value);\n    }\n    this._setProp(camelKey, value, false);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n    if (val !== this._props[key]) {\n      this._props[key] = val;\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      // reflect\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute(hyphenate(key), '');\n        } else if (typeof val === 'string' || typeof val === 'number') {\n          this.setAttribute(hyphenate(key), val + '');\n        } else if (!val) {\n          this.removeAttribute(hyphenate(key));\n        }\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const vnode = createVNode(this._def, extend({}, this._props));\n    if (!this._instance) {\n      vnode.ce = instance => {\n        this._instance = instance;\n        instance.isCE = true;\n        // HMR\n        if (false) {}\n        const dispatch = (event, args) => {\n          this.dispatchEvent(new CustomEvent(event, {\n            detail: args\n          }));\n        };\n        // intercept emit\n        instance.emit = (event, ...args) => {\n          // dispatch both the raw and hyphenated versions of an event\n          // to match Vue behavior\n          dispatch(event, args);\n          if (hyphenate(event) !== event) {\n            dispatch(hyphenate(event), args);\n          }\n        };\n        // locate nearest Vue custom element parent for provide/inject\n        let parent = this;\n        while (parent = parent && (parent.parentNode || parent.host)) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance;\n            instance.provides = parent._instance.provides;\n            break;\n          }\n        }\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles) {\n    if (styles) {\n      styles.forEach(css => {\n        const s = document.createElement('style');\n        s.textContent = css;\n        this.shadowRoot.appendChild(s);\n        // record for HMR\n        if (false) {}\n      });\n    }\n  }\n}\nfunction useCssModule(name = '$style') {\n  /* istanbul ignore else */\n  {\n    const instance = getCurrentInstance();\n    if (!instance) {\n       false && 0;\n      return EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n       false && 0;\n      return EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n       false && 0;\n      return EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\n\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nfunction useCssVars(getter) {\n  const instance = getCurrentInstance();\n  /* istanbul ignore next */\n  if (!instance) {\n     false && 0;\n    return;\n  }\n  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {\n    Array.from(document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)).forEach(node => setVarsOnNode(node, vars));\n  };\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    setVarsOnVNode(instance.subTree, vars);\n    updateTeleports(vars);\n  };\n  watchPostEffect(setVars);\n  onMounted(() => {\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, {\n      childList: true\n    });\n    onUnmounted(() => ob.disconnect());\n  });\n}\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  // drill down HOCs until it's a non-component vnode\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === Fragment) {\n    vnode.children.forEach(c => setVarsOnVNode(c, vars));\n  } else if (vnode.type === Static) {\n    let {\n      el,\n      anchor\n    } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor) break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key]);\n    }\n  }\n}\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n// DOM Transition is a higher-order-component based on the platform-agnostic\n// base Transition component, with DOM-specific logic.\nconst Transition = (props, {\n  slots\n}) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .BaseTransition */ .P$, resolveTransitionProps(props), slots);\nTransition.displayName = 'Transition';\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = Transition.props = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .BaseTransition.props */ .P$.props, DOMTransitionPropsValidators);\n/**\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\n * with custom HOCs.\n */\nconst callHook = (hook, args = []) => {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(hook)) {\n    hook.forEach(h => h(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\n/**\n * Check if a hook expects a callback (2nd arg), which means the user\n * intends to explicitly control the end of the transition.\n */\nconst hasExplicitCallback = hook => {\n  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(hook) ? hook.some(h => h.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = 'v',\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = isAppear => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      // force reflow so *-leave-from classes immediately take effect (#2593)\n      forceReflow();\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          // cancelled\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toNumber */ .He)(val);\n  if (false) {}\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n  (el._vtc || (el._vtc = new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n  const {\n    _vtc\n  } = el;\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el._vtc = undefined;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const {\n    type,\n    timeout,\n    propCount\n  } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + 'end';\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = e => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  const getStyleProperties = key => (styles[key] || '').split(', ');\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\n// numbers in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down\n// (i.e. acting as a floor function) causing unexpected behaviors\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n// synchronously force layout to put elements into a certain state\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\nconst positionMap = new WeakMap();\nconst newPositionMap = new WeakMap();\nconst TransitionGroupImpl = {\n  name: 'TransitionGroup',\n  props: /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, {\n    slots\n  }) {\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .getCurrentInstance */ .FN)();\n    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .useTransitionState */ .Y8)();\n    let prevChildren;\n    let children;\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .onUpdated */ .ic)(() => {\n      // children is guaranteed to exist after initial render\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || 'v'}-move`;\n      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n        return;\n      }\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      // force reflow to put everything in position\n      forceReflow();\n      movedChildren.forEach(c => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = '';\n        const cb = el._moveCb = e => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener('transitionend', cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener('transitionend', cb);\n      });\n    });\n    return () => {\n      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__/* .toRaw */ .IU)(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .Fragment */ .HY;\n      prevChildren = children;\n      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .getTransitionRawChildren */ .Q6)(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .setTransitionHooks */ .nK)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .resolveTransitionHooks */ .U2)(child, cssTransitionProps, state, instance));\n        } else if (false) {}\n      }\n      if (prevChildren) {\n        for (let i = 0; i < prevChildren.length; i++) {\n          const child = prevChildren[i];\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .setTransitionHooks */ .nK)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .resolveTransitionHooks */ .U2)(child, cssTransitionProps, state, instance));\n          positionMap.set(child, child.el.getBoundingClientRect());\n        }\n      }\n      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .createVNode */ .Wm)(tag, null, children);\n    };\n  }\n};\n/**\n * TransitionGroup does not support \"mode\" so we need to remove it from the\n * props declarations, but direct delete operation is considered a side effect\n * and will make the entire transition feature non-tree-shakeable, so we do it\n * in a function and mark the function's invocation as pure.\n */\nconst removeMode = props => delete props.mode;\n/*#__PURE__*/\nremoveMode(TransitionGroupImpl.props);\nconst TransitionGroup = (/* unused pure expression or super */ null && (TransitionGroupImpl));\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el._moveCb) {\n    el._moveCb();\n  }\n  if (el._enterCb) {\n    el._enterCb();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = '0s';\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  // Detect whether an element with the move class applied has\n  // CSS transitions. Since the element may be inside an entering\n  // transition at this very moment, we make a clone of it and remove\n  // all other transition classes applied to ensure only the move class\n  // is applied.\n  const clone = el.cloneNode();\n  if (el._vtc) {\n    el._vtc.forEach(cls => {\n      cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n  clone.style.display = 'none';\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const {\n    hasTransform\n  } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\nconst getModelAssigner = vnode => {\n  const fn = vnode.props['onUpdate:modelValue'] || false;\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .ir)(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event('input'));\n  }\n}\n// We are exporting the v-model runtime directly as vnode hooks so that it can\n// be tree-shaken in case v-model is never used.\nconst vModelText = {\n  created(el, {\n    modifiers: {\n      lazy,\n      trim,\n      number\n    }\n  }, vnode) {\n    el._assign = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === 'number';\n    addEventListener(el, lazy ? 'change' : 'input', e => {\n      if (e.target.composing) return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .h5)(domValue);\n      }\n      el._assign(domValue);\n    });\n    if (trim) {\n      addEventListener(el, 'change', () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, 'compositionstart', onCompositionStart);\n      addEventListener(el, 'compositionend', onCompositionEnd);\n      // Safari < 10.2 & UIWebView doesn't fire compositionend when\n      // switching focus before confirming composition choice\n      // this also fixes the issue where some browsers e.g. iOS Chrome\n      // fires \"change\" instead of \"input\" on autocomplete.\n      addEventListener(el, 'change', onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, {\n    value\n  }) {\n    el.value = value == null ? '' : value;\n  },\n  beforeUpdate(el, {\n    value,\n    modifiers: {\n      lazy,\n      trim,\n      number\n    }\n  }, vnode) {\n    el._assign = getModelAssigner(vnode);\n    // avoid clearing unresolved text. #2302\n    if (el.composing) return;\n    if (document.activeElement === el && el.type !== 'range') {\n      if (lazy) {\n        return;\n      }\n      if (trim && el.value.trim() === value) {\n        return;\n      }\n      if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .h5)(el.value) === value) {\n        return;\n      }\n    }\n    const newValue = value == null ? '' : value;\n    if (el.value !== newValue) {\n      el.value = newValue;\n    }\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el._assign = getModelAssigner(vnode);\n    addEventListener(el, 'change', () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el._assign;\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(modelValue)) {\n        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .hq)(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .DM)(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el._assign = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, {\n  value,\n  oldValue\n}, vnode) {\n  el._modelValue = value;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(value)) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .hq)(value, vnode.props.value) > -1;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .DM)(value)) {\n    el.checked = value.has(vnode.props.value);\n  } else if (value !== oldValue) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .WV)(value, getCheckboxValue(el, true));\n  }\n}\nconst vModelRadio = {\n  created(el, {\n    value\n  }, vnode) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .WV)(value, vnode.props.value);\n    el._assign = getModelAssigner(vnode);\n    addEventListener(el, 'change', () => {\n      el._assign(getValue(el));\n    });\n  },\n  beforeUpdate(el, {\n    value,\n    oldValue\n  }, vnode) {\n    el._assign = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .WV)(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, {\n    value,\n    modifiers: {\n      number\n    }\n  }, vnode) {\n    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .DM)(value);\n    addEventListener(el, 'change', () => {\n      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .h5)(getValue(o)) : getValue(o));\n      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);\n    });\n    el._assign = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, {\n    value\n  }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el._assign = getModelAssigner(vnode);\n  },\n  updated(el, {\n    value\n  }) {\n    setSelected(el, value);\n  }\n};\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .DM)(value)) {\n     false && 0;\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(value)) {\n        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .hq)(value, optionValue) > -1;\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .WV)(getValue(option), value)) {\n        if (el.selectedIndex !== i) el.selectedIndex = i;\n        return;\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\n// retrieve raw value set via :value bindings\nfunction getValue(el) {\n  return '_value' in el ? el._value : el.value;\n}\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? '_trueValue' : '_falseValue';\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'created');\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'mounted');\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'updated');\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case 'SELECT':\n      return vModelSelect;\n    case 'TEXTAREA':\n      return vModelText;\n    default:\n      switch (type) {\n        case 'checkbox':\n          return vModelCheckbox;\n        case 'radio':\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({\n    value\n  }) => ({\n    value\n  });\n  vModelRadio.getSSRProps = ({\n    value\n  }, vnode) => {\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({\n    value\n  }, vnode) => {\n    if (isArray(value)) {\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\n        return {\n          checked: true\n        };\n      }\n    } else if (isSet(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return {\n          checked: true\n        };\n      }\n    } else if (value) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== 'string') {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n    // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n    vnode.type.toUpperCase(), vnode.props && vnode.props.type);\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\nconst modifierGuards = {\n  stop: e => e.stopPropagation(),\n  prevent: e => e.preventDefault(),\n  self: e => e.target !== e.currentTarget,\n  ctrl: e => !e.ctrlKey,\n  shift: e => !e.shiftKey,\n  alt: e => !e.altKey,\n  meta: e => !e.metaKey,\n  left: e => 'button' in e && e.button !== 0,\n  middle: e => 'button' in e && e.button !== 1,\n  right: e => 'button' in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n};\n/**\n * @private\n */\nconst withModifiers = (fn, modifiers) => {\n  return (event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers)) return;\n    }\n    return fn(event, ...args);\n  };\n};\n// Kept for 2.x compat.\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\nconst keyNames = {\n  esc: 'escape',\n  space: ' ',\n  up: 'arrow-up',\n  left: 'arrow-left',\n  right: 'arrow-right',\n  down: 'arrow-down',\n  delete: 'backspace'\n};\n/**\n * @private\n */\nconst withKeys = (fn, modifiers) => {\n  return event => {\n    if (!('key' in event)) {\n      return;\n    }\n    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .rs)(event.key);\n    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event);\n    }\n  };\n};\nconst vShow = {\n  beforeMount(el, {\n    value\n  }, {\n    transition\n  }) {\n    el._vod = el.style.display === 'none' ? '' : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, {\n    value\n  }, {\n    transition\n  }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, {\n    value,\n    oldValue\n  }, {\n    transition\n  }) {\n    if (!value === !oldValue) return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, {\n    value\n  }) {\n    setDisplay(el, value);\n  }\n};\nfunction setDisplay(el, value) {\n  el.style.display = value ? el._vod : 'none';\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({\n    value\n  }) => {\n    if (!value) {\n      return {\n        style: {\n          display: 'none'\n        }\n      };\n    }\n  };\n}\nconst rendererOptions = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .l7)({\n  patchProp\n}, nodeOps);\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .createRenderer */ .Us)(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\nconst render = (...args) => {\n  ensureRenderer().render(...args);\n};\nconst hydrate = (...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n};\nconst createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  if (false) {}\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container) return;\n    const component = app._component;\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(component) && !component.render && !component.template) {\n      // __UNSAFE__\n      // Reason: potential execution of JS expressions in in-DOM template.\n      // The user must make sure the in-DOM template is trusted. If it's\n      // rendered by the server, the template should not contain any user data.\n      component.template = container.innerHTML;\n    }\n    // clear content before mounting\n    container.innerHTML = '';\n    const proxy = mount(container, false, container instanceof SVGElement);\n    if (container instanceof Element) {\n      container.removeAttribute('v-cloak');\n      container.setAttribute('data-v-app', '');\n    }\n    return proxy;\n  };\n  return app;\n};\nconst createSSRApp = (...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  if (false) {}\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, container instanceof SVGElement);\n    }\n  };\n  return app;\n};\nfunction injectNativeTagCheck(app) {\n  // Inject `isNativeTag`\n  // this is used for component name validation (dev only)\n  Object.defineProperty(app.config, 'isNativeTag', {\n    value: tag => isHTMLTag(tag) || isSVGTag(tag),\n    writable: false\n  });\n}\n// dev only\nfunction injectCompilerOptionsCheck(app) {\n  if (isRuntimeOnly()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, 'isCustomElement', {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        warn(`The \\`isCustomElement\\` config option is deprecated. Use ` + `\\`compilerOptions.isCustomElement\\` instead.`);\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using ` + `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` + `Since you are using the runtime-only build, \\`compilerOptions\\` ` + `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` + `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` + `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` + `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\n    Object.defineProperty(app.config, 'compilerOptions', {\n      get() {\n        warn(msg);\n        return compilerOptions;\n      },\n      set() {\n        warn(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .HD)(container)) {\n    const res = document.querySelector(container);\n    if (false) {}\n    return res;\n  }\n  if (false) {}\n  return container;\n}\nlet ssrDirectiveInitialized = false;\n/**\n * @internal\n */\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDbEQsTUFBTUMsR0FBRyxHQUFJLHFFQUFvRSxHQUM1RSwyRUFBMEUsR0FDMUUsa0VBQWlFLEdBQ2pFLHVFQUFzRSxHQUN0RSxpRkFBZ0YsR0FDaEYsNkZBQTRGLEdBQzVGLHFLQUFvSztJQUN6S3JULE1BQU0sQ0FBQ08sY0FBYyxDQUFDZ1MsR0FBRyxDQUFDVSxNQUFNLEVBQUUsaUJBQWlCLEVBQUU7TUFDakR6UyxHQUFHQSxDQUFBLEVBQUc7UUFDRmhQLElBQUksQ0FBQzZoQixHQUFHLENBQUM7UUFDVCxPQUFPRCxlQUFlO01BQzFCLENBQUM7TUFDRDFTLEdBQUdBLENBQUEsRUFBRztRQUNGbFAsSUFBSSxDQUFDNmhCLEdBQUcsQ0FBQztNQUNiO0lBQ0osQ0FBQyxDQUFDO0VBQ047QUFDSjtBQUNBLFNBQVNULGtCQUFrQkEsQ0FBQzdHLFNBQVMsRUFBRTtFQUNuQyxJQUFJL1ksK0RBQVEsQ0FBQytZLFNBQVMsQ0FBQyxFQUFFO0lBQ3JCLE1BQU0xRSxHQUFHLEdBQUc5UyxRQUFRLENBQUMrQixhQUFhLENBQUN5VixTQUFTLENBQUM7SUFDN0MsSUFBS2pULEtBQThDLEVBQUUsRUFFcEQ7SUFDRCxPQUFPdU8sR0FBRztFQUNkO0VBQ0EsSUFBS3ZPLEtBRzBCLEVBQUUsRUFFaEM7RUFDRCxPQUFPaVQsU0FBUztBQUNwQjtBQUNBLElBQUl3SCx1QkFBdUIsR0FBRyxLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLG9CQUFvQixHQUFHQSxDQUFBLEtBQU07RUFDM0IsSUFBSSxDQUFDRCx1QkFBdUIsRUFBRTtJQUMxQkEsdUJBQXVCLEdBQUcsSUFBSTtJQUM5Qi9ELGdCQUFnQixDQUFDLENBQUM7SUFDbEJ3QyxlQUFlLENBQUMsQ0FBQztFQUNyQjtBQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzPzI3MjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2FybiwgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCBjcmVhdGVWTm9kZSwgZ2V0Q3VycmVudEluc3RhbmNlLCB3YXRjaFBvc3RFZmZlY3QsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGgsIEJhc2VUcmFuc2l0aW9uLCBhc3NlcnROdW1iZXIsIHVzZVRyYW5zaXRpb25TdGF0ZSwgb25VcGRhdGVkLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIGlzUnVudGltZU9ubHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5LCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgaXNGdW5jdGlvbiwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgdG9OdW1iZXIsIGV4dGVuZCwgRU1QVFlfT0JKLCBpc09iamVjdCwgbG9vc2VUb051bWJlciwgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaW52b2tlQXJyYXlGbnMsIGlzSFRNTFRhZywgaXNTVkdUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qI19fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5jb25zdCBub2RlT3BzID0ge1xuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGlzU1ZHXG4gICAgICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZylcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0YWcgPT09ICdzZWxlY3QnICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCBwcm9wcy5tdWx0aXBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gICAgY3JlYXRlQ29tbWVudDogdGV4dCA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgfSxcbiAgICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9LFxuICAgIHBhcmVudE5vZGU6IG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgcXVlcnlTZWxlY3Rvcjogc2VsZWN0b3IgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xuICAgIH0sXG4gICAgLy8gX19VTlNBRkVfX1xuICAgIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxuICAgIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIGlzU1ZHLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIDxwYXJlbnQ+IGJlZm9yZSB8IGZpcnN0IC4uLiBsYXN0IHwgYW5jaG9yIDwvcGFyZW50PlxuICAgICAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgLy8gIzUzMDggY2FuIG9ubHkgdGFrZSBjYWNoZWQgcGF0aCBpZjpcbiAgICAgICAgLy8gLSBoYXMgYSBzaW5nbGUgcm9vdCBub2RlXG4gICAgICAgIC8vIC0gbmV4dFNpYmxpbmcgaW5mbyBpcyBzdGlsbCBhdmFpbGFibGVcbiAgICAgICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgLy8gY2FjaGVkXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJlc2ggaW5zZXJ0XG4gICAgICAgICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgICAgICAgIGlmIChpc1NWRykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvdXRlciBzdmcgd3JhcHBlclxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyBmaXJzdFxuICAgICAgICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAvLyBsYXN0XG4gICAgICAgICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgICAgICBdO1xuICAgIH1cbn07XG5cbi8vIGNvbXBpbGVyIHNob3VsZCBub3JtYWxpemUgY2xhc3MgKyA6Y2xhc3MgYmluZGluZ3Mgb24gdGhlIHNhbWUgZWxlbWVudFxuLy8gaW50byBhIHNpbmdsZSBiaW5kaW5nIFsnc3RhdGljQ2xhc3MnLCBkeW5hbWljXVxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XG4gICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcbiAgICAvLyBpZiB0aGlzIGlzIGFuIGVsZW1lbnQgZHVyaW5nIGEgdHJhbnNpdGlvbiwgdGFrZSB0aGUgdGVtcG9yYXJ5IHRyYW5zaXRpb25cbiAgICAvLyBjbGFzc2VzIGludG8gYWNjb3VudC5cbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTVkcpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcbiAgICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY3VycmVudERpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAoaXNDc3NTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldikge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBgZGlzcGxheWAgb2YgdGhlIGVsZW1lbnQgaXMgY29udHJvbGxlZCBieSBgdi1zaG93YCxcbiAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWBcbiAgICAgICAgLy8gdmFsdWUsIHRodXMgaGFuZGluZyBvdmVyIGNvbnRyb2wgdG8gYHYtc2hvd2AuXG4gICAgICAgIGlmICgnX3ZvZCcgaW4gZWwpIHtcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbC5mb3JFYWNoKHYgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHZhbCA9ICcnO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBpZiAoc2VtaWNvbG9uUkUudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnR5IGRlZmluaXRpb25cbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgIC8vICFpbXBvcnRhbnRcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUocHJlZml4ZWQpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcbiAgICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWUpO1xuICAgIH1cbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhd05hbWU7XG59XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSkge1xuICAgIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aCgneGxpbms6JykpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm90ZSB3ZSBhcmUgb25seSBjaGVja2luZyBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCBkb24ndCBoYXZlIGFcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkb20gcHJvcCBvZiB0aGUgc2FtZSBuYW1lIGhlcmUuXG4gICAgICAgIGNvbnN0IGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzQm9vbGVhbiA/ICcnIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBfX1VOU0FGRV9fXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIFxuLy8gdGhlIGZvbGxvd2luZyBhcmdzIGFyZSBwYXNzZWQgb25seSBkdWUgdG8gcG90ZW50aWFsIGlubmVySFRNTC90ZXh0Q29udGVudFxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcbi8vIHVubW91bnRlZC5cbnByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSB7XG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmXG4gICAgICAgIGVsLnRhZ05hbWUgIT09ICdQUk9HUkVTUycgJiZcbiAgICAgICAgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgICAgICAgIWVsLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkLlxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSB8fFxuICAgICAgICAgICAgLy8gIzQ5NTY6IGFsd2F5cyBzZXQgZm9yIE9QVElPTiBlbGVtZW50cyBiZWNhdXNlIGl0cyB2YWx1ZSBmYWxscyBiYWNrIHRvXG4gICAgICAgICAgICAvLyB0ZXh0Q29udGVudCBpZiBubyB2YWx1ZSBhdHRyaWJ1dGUgaXMgcHJlc2VudC4gQW5kIHNldHRpbmcgLnZhbHVlIGZvclxuICAgICAgICAgICAgLy8gT1BUSU9OIGhhcyBubyBzaWRlIGVmZmVjdFxuICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ09QVElPTicpIHtcbiAgICAgICAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5lZWRSZW1vdmUgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAvLyBlLmcuIDxzZWxlY3QgbXVsdGlwbGU+IGNvbXBpbGVzIHRvIHsgbXVsdGlwbGU6ICcnIH1cbiAgICAgICAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBlLmcuIDxkaXYgOmlkPVwibnVsbFwiPlxuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBlLmcuIDxpbWcgOndpZHRoPVwibnVsbFwiPlxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3csXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIGhhcyBnZXR0ZXIsIG5vIHNldHRlciwgd2lsbCBlcnJvciBpbiAndXNlIHN0cmljdCdcbiAgICAvLyBlZy4gPHNlbGVjdCA6dHlwZT1cIm51bGxcIj48L3NlbGVjdD4gPHNlbGVjdCA6d2lsbFZhbGlkYXRlPVwibnVsbFwiPjwvc2VsZWN0PlxuICAgIHRyeSB7XG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90IHdhcm4gaWYgdmFsdWUgaXMgYXV0by1jb2VyY2VkIGZyb20gbnVsbGlzaCB2YWx1ZXNcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgICAgICAgd2FybihgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcbiAgICAgICAgICAgICAgICBgdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZWVkUmVtb3ZlICYmIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcbiAgICBjb25zdCBpbnZva2VycyA9IGVsLl92ZWkgfHwgKGVsLl92ZWkgPSB7fSk7XG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgICAgLy8gcGF0Y2hcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSAnOicgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICAgIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xufVxuLy8gVG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mIHJlcGVhdGVkbHkgY2FsbGluZyBEYXRlLm5vdygpLCB3ZSBjYWNoZVxuLy8gYW5kIHVzZSB0aGUgc2FtZSB0aW1lc3RhbXAgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgaW4gdGhlIHNhbWUgdGljay5cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qI19fUFVSRV9fKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbigoKSA9PiAoY2FjaGVkTm93ID0gMCkpLCAoY2FjaGVkTm93ID0gRGF0ZS5ub3coKSkpO1xuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XG4gICAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XG4gICAgICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSB2dWVqcy92dWUjNjU2NlxuICAgICAgICAvLyBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAgICAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAgICAgICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgLy8gdGhpcyBubyBsb25nZXIgaGFwcGVucyBmb3IgdGVtcGxhdGVzIGluIFZ1ZSAzLCBidXQgY291bGQgc3RpbGwgYmVcbiAgICAgICAgLy8gdGhlb3JldGljYWxseSBwb3NzaWJsZSBmb3IgaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gICAgICAgIC8vIHRoZSBzb2x1dGlvbjogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAgICAgICAvLyBhbmQgYWxzbyBhdHRhY2ggdGhlIHRpbWVzdGFtcCB0byBhbnkgZXZlbnQgdGhhdCB3YXMgaGFuZGxlZCBieSB2dWVcbiAgICAgICAgLy8gZm9yIHRoZSBmaXJzdCB0aW1lICh0byBhdm9pZCBpbmNvbnNpc3RlbnQgZXZlbnQgdGltZXN0YW1wIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAvLyBvciBldmVudHMgZmlyZWQgZnJvbSBpZnJhbWVzLCBlLmcuICMyNTEzKVxuICAgICAgICAvLyBUaGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICAgICAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLl92dHMgPD0gaW52b2tlci5hdHRhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLCBpbnN0YW5jZSwgNSAvKiBFcnJvckNvZGVzLk5BVElWRV9FVkVOVF9IQU5ETEVSICovLCBbZV0pO1xuICAgIH07XG4gICAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gICAgcmV0dXJuIGludm9rZXI7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgICAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZuID0+IChlKSA9PiAhZS5fc3RvcHBlZCAmJiBmbiAmJiBmbihlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5jb25zdCBuYXRpdmVPblJFID0gL15vblthLXpdLztcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaXNTVkcgPSBmYWxzZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pID0+IHtcbiAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgICAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5WzBdID09PSAnLidcbiAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIHRydWUpXG4gICAgICAgIDoga2V5WzBdID09PSAnXidcbiAgICAgICAgICAgID8gKChrZXkgPSBrZXkuc2xpY2UoMSkpLCBmYWxzZSlcbiAgICAgICAgICAgIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPGlucHV0IHYtbW9kZWwgdHlwZT1cImNoZWNrYm94XCI+IHdpdGhcbiAgICAgICAgLy8gOnRydWUtdmFsdWUgJiA6ZmFsc2UtdmFsdWVcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxuICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgaWYgKGtleSA9PT0gJ3RydWUtdmFsdWUnKSB7XG4gICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2ZhbHNlLXZhbHVlJykge1xuICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XG4gICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgIC8vIG1vc3Qga2V5cyBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGUgb24gc3ZnIGVsZW1lbnRzIHRvIHdvcmtcbiAgICAgICAgLy8gLi4uZXhjZXB0IGlubmVySFRNTCAmIHRleHRDb250ZW50XG4gICAgICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3IgbmF0aXZlIG9uY2xpY2sgd2l0aCBmdW5jdGlvbiB2YWx1ZXNcbiAgICAgICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB0aGVzZSBhcmUgZW51bWVyYXRlZCBhdHRycywgaG93ZXZlciB0aGVpciBjb3JyZXNwb25kaW5nIERPTSBwcm9wZXJ0aWVzXG4gICAgLy8gYXJlIGFjdHVhbGx5IGJvb2xlYW5zIC0gdGhpcyBsZWFkcyB0byBzZXR0aW5nIGl0IHdpdGggYSBzdHJpbmcgXCJmYWxzZVwiXG4gICAgLy8gdmFsdWUgbGVhZGluZyBpdCB0byBiZSBjb2VyY2VkIHRvIGB0cnVlYCwgc28gd2UgbmVlZCB0byBhbHdheXMgdHJlYXRcbiAgICAvLyB0aGVtIGFzIGF0dHJpYnV0ZXMuXG4gICAgLy8gTm90ZSB0aGF0IGBjb250ZW50RWRpdGFibGVgIGRvZXNuJ3QgaGF2ZSB0aGlzIHByb2JsZW06IGl0cyBET01cbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIGVudW1lcmF0ZWQgc3RyaW5nIHZhbHVlcy5cbiAgICBpZiAoa2V5ID09PSAnc3BlbGxjaGVjaycgfHwga2V5ID09PSAnZHJhZ2dhYmxlJyB8fCBrZXkgPT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gIzE3ODcsICMyODQwIGZvcm0gcHJvcGVydHkgb24gZm9ybSBlbGVtZW50cyBpcyByZWFkb25seSBhbmQgbXVzdCBiZSBzZXQgYXNcbiAgICAvLyBhdHRyaWJ1dGUuXG4gICAgaWYgKGtleSA9PT0gJ2Zvcm0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gIzE1MjYgPGlucHV0IGxpc3Q+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxuICAgIGlmIChrZXkgPT09ICdsaXN0JyAmJiBlbC50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gIzI3NjYgPHRleHRhcmVhIHR5cGU+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxuICAgIGlmIChrZXkgPT09ICd0eXBlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbmF0aXZlIG9uY2xpY2sgd2l0aCBzdHJpbmcgdmFsdWUsIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxuICAgIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpIHtcbiAgICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpO1xuICAgIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIGh5ZHJhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAoKG9wdGlvbnMpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgaHlkcmF0ZSk7XG59KTtcbmNvbnN0IEJhc2VDbGFzcyA9ICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XG59KTtcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBoeWRyYXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2RlZiA9IF9kZWY7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgaHlkcmF0ZSh0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgYCArXG4gICAgICAgICAgICAgICAgICAgIGBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIHN5bmMgY29tcG9uZW50IGRlZnMgd2UgY2FuIGltbWVkaWF0ZWx5IHJlc29sdmUgcHJvcHNcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHModGhpcy5fZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAgICovXG4gICAgX3Jlc29sdmVEZWYoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgYXR0cnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhdGNoIGZ1dHVyZSBhdHRyIGNoYW5nZXNcbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgICAgICAgIC8vIGNhc3QgTnVtYmVyLXR5cGUgcHJvcHMgc2V0IGJlZm9yZSByZXNvbHZlXG4gICAgICAgICAgICBsZXQgbnVtYmVyUHJvcHM7XG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgIWlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdCA9PT0gTnVtYmVyIHx8IChvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2NhbWVsaXplJDEoa2V5KV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcbiAgICAgICAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5pbmcgZ2V0dGVyL3NldHRlcnMgb24gcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgLy8gZm9yIHN5bmMgZGVmcywgdGhpcyBhbHJlYWR5IGhhcHBlbmVkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyhkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwbHkgQ1NTXG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xuICAgICAgICBpZiAoYXN5bmNEZWYpIHtcbiAgICAgICAgICAgIGFzeW5jRGVmKCkudGhlbihkZWYgPT4gcmVzb2x2ZShkZWYsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5fZGVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVzb2x2ZVByb3BzKGRlZikge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBkZWY7XG4gICAgICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgcHJvcHMgc2V0IHByZS11cGdyYWRlIG9yIGNvbm5lY3RcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICdfJyAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5pbmcgZ2V0dGVyL3NldHRlcnMgb24gcHJvdG90eXBlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKGNhbWVsaXplJDEpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2V0QXR0cihrZXkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbGl6ZSQxKGtleSk7XG4gICAgICAgIGlmICh0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1tjYW1lbEtleV0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9nZXRQcm9wKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSB0cnVlKSB7XG4gICAgICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsZWN0XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGUoKSB7XG4gICAgICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgIH1cbiAgICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoe30sIHRoaXMuX3Byb3BzKSk7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZub2RlLmNlID0gaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSE1SXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IG5ld1N0eWxlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgcmVzZXQgc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2gocyA9PiB0aGlzLnNoYWRvd1Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaCA9IChldmVudCwgYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJjZXB0IGVtaXRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIGJvdGggdGhlIHJhdyBhbmQgaHlwaGVuYXRlZCB2ZXJzaW9ucyBvZiBhbiBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBtYXRjaCBWdWUgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKGV2ZW50KSAhPT0gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGh5cGhlbmF0ZShldmVudCksIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGUgbmVhcmVzdCBWdWUgY3VzdG9tIGVsZW1lbnQgcGFyZW50IGZvciBwcm92aWRlL2luamVjdFxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlICgocGFyZW50ID1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQgPSBwYXJlbnQuX2luc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucHJvdmlkZXMgPSBwYXJlbnQuX2luc3RhbmNlLnByb3ZpZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gICAgX2FwcGx5U3R5bGVzKHN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICBzdHlsZXMuZm9yRWFjaChjc3MgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHMudGV4dENvbnRlbnQgPSBjc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHMpO1xuICAgICAgICAgICAgICAgIC8vIHJlY29yZCBmb3IgSE1SXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gJyRzdHlsZScpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XG4gICAgICAgIGlmICghbW9kdWxlcykge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFtb2QpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgU0ZDJ3MgQ1NTIHZhcmlhYmxlIGluamVjdGlvbiBmZWF0dXJlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IChpbnN0YW5jZS51dCA9ICh2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KSkgPT4ge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKSkuZm9yRWFjaChub2RlID0+IHNldFZhcnNPbk5vZGUobm9kZSwgdmFycykpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNldFZhcnMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICAgICAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICAgICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICAgIH07XG4gICAgd2F0Y2hQb3N0RWZmZWN0KHNldFZhcnMpO1xuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XG4gICAgICAgIG9iLm9ic2VydmUoaW5zdGFuY2Uuc3ViVHJlZS5lbC5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XG4gICAgICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xuICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRyaWxsIGRvd24gSE9DcyB1bnRpbCBpdCdzIGEgbm9uLWNvbXBvbmVudCB2bm9kZVxuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgICB9XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovICYmIHZub2RlLmVsKSB7XG4gICAgICAgIHNldFZhcnNPbk5vZGUodm5vZGUuZWwsIHZhcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICAgICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XG4gICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgc2V0VmFyc09uTm9kZShlbCwgdmFycyk7XG4gICAgICAgICAgICBpZiAoZWwgPT09IGFuY2hvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcbi8vIERPTSBUcmFuc2l0aW9uIGlzIGEgaGlnaGVyLW9yZGVyLWNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0tYWdub3N0aWNcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpO1xuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9ICdUcmFuc2l0aW9uJztcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjc3M6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9XG4gICAgLyojX19QVVJFX18qLyBleHRlbmQoe30sIEJhc2VUcmFuc2l0aW9uLnByb3BzLCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSk7XG4vKipcbiAqICMzMjI3IEluY29taW5nIGhvb2tzIG1heSBiZSBtZXJnZWQgaW50byBhcnJheXMgd2hlbiB3cmFwcGluZyBUcmFuc2l0aW9uXG4gKiB3aXRoIGN1c3RvbSBIT0NzLlxuICovXG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgICBob29rLmZvckVhY2goaCA9PiBoKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG9vaykge1xuICAgICAgICBob29rKC4uLmFyZ3MpO1xuICAgIH1cbn07XG4vKipcbiAqIENoZWNrIGlmIGEgaG9vayBleHBlY3RzIGEgY2FsbGJhY2sgKDJuZCBhcmcpLCB3aGljaCBtZWFucyB0aGUgdXNlclxuICogaW50ZW5kcyB0byBleHBsaWNpdGx5IGNvbnRyb2wgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gICAgcmV0dXJuIGhvb2tcbiAgICAgICAgPyBpc0FycmF5KGhvb2spXG4gICAgICAgICAgICA/IGhvb2suc29tZShoID0+IGgubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIDogaG9vay5sZW5ndGggPiAxXG4gICAgICAgIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBiYXNlUHJvcHM7XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZSA9ICd2JywgdHlwZSwgZHVyYXRpb24sIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLCBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLCBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2AgfSA9IHJhd1Byb3BzO1xuICAgIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcbiAgICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlciwgb25BcHBlYXIgPSBvbkVudGVyLCBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWQgfSA9IGJhc2VQcm9wcztcbiAgICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xuICAgICAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xuICAgICAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXI6IG1ha2VFbnRlckhvb2soZmFsc2UpLFxuICAgICAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgc28gKi1sZWF2ZS1mcm9tIGNsYXNzZXMgaW1tZWRpYXRlbHkgdGFrZSBlZmZlY3QgKCMyNTkzKVxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWxsZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUpO1xuICAgICAgICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIFtuLCBuXTtcbiAgICB9XG59XG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKHJlcywgJzx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgICAoZWwuX3Z0YyB8fFxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICBjb25zdCB7IF92dGMgfSA9IGVsO1xuICAgIGlmIChfdnRjKSB7XG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XG4gICAgICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICAgICAgICBlbC5fdnRjID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgICB9KTtcbn1cbmxldCBlbmRJZCA9IDA7XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XG4gICAgY29uc3QgaWQgPSAoZWwuX2VuZElkID0gKytlbmRJZCk7XG4gICAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChleHBsaWNpdFRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgJ2VuZCc7XG4gICAgbGV0IGVuZGVkID0gMDtcbiAgICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICAgIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfUR1cmF0aW9uYCk7XG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfUR1cmF0aW9uYCk7XG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBsZXQgdGltZW91dCA9IDA7XG4gICAgbGV0IHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICAgICAgdHlwZSA9XG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICAgIHByb3BDb3VudCxcbiAgICAgICAgaGFzVHJhbnNmb3JtXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXJcbi8vIG51bWJlcnMgaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxuLy8gKGkuZS4gYWN0aW5nIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbmZ1bmN0aW9uIHRvTXMocykge1xuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcbn1cbi8vIHN5bmNocm9ub3VzbHkgZm9yY2UgbGF5b3V0IHRvIHB1dCBlbGVtZW50cyBpbnRvIGEgY2VydGFpbiBzdGF0ZVxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xuICAgIG5hbWU6ICdUcmFuc2l0aW9uR3JvdXAnLFxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xuICAgICAgICB0YWc6IFN0cmluZyxcbiAgICAgICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgICB9KSxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3QgYWZ0ZXIgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8ICd2J30tbW92ZWA7XG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAgICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gYy5lbDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICAgICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBUcmFuc2l0aW9uR3JvdXAgZG9lcyBub3Qgc3VwcG9ydCBcIm1vZGVcIiBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZVxuICogcHJvcHMgZGVjbGFyYXRpb25zLCBidXQgZGlyZWN0IGRlbGV0ZSBvcGVyYXRpb24gaXMgY29uc2lkZXJlZCBhIHNpZGUgZWZmZWN0XG4gKiBhbmQgd2lsbCBtYWtlIHRoZSBlbnRpcmUgdHJhbnNpdGlvbiBmZWF0dXJlIG5vbi10cmVlLXNoYWtlYWJsZSwgc28gd2UgZG8gaXRcbiAqIGluIGEgZnVuY3Rpb24gYW5kIG1hcmsgdGhlIGZ1bmN0aW9uJ3MgaW52b2NhdGlvbiBhcyBwdXJlLlxuICovXG5jb25zdCByZW1vdmVNb2RlID0gKHByb3BzKSA9PiBkZWxldGUgcHJvcHMubW9kZTtcbi8qI19fUFVSRV9fKi8gcmVtb3ZlTW9kZShUcmFuc2l0aW9uR3JvdXBJbXBsLnByb3BzKTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gICAgY29uc3QgZWwgPSBjLmVsO1xuICAgIGlmIChlbC5fbW92ZUNiKSB7XG4gICAgICAgIGVsLl9tb3ZlQ2IoKTtcbiAgICB9XG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gICAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAvLyBpcyBhcHBsaWVkLlxuICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgaWYgKGVsLl92dGMpIHtcbiAgICAgICAgZWwuX3Z0Yy5mb3JFYWNoKGNscyA9PiB7XG4gICAgICAgICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29uc3QgY29udGFpbmVyID0gKHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddIHx8XG4gICAgICAgIChmYWxzZSApO1xuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XG4gICAgfVxufVxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09ICdudW1iZXInKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGxvb3NlVG9OdW1iZXIoZG9tVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX2Fzc2lnbihkb21WYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICAvLyBhdm9pZCBjbGVhcmluZyB1bnJlc29sdmVkIHRleHQuICMyMzAyXG4gICAgICAgIGlmIChlbC5jb21wb3NpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCAmJiBlbC50eXBlICE9PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICBpZiAobGF6eSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiZcbiAgICAgICAgICAgICAgICBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcbiAgICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgICBkZWVwOiB0cnVlLFxuICAgIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xuICAgICAgICAgICAgY29uc3QgYXNzaWduID0gZWwuX2Fzc2lnbjtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXG4gICAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICAgICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICAgIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gICAgZGVlcDogdHJ1ZSxcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICAgICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgIC5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IGxvb3NlVG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobykpO1xuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgID8gaXNTZXRNb2RlbFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsWzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICB9LFxuICAgIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cbiAgICAvLyA8b3B0aW9uPnMuXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgfSxcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5KHZhbHVlKSAmJiAhaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xuICAgICAgICAgICAgICAgIGBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgfVxufVxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xufVxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIGZvciB0cnVlLXZhbHVlIGFuZCBmYWxzZS12YWx1ZSBzZXQgdmlhIDp0cnVlLXZhbHVlIG9yIDpmYWxzZS12YWx1ZSBiaW5kaW5nc1xuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xuICAgIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcbn1cbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XG4gICAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdjcmVhdGVkJyk7XG4gICAgfSxcbiAgICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ21vdW50ZWQnKTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfSxcbiAgICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICd1cGRhdGVkJyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xuICAgIHN3aXRjaCAodGFnTmFtZSkge1xuICAgICAgICBjYXNlICdTRUxFQ1QnOlxuICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxuICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoZWwudGFnTmFtZSwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSk7XG4gICAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xuICAgIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbi8vIFNTUiB2bm9kZSB0cmFuc2Zvcm1zLCBvbmx5IHVzZWQgd2hlbiB1c2VyIGluY2x1ZGVzIGNsaWVudC1vcmllbnRlZCByZW5kZXJcbi8vIGZ1bmN0aW9uIGluIFNTUlxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcbiAgICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XG4gICAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2bm9kZS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgICAgdm5vZGUudHlwZS50b1VwcGVyQ2FzZSgpLCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKTtcbiAgICAgICAgaWYgKG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICAgIHByZXZlbnQ6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgIHNlbGY6IGUgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXG4gICAgc2hpZnQ6IGUgPT4gIWUuc2hpZnRLZXksXG4gICAgYWx0OiBlID0+ICFlLmFsdEtleSxcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXG4gICAgbGVmdDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxuICAgIG1pZGRsZTogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gICAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKG0gPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XG4gICAgICAgICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gICAgfTtcbn07XG4vLyBLZXB0IGZvciAyLnggY29tcGF0LlxuLy8gTm90ZTogSUUxMSBjb21wYXQgZm9yIGBzcGFjZWJhcmAgYW5kIGBkZWxgIGlzIHJlbW92ZWQgZm9yIG5vdy5cbmNvbnN0IGtleU5hbWVzID0ge1xuICAgIGVzYzogJ2VzY2FwZScsXG4gICAgc3BhY2U6ICcgJyxcbiAgICB1cDogJ2Fycm93LXVwJyxcbiAgICBsZWZ0OiAnYXJyb3ctbGVmdCcsXG4gICAgcmlnaHQ6ICdhcnJvdy1yaWdodCcsXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxuICAgIGRlbGV0ZTogJ2JhY2tzcGFjZSdcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghKCdrZXknIGluIGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XG4gICAgICAgIGlmIChtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgdlNob3cgPSB7XG4gICAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICAgICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fdm9kIDogJ25vbmUnO1xufVxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxuLy8gZnVuY3Rpb24gaW4gU1NSXG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gICAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9IH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcbi8vIGxhenkgY3JlYXRlIHRoZSByZW5kZXJlciAtIHRoaXMgbWFrZXMgY29yZSByZW5kZXJlciBsb2dpYyB0cmVlLXNoYWthYmxlXG4vLyBpbiBjYXNlIHRoZSB1c2VyIG9ubHkgaW1wb3J0cyByZWFjdGl2aXR5IHV0aWxpdGllcyBmcm9tIFZ1ZS5cbmxldCByZW5kZXJlcjtcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gKHJlbmRlcmVyIHx8XG4gICAgICAgIChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxuICAgICAgICA/IHJlbmRlcmVyXG4gICAgICAgIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVuZGVyZXI7XG59XG4vLyB1c2UgZXhwbGljaXQgdHlwZSBjYXN0cyBoZXJlIHRvIGF2b2lkIGltcG9ydCgpIGNhbGxzIGluIHJvbGxlZC11cCBkLnRzXG5jb25zdCByZW5kZXIgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn0pO1xuY29uc3QgaHlkcmF0ZSA9ICgoLi4uYXJncykgPT4ge1xuICAgIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn0pO1xuY29uc3QgY3JlYXRlQXBwID0gKCguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICAgIH1cbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIF9fVU5TQUZFX19cbiAgICAgICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXG4gICAgICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3NcbiAgICAgICAgICAgIC8vIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHVzZXIgZGF0YS5cbiAgICAgICAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgY29udGVudCBiZWZvcmUgbW91bnRpbmdcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xuICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS12LWFwcCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xufSk7XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gICAgfVxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xufSk7XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgICAvLyBJbmplY3QgYGlzTmF0aXZlVGFnYFxuICAgIC8vIHRoaXMgaXMgdXNlZCBmb3IgY29tcG9uZW50IG5hbWUgdmFsaWRhdGlvbiAoZGV2IG9ubHkpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc05hdGl2ZVRhZycsIHtcbiAgICAgICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xufVxuLy8gZGV2IG9ubHlcbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xuICAgIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNDdXN0b21FbGVtZW50Jywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgYCArXG4gICAgICAgICAgICAgICAgICAgIGBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGAgK1xuICAgICAgICAgICAgYGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIGAgK1xuICAgICAgICAgICAgYFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIGAgK1xuICAgICAgICAgICAgYG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxcbmAgK1xuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cXG5gICtcbiAgICAgICAgICAgIGAtIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxcbmAgK1xuICAgICAgICAgICAgYC0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1kb21gO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2NvbXBpbGVyT3B0aW9ucycsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFyZXMpIHtcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICB3aW5kb3cuU2hhZG93Um9vdCAmJlxuICAgICAgICBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJlxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgd2FybihgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2ApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgICAgICAgICAgaW5pdFZTaG93Rm9yU1NSKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiJdLCJuYW1lcyI6WyJ3YXJuIiwiY2FtZWxpemUiLCJjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyIsImRlZmluZUNvbXBvbmVudCIsIm5leHRUaWNrIiwiY3JlYXRlVk5vZGUiLCJnZXRDdXJyZW50SW5zdGFuY2UiLCJ3YXRjaFBvc3RFZmZlY3QiLCJvbk1vdW50ZWQiLCJvblVubW91bnRlZCIsIkZyYWdtZW50IiwiU3RhdGljIiwiaCIsIkJhc2VUcmFuc2l0aW9uIiwiYXNzZXJ0TnVtYmVyIiwidXNlVHJhbnNpdGlvblN0YXRlIiwib25VcGRhdGVkIiwidG9SYXciLCJnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4iLCJzZXRUcmFuc2l0aW9uSG9va3MiLCJyZXNvbHZlVHJhbnNpdGlvbkhvb2tzIiwiaXNSdW50aW1lT25seSIsImNyZWF0ZVJlbmRlcmVyIiwiY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIiLCJpc1N0cmluZyIsImlzQXJyYXkiLCJoeXBoZW5hdGUiLCJjYXBpdGFsaXplIiwiaXNTcGVjaWFsQm9vbGVhbkF0dHIiLCJpbmNsdWRlQm9vbGVhbkF0dHIiLCJpc09uIiwiaXNNb2RlbExpc3RlbmVyIiwiaXNGdW5jdGlvbiIsImNhbWVsaXplJDEiLCJ0b051bWJlciIsImV4dGVuZCIsIkVNUFRZX09CSiIsImlzT2JqZWN0IiwibG9vc2VUb051bWJlciIsImxvb3NlSW5kZXhPZiIsImlzU2V0IiwibG9vc2VFcXVhbCIsImludm9rZUFycmF5Rm5zIiwiaXNIVE1MVGFnIiwiaXNTVkdUYWciLCJzdmdOUyIsImRvYyIsImRvY3VtZW50IiwidGVtcGxhdGVDb250YWluZXIiLCJjcmVhdGVFbGVtZW50Iiwibm9kZU9wcyIsImluc2VydCIsImNoaWxkIiwicGFyZW50IiwiYW5jaG9yIiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidGFnIiwiaXNTVkciLCJpcyIsInByb3BzIiwiZWwiLCJjcmVhdGVFbGVtZW50TlMiLCJ1bmRlZmluZWQiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZVRleHQiLCJ0ZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50Iiwic2V0VGV4dCIsIm5vZGUiLCJub2RlVmFsdWUiLCJzZXRFbGVtZW50VGV4dCIsInRleHRDb250ZW50IiwibmV4dFNpYmxpbmciLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0b3IiLCJzZXRTY29wZUlkIiwiaWQiLCJpbnNlcnRTdGF0aWNDb250ZW50IiwiY29udGVudCIsInN0YXJ0IiwiZW5kIiwiYmVmb3JlIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdENoaWxkIiwiY2xvbmVOb2RlIiwiaW5uZXJIVE1MIiwidGVtcGxhdGUiLCJ3cmFwcGVyIiwiZmlyc3RDaGlsZCIsImFwcGVuZENoaWxkIiwicGF0Y2hDbGFzcyIsInZhbHVlIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJfdnRjIiwiam9pbiIsInJlbW92ZUF0dHJpYnV0ZSIsImNsYXNzTmFtZSIsInBhdGNoU3R5bGUiLCJwcmV2IiwibmV4dCIsInN0eWxlIiwiaXNDc3NTdHJpbmciLCJrZXkiLCJzZXRTdHlsZSIsImN1cnJlbnREaXNwbGF5IiwiZGlzcGxheSIsImNzc1RleHQiLCJzZW1pY29sb25SRSIsImltcG9ydGFudFJFIiwibmFtZSIsInZhbCIsImZvckVhY2giLCJ2IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidGVzdCIsInN0YXJ0c1dpdGgiLCJzZXRQcm9wZXJ0eSIsInByZWZpeGVkIiwiYXV0b1ByZWZpeCIsInJlcGxhY2UiLCJwcmVmaXhlcyIsInByZWZpeENhY2hlIiwicmF3TmFtZSIsImNhY2hlZCIsImkiLCJsZW5ndGgiLCJ4bGlua05TIiwicGF0Y2hBdHRyIiwiaW5zdGFuY2UiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNsaWNlIiwic2V0QXR0cmlidXRlTlMiLCJpc0Jvb2xlYW4iLCJwYXRjaERPTVByb3AiLCJwcmV2Q2hpbGRyZW4iLCJwYXJlbnRDb21wb25lbnQiLCJwYXJlbnRTdXNwZW5zZSIsInVubW91bnRDaGlsZHJlbiIsInRhZ05hbWUiLCJpbmNsdWRlcyIsIl92YWx1ZSIsIm5ld1ZhbHVlIiwibmVlZFJlbW92ZSIsInR5cGUiLCJlIiwidG9Mb3dlckNhc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJoYW5kbGVyIiwib3B0aW9ucyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXRjaEV2ZW50IiwicHJldlZhbHVlIiwibmV4dFZhbHVlIiwiaW52b2tlcnMiLCJfdmVpIiwiZXhpc3RpbmdJbnZva2VyIiwicGFyc2VOYW1lIiwiaW52b2tlciIsImNyZWF0ZUludm9rZXIiLCJvcHRpb25zTW9kaWZpZXJSRSIsIm0iLCJtYXRjaCIsImNhY2hlZE5vdyIsInAiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldE5vdyIsInRoZW4iLCJEYXRlIiwibm93IiwiaW5pdGlhbFZhbHVlIiwiX3Z0cyIsImF0dGFjaGVkIiwicGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJvcmlnaW5hbFN0b3AiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJjYWxsIiwiX3N0b3BwZWQiLCJtYXAiLCJmbiIsIm5hdGl2ZU9uUkUiLCJwYXRjaFByb3AiLCJzaG91bGRTZXRBc1Byb3AiLCJfdHJ1ZVZhbHVlIiwiX2ZhbHNlVmFsdWUiLCJkZWZpbmVDdXN0b21FbGVtZW50IiwiaHlkcmF0ZSIsIkNvbXAiLCJWdWVDdXN0b21FbGVtZW50IiwiVnVlRWxlbWVudCIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFByb3BzIiwiZGVmIiwiZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCIsIkJhc2VDbGFzcyIsIkhUTUxFbGVtZW50IiwiX2RlZiIsIl9wcm9wcyIsIl9pbnN0YW5jZSIsIl9jb25uZWN0ZWQiLCJfcmVzb2x2ZWQiLCJfbnVtYmVyUHJvcHMiLCJzaGFkb3dSb290IiwiX2NyZWF0ZVZOb2RlIiwiYXR0YWNoU2hhZG93IiwibW9kZSIsIl9fYXN5bmNMb2FkZXIiLCJfcmVzb2x2ZVByb3BzIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJfdXBkYXRlIiwiX3Jlc29sdmVEZWYiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsInJlbmRlciIsImF0dHJpYnV0ZXMiLCJfc2V0QXR0ciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJhdHRyaWJ1dGVOYW1lIiwib2JzZXJ2ZSIsImlzQXN5bmMiLCJzdHlsZXMiLCJudW1iZXJQcm9wcyIsIm9wdCIsIk51bWJlciIsIk9iamVjdCIsImNyZWF0ZSIsIl9hcHBseVN0eWxlcyIsImFzeW5jRGVmIiwiZGVjbGFyZWRQcm9wS2V5cyIsImtleXMiLCJfc2V0UHJvcCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiX2dldFByb3AiLCJzZXQiLCJnZXRBdHRyaWJ1dGUiLCJjYW1lbEtleSIsInNob3VsZFJlZmxlY3QiLCJzaG91bGRVcGRhdGUiLCJ2bm9kZSIsImNlIiwiaXNDRSIsImNlUmVsb2FkIiwibmV3U3R5bGVzIiwiX3N0eWxlcyIsInMiLCJkaXNwYXRjaCIsImFyZ3MiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJlbWl0IiwiaG9zdCIsInByb3ZpZGVzIiwiY3NzIiwicHVzaCIsInVzZUNzc01vZHVsZSIsIm1vZHVsZXMiLCJfX2Nzc01vZHVsZXMiLCJtb2QiLCJ1c2VDc3NWYXJzIiwiZ2V0dGVyIiwidXBkYXRlVGVsZXBvcnRzIiwidXQiLCJ2YXJzIiwicHJveHkiLCJBcnJheSIsImZyb20iLCJxdWVyeVNlbGVjdG9yQWxsIiwidWlkIiwic2V0VmFyc09uTm9kZSIsInNldFZhcnMiLCJzZXRWYXJzT25WTm9kZSIsInN1YlRyZWUiLCJvYiIsImNoaWxkTGlzdCIsImRpc2Nvbm5lY3QiLCJzaGFwZUZsYWciLCJzdXNwZW5zZSIsImFjdGl2ZUJyYW5jaCIsInBlbmRpbmdCcmFuY2giLCJpc0h5ZHJhdGluZyIsImVmZmVjdHMiLCJjb21wb25lbnQiLCJjaGlsZHJlbiIsImMiLCJub2RlVHlwZSIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJUcmFuc2l0aW9uIiwic2xvdHMiLCJyZXNvbHZlVHJhbnNpdGlvblByb3BzIiwiZGlzcGxheU5hbWUiLCJET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzIiwiU3RyaW5nIiwiQm9vbGVhbiIsImRlZmF1bHQiLCJkdXJhdGlvbiIsImVudGVyRnJvbUNsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImVudGVyVG9DbGFzcyIsImFwcGVhckZyb21DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImxlYXZlRnJvbUNsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsIlRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJjYWxsSG9vayIsImhvb2siLCJoYXNFeHBsaWNpdENhbGxiYWNrIiwic29tZSIsInJhd1Byb3BzIiwiYmFzZVByb3BzIiwiZHVyYXRpb25zIiwibm9ybWFsaXplRHVyYXRpb24iLCJlbnRlckR1cmF0aW9uIiwibGVhdmVEdXJhdGlvbiIsIm9uQmVmb3JlRW50ZXIiLCJvbkVudGVyIiwib25FbnRlckNhbmNlbGxlZCIsIm9uTGVhdmUiLCJvbkxlYXZlQ2FuY2VsbGVkIiwib25CZWZvcmVBcHBlYXIiLCJvbkFwcGVhciIsIm9uQXBwZWFyQ2FuY2VsbGVkIiwiZmluaXNoRW50ZXIiLCJpc0FwcGVhciIsImRvbmUiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJmaW5pc2hMZWF2ZSIsIl9pc0xlYXZpbmciLCJtYWtlRW50ZXJIb29rIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZm9yY2VSZWZsb3ciLCJOdW1iZXJPZiIsImVudGVyIiwibGVhdmUiLCJuIiwicmVzIiwiY2xzIiwic3BsaXQiLCJjbGFzc0xpc3QiLCJhZGQiLCJTZXQiLCJkZWxldGUiLCJzaXplIiwiY2IiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJlbmRJZCIsImV4cGVjdGVkVHlwZSIsImV4cGxpY2l0VGltZW91dCIsIl9lbmRJZCIsInJlc29sdmVJZk5vdFN0YWxlIiwic2V0VGltZW91dCIsInRpbWVvdXQiLCJwcm9wQ291bnQiLCJnZXRUcmFuc2l0aW9uSW5mbyIsImVuZEV2ZW50IiwiZW5kZWQiLCJvbkVuZCIsInRhcmdldCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRTdHlsZVByb3BlcnRpZXMiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJNYXRoIiwibWF4IiwiaGFzVHJhbnNmb3JtIiwidG9TdHJpbmciLCJkZWxheXMiLCJjb25jYXQiLCJkIiwidG9NcyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJwb3NpdGlvbk1hcCIsIldlYWtNYXAiLCJuZXdQb3NpdGlvbk1hcCIsIlRyYW5zaXRpb25Hcm91cEltcGwiLCJtb3ZlQ2xhc3MiLCJzZXR1cCIsInN0YXRlIiwiaGFzQ1NTVHJhbnNmb3JtIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsIm1vdmVkQ2hpbGRyZW4iLCJmaWx0ZXIiLCJhcHBseVRyYW5zbGF0aW9uIiwidHJhbnNmb3JtIiwid2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsImNzc1RyYW5zaXRpb25Qcm9wcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlbW92ZU1vZGUiLCJUcmFuc2l0aW9uR3JvdXAiLCJfZW50ZXJDYiIsIm9sZFBvcyIsIm5ld1BvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicm9vdCIsImNsb25lIiwiY29udGFpbmVyIiwiZ2V0TW9kZWxBc3NpZ25lciIsIm9uQ29tcG9zaXRpb25TdGFydCIsImNvbXBvc2luZyIsIm9uQ29tcG9zaXRpb25FbmQiLCJFdmVudCIsInZNb2RlbFRleHQiLCJjcmVhdGVkIiwibW9kaWZpZXJzIiwibGF6eSIsInRyaW0iLCJudW1iZXIiLCJfYXNzaWduIiwiY2FzdFRvTnVtYmVyIiwiZG9tVmFsdWUiLCJtb3VudGVkIiwiYmVmb3JlVXBkYXRlIiwiYWN0aXZlRWxlbWVudCIsInZNb2RlbENoZWNrYm94IiwiZGVlcCIsIl8iLCJtb2RlbFZhbHVlIiwiX21vZGVsVmFsdWUiLCJlbGVtZW50VmFsdWUiLCJnZXRWYWx1ZSIsImNoZWNrZWQiLCJhc3NpZ24iLCJpbmRleCIsImZvdW5kIiwiZmlsdGVyZWQiLCJzcGxpY2UiLCJjbG9uZWQiLCJnZXRDaGVja2JveFZhbHVlIiwic2V0Q2hlY2tlZCIsImJpbmRpbmciLCJvbGRWYWx1ZSIsImhhcyIsInZNb2RlbFJhZGlvIiwidk1vZGVsU2VsZWN0IiwiaXNTZXRNb2RlbCIsInNlbGVjdGVkVmFsIiwicHJvdG90eXBlIiwibyIsInNlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJfYmluZGluZyIsInVwZGF0ZWQiLCJpc011bHRpcGxlIiwibCIsIm9wdGlvbiIsIm9wdGlvblZhbHVlIiwic2VsZWN0ZWRJbmRleCIsInZNb2RlbER5bmFtaWMiLCJjYWxsTW9kZWxIb29rIiwicHJldlZOb2RlIiwicmVzb2x2ZUR5bmFtaWNNb2RlbCIsIm1vZGVsVG9Vc2UiLCJpbml0Vk1vZGVsRm9yU1NSIiwiZ2V0U1NSUHJvcHMiLCJ0b1VwcGVyQ2FzZSIsInN5c3RlbU1vZGlmaWVycyIsIm1vZGlmaWVyR3VhcmRzIiwic3RvcCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInNlbGYiLCJjdXJyZW50VGFyZ2V0IiwiY3RybCIsImN0cmxLZXkiLCJzaGlmdCIsInNoaWZ0S2V5IiwiYWx0IiwiYWx0S2V5IiwibWV0YSIsIm1ldGFLZXkiLCJidXR0b24iLCJtaWRkbGUiLCJyaWdodCIsImV4YWN0Iiwid2l0aE1vZGlmaWVycyIsImd1YXJkIiwia2V5TmFtZXMiLCJlc2MiLCJzcGFjZSIsInVwIiwiZG93biIsIndpdGhLZXlzIiwiZXZlbnRLZXkiLCJrIiwidlNob3ciLCJiZWZvcmVNb3VudCIsInRyYW5zaXRpb24iLCJfdm9kIiwiYmVmb3JlRW50ZXIiLCJzZXREaXNwbGF5IiwiYmVmb3JlVW5tb3VudCIsImluaXRWU2hvd0ZvclNTUiIsInJlbmRlcmVyT3B0aW9ucyIsInJlbmRlcmVyIiwiZW5hYmxlZEh5ZHJhdGlvbiIsImVuc3VyZVJlbmRlcmVyIiwiZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIiLCJjcmVhdGVBcHAiLCJhcHAiLCJpbmplY3ROYXRpdmVUYWdDaGVjayIsImluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrIiwibW91bnQiLCJjb250YWluZXJPclNlbGVjdG9yIiwibm9ybWFsaXplQ29udGFpbmVyIiwiX2NvbXBvbmVudCIsIlNWR0VsZW1lbnQiLCJFbGVtZW50IiwiY3JlYXRlU1NSQXBwIiwiY29uZmlnIiwid3JpdGFibGUiLCJpc0N1c3RvbUVsZW1lbnQiLCJjb21waWxlck9wdGlvbnMiLCJtc2ciLCJTaGFkb3dSb290Iiwic3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQiLCJpbml0RGlyZWN0aXZlc0ZvclNTUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9242\n")},7139:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C_\": function() { return /* binding */ normalizeClass; },\n/* harmony export */   \"DM\": function() { return /* binding */ isSet; },\n/* harmony export */   \"E9\": function() { return /* binding */ getGlobalThis; },\n/* harmony export */   \"F7\": function() { return /* binding */ isOn; },\n/* harmony export */   \"Gg\": function() { return /* binding */ isReservedProp; },\n/* harmony export */   \"HD\": function() { return /* binding */ isString; },\n/* harmony export */   \"He\": function() { return /* binding */ toNumber; },\n/* harmony export */   \"Kj\": function() { return /* binding */ isRegExp; },\n/* harmony export */   \"Kn\": function() { return /* binding */ isObject; },\n/* harmony export */   \"NO\": function() { return /* binding */ NO; },\n/* harmony export */   \"Nj\": function() { return /* binding */ def; },\n/* harmony export */   \"Od\": function() { return /* binding */ remove; },\n/* harmony export */   \"PO\": function() { return /* binding */ isPlainObject; },\n/* harmony export */   \"Pq\": function() { return /* binding */ isSpecialBooleanAttr; },\n/* harmony export */   \"RI\": function() { return /* binding */ hasOwn; },\n/* harmony export */   \"S0\": function() { return /* binding */ isIntegerKey; },\n/* harmony export */   \"W7\": function() { return /* binding */ toRawType; },\n/* harmony export */   \"WV\": function() { return /* binding */ looseEqual; },\n/* harmony export */   \"Z6\": function() { return /* binding */ EMPTY_ARR; },\n/* harmony export */   \"_A\": function() { return /* binding */ camelize; },\n/* harmony export */   \"_N\": function() { return /* binding */ isMap; },\n/* harmony export */   \"aU\": function() { return /* binding */ hasChanged; },\n/* harmony export */   \"dG\": function() { return /* binding */ NOOP; },\n/* harmony export */   \"e1\": function() { return /* binding */ isGloballyundefineded; },\n/* harmony export */   \"fY\": function() { return /* binding */ makeMap; },\n/* harmony export */   \"h5\": function() { return /* binding */ looseToNumber; },\n/* harmony export */   \"hR\": function() { return /* binding */ toHandlerKey; },\n/* harmony export */   \"hq\": function() { return /* binding */ looseIndexOf; },\n/* harmony export */   \"ir\": function() { return /* binding */ invokeArrayFns; },\n/* harmony export */   \"j5\": function() { return /* binding */ normalizeStyle; },\n/* harmony export */   \"kC\": function() { return /* binding */ capitalize; },\n/* harmony export */   \"kJ\": function() { return /* binding */ isArray; },\n/* harmony export */   \"kT\": function() { return /* binding */ EMPTY_OBJ; },\n/* harmony export */   \"l7\": function() { return /* binding */ extend; },\n/* harmony export */   \"mf\": function() { return /* binding */ isFunction; },\n/* harmony export */   \"rs\": function() { return /* binding */ hyphenate; },\n/* harmony export */   \"tI\": function() { return /* binding */ isPromise; },\n/* harmony export */   \"tR\": function() { return /* binding */ isModelListener; },\n/* harmony export */   \"yA\": function() { return /* binding */ includeBooleanAttr; },\n/* harmony export */   \"yk\": function() { return /* binding */ isSymbol; },\n/* harmony export */   \"zw\": function() { return /* binding */ toDisplayString; }\n/* harmony export */ });\n/* unused harmony exports PatchFlagNames, escapeHtml, escapeHtmlComment, genPropsAccessExp, generateCodeFrame, isBooleanAttr, isBuiltInDirective, isDate, isHTMLTag, isKnownHtmlAttr, isKnownSvgAttr, isSSRSafeAttrName, isSVGTag, isVoidTag, normalizeProps, objectToString, parseStringStyle, propsToAttrMap, slotFlagsText, stringifyStyle, toTypeString */\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n  const map = Object.create(null);\n  const list = str.split(',');\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n  [1 /* PatchFlags.TEXT */]: `TEXT`,\n  [2 /* PatchFlags.CLASS */]: `CLASS`,\n  [4 /* PatchFlags.STYLE */]: `STYLE`,\n  [8 /* PatchFlags.PROPS */]: `PROPS`,\n  [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n  [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n  [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n  [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n  [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n  [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n  [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n  [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n  [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n  [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n  [1 /* SlotFlags.STABLE */]: 'STABLE',\n  [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n  [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyundefineded = /*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  // Split the content into individual lines but capture the newline sequence\n  // that separated each line. This is important because the actual sequence is\n  // needed to properly take into account the full line length for offset\n  // comparison\n  let lines = source.split(/(\\r?\\n)/);\n  // Separate the lines and newline sequences into separate arrays for easier referencing\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          // push underline\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(1, end > count ? lineLength - pad : end - start);\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + '^'.repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join('\\n');\n}\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value)) {\n    return value;\n  } else if (isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, '').split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = '';\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n    if (isString(value) || typeof value === 'number') {\n      // only render valid values\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = '';\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + ' ';\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + ' ';\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let {\n    class: klass,\n    style\n  } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = (/* unused pure expression or super */ null && ('html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot'));\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = (/* unused pure expression or super */ null && ('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view'));\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(HTML_TAGS)));\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(SVG_TAGS)));\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(VOID_TAGS)));\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` + `loop,open,required,reversed,scoped,seamless,` + `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n  return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` + `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` + `border,buffered,capture,challenge,charset,checked,cite,class,code,` + `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` + `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` + `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` + `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` + `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` + `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` + `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` + `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` + `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` + `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` + `start,step,style,summary,tabindex,target,title,translate,type,usemap,` + `value,width,wrap`)));\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` + `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` + `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` + `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` + `color-interpolation-filters,color-profile,color-rendering,` + `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` + `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` + `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` + `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` + `font-family,font-size,font-size-adjust,font-stretch,font-style,` + `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` + `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` + `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` + `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` + `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` + `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` + `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` + `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` + `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` + `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` + `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` + `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` + `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` + `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` + `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` + `specularConstant,specularExponent,speed,spreadMethod,startOffset,` + `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` + `strikethrough-position,strikethrough-thickness,string,stroke,` + `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` + `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` + `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` + `text-decoration,text-rendering,textLength,to,transform,transform-origin,` + `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` + `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` + `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` + `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` + `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` + `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` + `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = '' + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = '';\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        // \"\n        escaped = '&quot;';\n        break;\n      case 38:\n        // &\n        escaped = '&amp;';\n        break;\n      case 39:\n        // '\n        escaped = '&#39;';\n        break;\n      case 60:\n        // <\n        escaped = '&lt;';\n        break;\n      case 62:\n        // >\n        escaped = '&gt;';\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|\x3c!--|--\x3e|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, '');\n}\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    /* istanbul ignore if: this if will probably never be called */\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = val => {\n  return isString(val) ? val : val == null ? '' : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  // can't use isRef here since @vue/shared has no deps\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n        entries[`${key} =>`] = val;\n        return entries;\n      }, {})\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()]\n    };\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst EMPTY_OBJ =  false ? 0 : {};\nconst EMPTY_ARR =  false ? 0 : [];\nconst NOOP = () => {};\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = key => onRE.test(key);\nconst isModelListener = key => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = val => toTypeString(val) === '[object Map]';\nconst isSet = val => toTypeString(val) === '[object Set]';\nconst isDate = val => toTypeString(val) === '[object Date]';\nconst isRegExp = val => toTypeString(val) === '[object RegExp]';\nconst isFunction = val => typeof val === 'function';\nconst isString = val => typeof val === 'string';\nconst isSymbol = val => typeof val === 'symbol';\nconst isObject = val => val !== null && typeof val === 'object';\nconst isPromise = val => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = value => objectToString.call(value);\nconst toRawType = value => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = val => toTypeString(val) === '[object Object]';\nconst isIntegerKey = key => isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')));\nconst cacheStringFunction = fn => {\n  const cache = Object.create(null);\n  return str => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction(str => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = val => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = val => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEzOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0EsT0FBT0EsQ0FBQ0MsR0FBRyxFQUFFQyxnQkFBZ0IsRUFBRTtFQUNwQyxNQUFNQyxHQUFHLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQztFQUMvQixNQUFNQyxJQUFJLEdBQUdMLEdBQUcsQ0FBQ00sS0FBSyxDQUFDLEdBQUcsQ0FBQztFQUMzQixLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0YsSUFBSSxDQUFDRyxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQ2xDTCxHQUFHLENBQUNHLElBQUksQ0FBQ0UsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJO0VBQ3ZCO0VBQ0EsT0FBT04sZ0JBQWdCLEdBQUdRLEdBQUcsSUFBSSxDQUFDLENBQUNQLEdBQUcsQ0FBQ08sR0FBRyxDQUFDQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUdELEdBQUcsSUFBSSxDQUFDLENBQUNQLEdBQUcsQ0FBQ08sR0FBRyxDQUFDO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLGNBQWMsR0FBRztFQUNuQixDQUFDLENBQUMsQ0FBQyx3QkFBeUIsTUFBSztFQUNqQyxDQUFDLENBQUMsQ0FBQyx5QkFBMEIsT0FBTTtFQUNuQyxDQUFDLENBQUMsQ0FBQyx5QkFBMEIsT0FBTTtFQUNuQyxDQUFDLENBQUMsQ0FBQyx5QkFBMEIsT0FBTTtFQUNuQyxDQUFDLEVBQUUsQ0FBQyw4QkFBK0IsWUFBVztFQUM5QyxDQUFDLEVBQUUsQ0FBQyxrQ0FBbUMsZ0JBQWU7RUFDdEQsQ0FBQyxFQUFFLENBQUMsbUNBQW9DLGlCQUFnQjtFQUN4RCxDQUFDLEdBQUcsQ0FBQyxrQ0FBbUMsZ0JBQWU7RUFDdkQsQ0FBQyxHQUFHLENBQUMsb0NBQXFDLGtCQUFpQjtFQUMzRCxDQUFDLEdBQUcsQ0FBQyw4QkFBK0IsWUFBVztFQUMvQyxDQUFDLElBQUksQ0FBQyxpQ0FBa0MsZUFBYztFQUN0RCxDQUFDLElBQUksQ0FBQyxxQ0FBc0MsbUJBQWtCO0VBQzlELENBQUMsQ0FBQyxDQUFDLENBQUMsMkJBQTRCLFNBQVE7RUFDeEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBeUI7QUFDakMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxhQUFhLEdBQUc7RUFDbEIsQ0FBQyxDQUFDLENBQUMseUJBQXlCLFFBQVE7RUFDcEMsQ0FBQyxDQUFDLENBQUMsMEJBQTBCLFNBQVM7RUFDdEMsQ0FBQyxDQUFDLENBQUMsNEJBQTRCO0FBQ25DLENBQUM7QUFFRCxNQUFNQyxvQkFBb0IsR0FBRyxzRUFBc0UsR0FDL0YseUVBQXlFLEdBQ3pFLHVEQUF1RDtBQUMzRCxNQUFNQyxxQkFBcUIsR0FBRyxhQUFjZixPQUFPLENBQUNjLG9CQUFvQixDQUFDO0FBRXpFLE1BQU1FLEtBQUssR0FBRyxDQUFDO0FBQ2YsU0FBU0MsaUJBQWlCQSxDQUFDQyxNQUFNLEVBQUVDLEtBQUssR0FBRyxDQUFDLEVBQUVDLEdBQUcsR0FBR0YsTUFBTSxDQUFDVCxNQUFNLEVBQUU7RUFDL0Q7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJWSxLQUFLLEdBQUdILE1BQU0sQ0FBQ1gsS0FBSyxDQUFDLFNBQVMsQ0FBQztFQUNuQztFQUNBLE1BQU1lLGdCQUFnQixHQUFHRCxLQUFLLENBQUNFLE1BQU0sQ0FBQyxDQUFDQyxDQUFDLEVBQUVDLEdBQUcsS0FBS0EsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7RUFDaEVKLEtBQUssR0FBR0EsS0FBSyxDQUFDRSxNQUFNLENBQUMsQ0FBQ0MsQ0FBQyxFQUFFQyxHQUFHLEtBQUtBLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0VBQy9DLElBQUlDLEtBQUssR0FBRyxDQUFDO0VBQ2IsTUFBTUMsR0FBRyxHQUFHLEVBQUU7RUFDZCxLQUFLLElBQUluQixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdhLEtBQUssQ0FBQ1osTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtJQUNuQ2tCLEtBQUssSUFDREwsS0FBSyxDQUFDYixDQUFDLENBQUMsQ0FBQ0MsTUFBTSxJQUNUYSxnQkFBZ0IsQ0FBQ2QsQ0FBQyxDQUFDLElBQUljLGdCQUFnQixDQUFDZCxDQUFDLENBQUMsQ0FBQ0MsTUFBTSxJQUFLLENBQUMsQ0FBQztJQUNsRSxJQUFJaUIsS0FBSyxJQUFJUCxLQUFLLEVBQUU7TUFDaEIsS0FBSyxJQUFJUyxDQUFDLEdBQUdwQixDQUFDLEdBQUdRLEtBQUssRUFBRVksQ0FBQyxJQUFJcEIsQ0FBQyxHQUFHUSxLQUFLLElBQUlJLEdBQUcsR0FBR00sS0FBSyxFQUFFRSxDQUFDLEVBQUUsRUFBRTtRQUN4RCxJQUFJQSxDQUFDLEdBQUcsQ0FBQyxJQUFJQSxDQUFDLElBQUlQLEtBQUssQ0FBQ1osTUFBTSxFQUMxQjtRQUNKLE1BQU1vQixJQUFJLEdBQUdELENBQUMsR0FBRyxDQUFDO1FBQ2xCRCxHQUFHLENBQUNHLElBQUksQ0FBRSxHQUFFRCxJQUFLLEdBQUUsR0FBRyxDQUFDRSxNQUFNLENBQUNDLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsR0FBR0MsTUFBTSxDQUFDTCxJQUFJLENBQUMsQ0FBQ3BCLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBRSxNQUFLWSxLQUFLLENBQUNPLENBQUMsQ0FBRSxFQUFDLENBQUM7UUFDcEYsTUFBTU8sVUFBVSxHQUFHZCxLQUFLLENBQUNPLENBQUMsQ0FBQyxDQUFDbkIsTUFBTTtRQUNsQyxNQUFNMkIsZ0JBQWdCLEdBQUlkLGdCQUFnQixDQUFDTSxDQUFDLENBQUMsSUFBSU4sZ0JBQWdCLENBQUNNLENBQUMsQ0FBQyxDQUFDbkIsTUFBTSxJQUFLLENBQUM7UUFDakYsSUFBSW1CLENBQUMsS0FBS3BCLENBQUMsRUFBRTtVQUNUO1VBQ0EsTUFBTTZCLEdBQUcsR0FBR2xCLEtBQUssSUFBSU8sS0FBSyxJQUFJUyxVQUFVLEdBQUdDLGdCQUFnQixDQUFDLENBQUM7VUFDN0QsTUFBTTNCLE1BQU0sR0FBR3VCLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBRWIsR0FBRyxHQUFHTSxLQUFLLEdBQUdTLFVBQVUsR0FBR0UsR0FBRyxHQUFHakIsR0FBRyxHQUFHRCxLQUFLLENBQUM7VUFDeEVRLEdBQUcsQ0FBQ0csSUFBSSxDQUFFLFFBQU8sR0FBRyxHQUFHLENBQUNDLE1BQU0sQ0FBQ00sR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDTixNQUFNLENBQUN0QixNQUFNLENBQUMsQ0FBQztRQUM3RCxDQUFDLE1BQ0ksSUFBSW1CLENBQUMsR0FBR3BCLENBQUMsRUFBRTtVQUNaLElBQUlZLEdBQUcsR0FBR00sS0FBSyxFQUFFO1lBQ2IsTUFBTWpCLE1BQU0sR0FBR3VCLElBQUksQ0FBQ0MsR0FBRyxDQUFDRCxJQUFJLENBQUNNLEdBQUcsQ0FBQ2xCLEdBQUcsR0FBR00sS0FBSyxFQUFFUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0RSLEdBQUcsQ0FBQ0csSUFBSSxDQUFFLFFBQU8sR0FBRyxHQUFHLENBQUNDLE1BQU0sQ0FBQ3RCLE1BQU0sQ0FBQyxDQUFDO1VBQzNDO1VBQ0FpQixLQUFLLElBQUlTLFVBQVUsR0FBR0MsZ0JBQWdCO1FBQzFDO01BQ0o7TUFDQTtJQUNKO0VBQ0o7RUFDQSxPQUFPVCxHQUFHLENBQUNZLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDekI7QUFFQSxTQUFTQyxjQUFjQSxDQUFDQyxLQUFLLEVBQUU7RUFDM0IsSUFBSUMsT0FBTyxDQUFDRCxLQUFLLENBQUMsRUFBRTtJQUNoQixNQUFNZCxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsS0FBSyxJQUFJbkIsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHaUMsS0FBSyxDQUFDaEMsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUNuQyxNQUFNbUMsSUFBSSxHQUFHRixLQUFLLENBQUNqQyxDQUFDLENBQUM7TUFDckIsTUFBTW9DLFVBQVUsR0FBR0MsUUFBUSxDQUFDRixJQUFJLENBQUMsR0FDM0JHLGdCQUFnQixDQUFDSCxJQUFJLENBQUMsR0FDdEJILGNBQWMsQ0FBQ0csSUFBSSxDQUFDO01BQzFCLElBQUlDLFVBQVUsRUFBRTtRQUNaLEtBQUssTUFBTUcsR0FBRyxJQUFJSCxVQUFVLEVBQUU7VUFDMUJqQixHQUFHLENBQUNvQixHQUFHLENBQUMsR0FBR0gsVUFBVSxDQUFDRyxHQUFHLENBQUM7UUFDOUI7TUFDSjtJQUNKO0lBQ0EsT0FBT3BCLEdBQUc7RUFDZCxDQUFDLE1BQ0ksSUFBSWtCLFFBQVEsQ0FBQ0osS0FBSyxDQUFDLEVBQUU7SUFDdEIsT0FBT0EsS0FBSztFQUNoQixDQUFDLE1BQ0ksSUFBSU8sUUFBUSxDQUFDUCxLQUFLLENBQUMsRUFBRTtJQUN0QixPQUFPQSxLQUFLO0VBQ2hCO0FBQ0o7QUFDQSxNQUFNUSxlQUFlLEdBQUcsZUFBZTtBQUN2QyxNQUFNQyxtQkFBbUIsR0FBRyxTQUFTO0FBQ3JDLE1BQU1DLGNBQWMsR0FBRyxlQUFlO0FBQ3RDLFNBQVNMLGdCQUFnQkEsQ0FBQ00sT0FBTyxFQUFFO0VBQy9CLE1BQU1DLEdBQUcsR0FBRyxDQUFDLENBQUM7RUFDZEQsT0FBTyxDQUNGRSxPQUFPLENBQUNILGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FDM0I1QyxLQUFLLENBQUMwQyxlQUFlLENBQUMsQ0FDdEJNLE9BQU8sQ0FBQ1osSUFBSSxJQUFJO0lBQ2pCLElBQUlBLElBQUksRUFBRTtNQUNOLE1BQU1hLEdBQUcsR0FBR2IsSUFBSSxDQUFDcEMsS0FBSyxDQUFDMkMsbUJBQW1CLENBQUM7TUFDM0NNLEdBQUcsQ0FBQy9DLE1BQU0sR0FBRyxDQUFDLEtBQUs0QyxHQUFHLENBQUNHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHRCxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUNDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDMUQ7RUFDSixDQUFDLENBQUM7RUFDRixPQUFPSixHQUFHO0FBQ2Q7QUFDQSxTQUFTSyxjQUFjQSxDQUFDQyxNQUFNLEVBQUU7RUFDNUIsSUFBSU4sR0FBRyxHQUFHLEVBQUU7RUFDWixJQUFJLENBQUNNLE1BQU0sSUFBSWQsUUFBUSxDQUFDYyxNQUFNLENBQUMsRUFBRTtJQUM3QixPQUFPTixHQUFHO0VBQ2Q7RUFDQSxLQUFLLE1BQU1OLEdBQUcsSUFBSVksTUFBTSxFQUFFO0lBQ3RCLE1BQU1sQixLQUFLLEdBQUdrQixNQUFNLENBQUNaLEdBQUcsQ0FBQztJQUN6QixNQUFNYSxhQUFhLEdBQUdiLEdBQUcsQ0FBQ2MsVUFBVSxDQUFFLElBQUcsQ0FBQyxHQUFHZCxHQUFHLEdBQUdlLFNBQVMsQ0FBQ2YsR0FBRyxDQUFDO0lBQ2pFLElBQUlGLFFBQVEsQ0FBQ0osS0FBSyxDQUFDLElBQUksT0FBT0EsS0FBSyxLQUFLLFFBQVEsRUFBRTtNQUM5QztNQUNBWSxHQUFHLElBQUssR0FBRU8sYUFBYyxJQUFHbkIsS0FBTSxHQUFFO0lBQ3ZDO0VBQ0o7RUFDQSxPQUFPWSxHQUFHO0FBQ2Q7QUFDQSxTQUFTVSxjQUFjQSxDQUFDdEIsS0FBSyxFQUFFO0VBQzNCLElBQUlkLEdBQUcsR0FBRyxFQUFFO0VBQ1osSUFBSWtCLFFBQVEsQ0FBQ0osS0FBSyxDQUFDLEVBQUU7SUFDakJkLEdBQUcsR0FBR2MsS0FBSztFQUNmLENBQUMsTUFDSSxJQUFJQyxPQUFPLENBQUNELEtBQUssQ0FBQyxFQUFFO0lBQ3JCLEtBQUssSUFBSWpDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR2lDLEtBQUssQ0FBQ2hDLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7TUFDbkMsTUFBTW9DLFVBQVUsR0FBR21CLGNBQWMsQ0FBQ3RCLEtBQUssQ0FBQ2pDLENBQUMsQ0FBQyxDQUFDO01BQzNDLElBQUlvQyxVQUFVLEVBQUU7UUFDWmpCLEdBQUcsSUFBSWlCLFVBQVUsR0FBRyxHQUFHO01BQzNCO0lBQ0o7RUFDSixDQUFDLE1BQ0ksSUFBSUksUUFBUSxDQUFDUCxLQUFLLENBQUMsRUFBRTtJQUN0QixLQUFLLE1BQU11QixJQUFJLElBQUl2QixLQUFLLEVBQUU7TUFDdEIsSUFBSUEsS0FBSyxDQUFDdUIsSUFBSSxDQUFDLEVBQUU7UUFDYnJDLEdBQUcsSUFBSXFDLElBQUksR0FBRyxHQUFHO01BQ3JCO0lBQ0o7RUFDSjtFQUNBLE9BQU9yQyxHQUFHLENBQUM4QixJQUFJLENBQUMsQ0FBQztBQUNyQjtBQUNBLFNBQVNRLGNBQWNBLENBQUNDLEtBQUssRUFBRTtFQUMzQixJQUFJLENBQUNBLEtBQUssRUFDTixPQUFPLElBQUk7RUFDZixJQUFJO0lBQUVDLEtBQUssRUFBRUMsS0FBSztJQUFFQztFQUFNLENBQUMsR0FBR0gsS0FBSztFQUNuQyxJQUFJRSxLQUFLLElBQUksQ0FBQ3ZCLFFBQVEsQ0FBQ3VCLEtBQUssQ0FBQyxFQUFFO0lBQzNCRixLQUFLLENBQUNDLEtBQUssR0FBR0osY0FBYyxDQUFDSyxLQUFLLENBQUM7RUFDdkM7RUFDQSxJQUFJQyxLQUFLLEVBQUU7SUFDUEgsS0FBSyxDQUFDRyxLQUFLLEdBQUc3QixjQUFjLENBQUM2QixLQUFLLENBQUM7RUFDdkM7RUFDQSxPQUFPSCxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxNQUFNSSxTQUFTLEdBQUcseUhBQXlFLEdBQ3ZGLHNFQUFzRSxHQUN0RSwwRUFBMEUsR0FDMUUsdUVBQXVFLEdBQ3ZFLHNFQUFzRSxHQUN0RSwyRUFBMkUsR0FDM0Usd0VBQXdFLEdBQ3hFLDZEQUE2RCxHQUM3RCwwQ0FBMEM7QUFDOUM7QUFDQSxNQUFNQyxRQUFRLEdBQUcsMkhBQTJFLEdBQ3hGLHNFQUFzRSxHQUN0RSxtRUFBbUUsR0FDbkUsc0VBQXNFLEdBQ3RFLG1FQUFtRSxHQUNuRSx5RUFBeUUsR0FDekUsd0VBQXdFLEdBQ3hFLGtFQUFrRSxHQUNsRSx5RUFBeUUsR0FDekUsNENBQTRDO0FBQ2hELE1BQU1DLFNBQVMsR0FBRyxzRUFBc0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxTQUFTLEdBQUcsYUFBY3pFLGdEQUFBQSxPQUFPLENBQUNzRSxTQUFTLENBQUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNSSxRQUFRLEdBQUcsYUFBYzFFLGdEQUFBQSxPQUFPLENBQUN1RSxRQUFRLENBQUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNSSxTQUFTLEdBQUcsYUFBYzNFLGdEQUFBQSxPQUFPLENBQUN3RSxTQUFTLENBQUM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNSSxtQkFBbUIsR0FBSSw2RUFBNEU7QUFDekcsTUFBTUMsb0JBQW9CLEdBQUcsYUFBYzdFLE9BQU8sQ0FBQzRFLG1CQUFtQixDQUFDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLGFBQWEsR0FBRyxhQUFjOUUsT0FBTyxDQUFDNEUsbUJBQW1CLEdBQzFELG1FQUFrRSxHQUNsRSw4Q0FBNkMsR0FDN0MsaUNBQWdDLENBQUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTRyxrQkFBa0JBLENBQUN0QyxLQUFLLEVBQUU7RUFDL0IsT0FBTyxDQUFDLENBQUNBLEtBQUssSUFBSUEsS0FBSyxLQUFLLEVBQUU7QUFDbEM7QUFDQSxNQUFNdUMsZ0JBQWdCLEdBQUcsaUNBQWlDO0FBQzFELE1BQU1DLG1CQUFtQixHQUFHLENBQUMsQ0FBQztBQUM5QixTQUFTQyxpQkFBaUJBLENBQUNsQixJQUFJLEVBQUU7RUFDN0IsSUFBSWlCLG1CQUFtQixDQUFDRSxjQUFjLENBQUNuQixJQUFJLENBQUMsRUFBRTtJQUMxQyxPQUFPaUIsbUJBQW1CLENBQUNqQixJQUFJLENBQUM7RUFDcEM7RUFDQSxNQUFNb0IsUUFBUSxHQUFHSixnQkFBZ0IsQ0FBQ0ssSUFBSSxDQUFDckIsSUFBSSxDQUFDO0VBQzVDLElBQUlvQixRQUFRLEVBQUU7SUFDVkUsT0FBTyxDQUFDQyxLQUFLLENBQUUsMEJBQXlCdkIsSUFBSyxFQUFDLENBQUM7RUFDbkQ7RUFDQSxPQUFRaUIsbUJBQW1CLENBQUNqQixJQUFJLENBQUMsR0FBRyxDQUFDb0IsUUFBUTtBQUNqRDtBQUNBLE1BQU1JLGNBQWMsR0FBRztFQUNuQkMsYUFBYSxFQUFFLGdCQUFnQjtFQUMvQkMsU0FBUyxFQUFFLE9BQU87RUFDbEJDLE9BQU8sRUFBRSxLQUFLO0VBQ2RDLFNBQVMsRUFBRTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxlQUFlLEdBQUcsYUFBYzdGLGdEQUFBQSxPQUFPLENBQUUsK0RBQThELEdBQ3hHLG9FQUFtRSxHQUNuRSxvRUFBbUUsR0FDbkUsMkVBQTBFLEdBQzFFLDBFQUF5RSxHQUN6RSxxRUFBb0UsR0FDcEUsc0VBQXFFLEdBQ3JFLDJFQUEwRSxHQUMxRSx3RUFBdUUsR0FDdkUsNEVBQTJFLEdBQzNFLDJFQUEwRSxHQUMxRSx5RUFBd0UsR0FDeEUsMkVBQTBFLEdBQzFFLHVFQUFzRSxHQUN0RSxrQkFBaUIsQ0FBQztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNOEYsY0FBYyxHQUFHLGFBQWM5RixnREFBQUEsT0FBTyxDQUFFLGtGQUFpRixHQUMxSCx1RUFBc0UsR0FDdEUsMEVBQXlFLEdBQ3pFLG1FQUFrRSxHQUNsRSw0REFBMkQsR0FDM0QsMkVBQTBFLEdBQzFFLDZFQUE0RSxHQUM1RSx5RUFBd0UsR0FDeEUsbUVBQWtFLEdBQ2xFLGlFQUFnRSxHQUNoRSxpRUFBZ0UsR0FDaEUsbUVBQWtFLEdBQ2xFLDJFQUEwRSxHQUMxRSw0RUFBMkUsR0FDM0UseUVBQXdFLEdBQ3hFLDBFQUF5RSxHQUN6RSwwRUFBeUUsR0FDekUseUVBQXdFLEdBQ3hFLDBFQUF5RSxHQUN6RSwwRUFBeUUsR0FDekUsb0VBQW1FLEdBQ25FLG9FQUFtRSxHQUNuRSwyRUFBMEUsR0FDMUUsNkVBQTRFLEdBQzVFLHVFQUFzRSxHQUN0RSxtRUFBa0UsR0FDbEUsK0RBQThELEdBQzlELCtEQUE4RCxHQUM5RCxvRUFBbUUsR0FDbkUsbUVBQWtFLEdBQ2xFLHlFQUF3RSxHQUN4RSwwRUFBeUUsR0FDekUseUVBQXdFLEdBQ3hFLGtFQUFpRSxHQUNqRSx1RUFBc0UsR0FDdEUsd0VBQXVFLEdBQ3ZFLDZFQUE0RSxHQUM1RSw0RUFBMkUsR0FDM0UsaURBQWdELENBQUM7QUFFdEQsTUFBTStGLFFBQVEsR0FBRyxTQUFTO0FBQzFCLFNBQVNDLFVBQVVBLENBQUNDLE1BQU0sRUFBRTtFQUN4QixNQUFNaEcsR0FBRyxHQUFHLEVBQUUsR0FBR2dHLE1BQU07RUFDdkIsTUFBTUMsS0FBSyxHQUFHSCxRQUFRLENBQUNJLElBQUksQ0FBQ2xHLEdBQUcsQ0FBQztFQUNoQyxJQUFJLENBQUNpRyxLQUFLLEVBQUU7SUFDUixPQUFPakcsR0FBRztFQUNkO0VBQ0EsSUFBSW1HLElBQUksR0FBRyxFQUFFO0VBQ2IsSUFBSUMsT0FBTztFQUNYLElBQUlDLEtBQUs7RUFDVCxJQUFJQyxTQUFTLEdBQUcsQ0FBQztFQUNqQixLQUFLRCxLQUFLLEdBQUdKLEtBQUssQ0FBQ0ksS0FBSyxFQUFFQSxLQUFLLEdBQUdyRyxHQUFHLENBQUNRLE1BQU0sRUFBRTZGLEtBQUssRUFBRSxFQUFFO0lBQ25ELFFBQVFyRyxHQUFHLENBQUN1RyxVQUFVLENBQUNGLEtBQUssQ0FBQztNQUN6QixLQUFLLEVBQUU7UUFBRTtRQUNMRCxPQUFPLEdBQUcsUUFBUTtRQUNsQjtNQUNKLEtBQUssRUFBRTtRQUFFO1FBQ0xBLE9BQU8sR0FBRyxPQUFPO1FBQ2pCO01BQ0osS0FBSyxFQUFFO1FBQUU7UUFDTEEsT0FBTyxHQUFHLE9BQU87UUFDakI7TUFDSixLQUFLLEVBQUU7UUFBRTtRQUNMQSxPQUFPLEdBQUcsTUFBTTtRQUNoQjtNQUNKLEtBQUssRUFBRTtRQUFFO1FBQ0xBLE9BQU8sR0FBRyxNQUFNO1FBQ2hCO01BQ0o7UUFDSTtJQUNSO0lBQ0EsSUFBSUUsU0FBUyxLQUFLRCxLQUFLLEVBQUU7TUFDckJGLElBQUksSUFBSW5HLEdBQUcsQ0FBQ3dHLEtBQUssQ0FBQ0YsU0FBUyxFQUFFRCxLQUFLLENBQUM7SUFDdkM7SUFDQUMsU0FBUyxHQUFHRCxLQUFLLEdBQUcsQ0FBQztJQUNyQkYsSUFBSSxJQUFJQyxPQUFPO0VBQ25CO0VBQ0EsT0FBT0UsU0FBUyxLQUFLRCxLQUFLLEdBQUdGLElBQUksR0FBR25HLEdBQUcsQ0FBQ3dHLEtBQUssQ0FBQ0YsU0FBUyxFQUFFRCxLQUFLLENBQUMsR0FBR0YsSUFBSTtBQUMxRTtBQUNBO0FBQ0EsTUFBTU0sY0FBYyxHQUFHLDBCQUEwQjtBQUNqRCxTQUFTQyxpQkFBaUJBLENBQUNDLEdBQUcsRUFBRTtFQUM1QixPQUFPQSxHQUFHLENBQUN0RCxPQUFPLENBQUNvRCxjQUFjLEVBQUUsRUFBRSxDQUFDO0FBQzFDO0FBRUEsU0FBU0csa0JBQWtCQSxDQUFDQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtFQUM5QixJQUFJRCxDQUFDLENBQUNyRyxNQUFNLEtBQUtzRyxDQUFDLENBQUN0RyxNQUFNLEVBQ3JCLE9BQU8sS0FBSztFQUNoQixJQUFJdUcsS0FBSyxHQUFHLElBQUk7RUFDaEIsS0FBSyxJQUFJeEcsQ0FBQyxHQUFHLENBQUMsRUFBRXdHLEtBQUssSUFBSXhHLENBQUMsR0FBR3NHLENBQUMsQ0FBQ3JHLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7SUFDeEN3RyxLQUFLLEdBQUdDLFVBQVUsQ0FBQ0gsQ0FBQyxDQUFDdEcsQ0FBQyxDQUFDLEVBQUV1RyxDQUFDLENBQUN2RyxDQUFDLENBQUMsQ0FBQztFQUNsQztFQUNBLE9BQU93RyxLQUFLO0FBQ2hCO0FBQ0EsU0FBU0MsVUFBVUEsQ0FBQ0gsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7RUFDdEIsSUFBSUQsQ0FBQyxLQUFLQyxDQUFDLEVBQ1AsT0FBTyxJQUFJO0VBQ2YsSUFBSUcsVUFBVSxHQUFHQyxNQUFNLENBQUNMLENBQUMsQ0FBQztFQUMxQixJQUFJTSxVQUFVLEdBQUdELE1BQU0sQ0FBQ0osQ0FBQyxDQUFDO0VBQzFCLElBQUlHLFVBQVUsSUFBSUUsVUFBVSxFQUFFO0lBQzFCLE9BQU9GLFVBQVUsSUFBSUUsVUFBVSxHQUFHTixDQUFDLENBQUNPLE9BQU8sQ0FBQyxDQUFDLEtBQUtOLENBQUMsQ0FBQ00sT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLO0VBQ3pFO0VBQ0FILFVBQVUsR0FBR0ksUUFBUSxDQUFDUixDQUFDLENBQUM7RUFDeEJNLFVBQVUsR0FBR0UsUUFBUSxDQUFDUCxDQUFDLENBQUM7RUFDeEIsSUFBSUcsVUFBVSxJQUFJRSxVQUFVLEVBQUU7SUFDMUIsT0FBT04sQ0FBQyxLQUFLQyxDQUFDO0VBQ2xCO0VBQ0FHLFVBQVUsR0FBR3hFLE9BQU8sQ0FBQ29FLENBQUMsQ0FBQztFQUN2Qk0sVUFBVSxHQUFHMUUsT0FBTyxDQUFDcUUsQ0FBQyxDQUFDO0VBQ3ZCLElBQUlHLFVBQVUsSUFBSUUsVUFBVSxFQUFFO0lBQzFCLE9BQU9GLFVBQVUsSUFBSUUsVUFBVSxHQUFHUCxrQkFBa0IsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLENBQUMsR0FBRyxLQUFLO0VBQ3RFO0VBQ0FHLFVBQVUsR0FBR2xFLFFBQVEsQ0FBQzhELENBQUMsQ0FBQztFQUN4Qk0sVUFBVSxHQUFHcEUsUUFBUSxDQUFDK0QsQ0FBQyxDQUFDO0VBQ3hCLElBQUlHLFVBQVUsSUFBSUUsVUFBVSxFQUFFO0lBQzFCO0lBQ0EsSUFBSSxDQUFDRixVQUFVLElBQUksQ0FBQ0UsVUFBVSxFQUFFO01BQzVCLE9BQU8sS0FBSztJQUNoQjtJQUNBLE1BQU1HLFVBQVUsR0FBR25ILE1BQU0sQ0FBQ29ILElBQUksQ0FBQ1YsQ0FBQyxDQUFDLENBQUNyRyxNQUFNO0lBQ3hDLE1BQU1nSCxVQUFVLEdBQUdySCxNQUFNLENBQUNvSCxJQUFJLENBQUNULENBQUMsQ0FBQyxDQUFDdEcsTUFBTTtJQUN4QyxJQUFJOEcsVUFBVSxLQUFLRSxVQUFVLEVBQUU7TUFDM0IsT0FBTyxLQUFLO0lBQ2hCO0lBQ0EsS0FBSyxNQUFNMUUsR0FBRyxJQUFJK0QsQ0FBQyxFQUFFO01BQ2pCLE1BQU1ZLE9BQU8sR0FBR1osQ0FBQyxDQUFDM0IsY0FBYyxDQUFDcEMsR0FBRyxDQUFDO01BQ3JDLE1BQU00RSxPQUFPLEdBQUdaLENBQUMsQ0FBQzVCLGNBQWMsQ0FBQ3BDLEdBQUcsQ0FBQztNQUNyQyxJQUFLMkUsT0FBTyxJQUFJLENBQUNDLE9BQU8sSUFDbkIsQ0FBQ0QsT0FBTyxJQUFJQyxPQUFRLElBQ3JCLENBQUNWLFVBQVUsQ0FBQ0gsQ0FBQyxDQUFDL0QsR0FBRyxDQUFDLEVBQUVnRSxDQUFDLENBQUNoRSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQzdCLE9BQU8sS0FBSztNQUNoQjtJQUNKO0VBQ0o7RUFDQSxPQUFPYixNQUFNLENBQUM0RSxDQUFDLENBQUMsS0FBSzVFLE1BQU0sQ0FBQzZFLENBQUMsQ0FBQztBQUNsQztBQUNBLFNBQVNhLFlBQVlBLENBQUNDLEdBQUcsRUFBRW5ILEdBQUcsRUFBRTtFQUM1QixPQUFPbUgsR0FBRyxDQUFDQyxTQUFTLENBQUNuRixJQUFJLElBQUlzRSxVQUFVLENBQUN0RSxJQUFJLEVBQUVqQyxHQUFHLENBQUMsQ0FBQztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1xSCxlQUFlLEdBQUlySCxHQUFHLElBQUs7RUFDN0IsT0FBT21DLFFBQVEsQ0FBQ25DLEdBQUcsQ0FBQyxHQUNkQSxHQUFHLEdBQ0hBLEdBQUcsSUFBSSxJQUFJLEdBQ1AsRUFBRSxHQUNGZ0MsT0FBTyxDQUFDaEMsR0FBRyxDQUFDLElBQ1RzQyxRQUFRLENBQUN0QyxHQUFHLENBQUMsS0FDVEEsR0FBRyxDQUFDc0gsUUFBUSxLQUFLQyxjQUFjLElBQUksQ0FBQ0MsVUFBVSxDQUFDeEgsR0FBRyxDQUFDc0gsUUFBUSxDQUFDLENBQUUsR0FDakVHLElBQUksQ0FBQ0MsU0FBUyxDQUFDMUgsR0FBRyxFQUFFMkgsUUFBUSxFQUFFLENBQUMsQ0FBQyxHQUNoQ25HLE1BQU0sQ0FBQ3hCLEdBQUcsQ0FBQztBQUM3QixDQUFDO0FBQ0QsTUFBTTJILFFBQVEsR0FBR0EsQ0FBQ0MsSUFBSSxFQUFFNUgsR0FBRyxLQUFLO0VBQzVCO0VBQ0EsSUFBSUEsR0FBRyxJQUFJQSxHQUFHLENBQUM2SCxTQUFTLEVBQUU7SUFDdEIsT0FBT0YsUUFBUSxDQUFDQyxJQUFJLEVBQUU1SCxHQUFHLENBQUMrQixLQUFLLENBQUM7RUFDcEMsQ0FBQyxNQUNJLElBQUkrRixLQUFLLENBQUM5SCxHQUFHLENBQUMsRUFBRTtJQUNqQixPQUFPO01BQ0gsQ0FBRSxPQUFNQSxHQUFHLENBQUMrSCxJQUFLLEdBQUUsR0FBRyxDQUFDLEdBQUcvSCxHQUFHLENBQUNnSSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNDLE1BQU0sQ0FBQyxDQUFDRCxPQUFPLEVBQUUsQ0FBQzNGLEdBQUcsRUFBRXJDLEdBQUcsQ0FBQyxLQUFLO1FBQ3JFZ0ksT0FBTyxDQUFFLEdBQUUzRixHQUFJLEtBQUksQ0FBQyxHQUFHckMsR0FBRztRQUMxQixPQUFPZ0ksT0FBTztNQUNsQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztFQUNMLENBQUMsTUFDSSxJQUFJRSxLQUFLLENBQUNsSSxHQUFHLENBQUMsRUFBRTtJQUNqQixPQUFPO01BQ0gsQ0FBRSxPQUFNQSxHQUFHLENBQUMrSCxJQUFLLEdBQUUsR0FBRyxDQUFDLEdBQUcvSCxHQUFHLENBQUNtSSxNQUFNLENBQUMsQ0FBQztJQUMxQyxDQUFDO0VBQ0wsQ0FBQyxNQUNJLElBQUk3RixRQUFRLENBQUN0QyxHQUFHLENBQUMsSUFBSSxDQUFDZ0MsT0FBTyxDQUFDaEMsR0FBRyxDQUFDLElBQUksQ0FBQ29JLGFBQWEsQ0FBQ3BJLEdBQUcsQ0FBQyxFQUFFO0lBQzVELE9BQU93QixNQUFNLENBQUN4QixHQUFHLENBQUM7RUFDdEI7RUFDQSxPQUFPQSxHQUFHO0FBQ2QsQ0FBQztBQUVELE1BQU1xSSxTQUFTLEdBQUlDLE1BQXFDLEdBQ2xENUksQ0FBaUIsR0FDakIsQ0FBQyxDQUFDO0FBQ1IsTUFBTWdKLFNBQVMsR0FBSUosTUFBcUMsR0FBSTVJLENBQWlCLEdBQUcsRUFBRTtBQUNsRixNQUFNaUosSUFBSSxHQUFHQSxDQUFBLEtBQU0sQ0FBRSxDQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLEVBQUUsR0FBR0EsQ0FBQSxLQUFNLEtBQUs7QUFDdEIsTUFBTUMsSUFBSSxHQUFHLFdBQVc7QUFDeEIsTUFBTUMsSUFBSSxHQUFJekcsR0FBRyxJQUFLd0csSUFBSSxDQUFDbEUsSUFBSSxDQUFDdEMsR0FBRyxDQUFDO0FBQ3BDLE1BQU0wRyxlQUFlLEdBQUkxRyxHQUFHLElBQUtBLEdBQUcsQ0FBQ2MsVUFBVSxDQUFDLFdBQVcsQ0FBQztBQUM1RCxNQUFNNkYsTUFBTSxHQUFHdEosTUFBTSxDQUFDdUosTUFBTTtBQUM1QixNQUFNQyxNQUFNLEdBQUdBLENBQUMvQixHQUFHLEVBQUVnQyxFQUFFLEtBQUs7RUFDeEIsTUFBTXJKLENBQUMsR0FBR3FILEdBQUcsQ0FBQ2lDLE9BQU8sQ0FBQ0QsRUFBRSxDQUFDO0VBQ3pCLElBQUlySixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDUnFILEdBQUcsQ0FBQ2tDLE1BQU0sQ0FBQ3ZKLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDcEI7QUFDSixDQUFDO0FBQ0QsTUFBTTJFLGNBQWMsR0FBRy9FLE1BQU0sQ0FBQzRKLFNBQVMsQ0FBQzdFLGNBQWM7QUFDdEQsTUFBTThFLE1BQU0sR0FBR0EsQ0FBQ3ZKLEdBQUcsRUFBRXFDLEdBQUcsS0FBS29DLGNBQWMsQ0FBQytFLElBQUksQ0FBQ3hKLEdBQUcsRUFBRXFDLEdBQUcsQ0FBQztBQUMxRCxNQUFNTCxPQUFPLEdBQUd5SCxLQUFLLENBQUN6SCxPQUFPO0FBQzdCLE1BQU04RixLQUFLLEdBQUk5SCxHQUFHLElBQUswSixZQUFZLENBQUMxSixHQUFHLENBQUMsS0FBSyxjQUFjO0FBQzNELE1BQU1rSSxLQUFLLEdBQUlsSSxHQUFHLElBQUswSixZQUFZLENBQUMxSixHQUFHLENBQUMsS0FBSyxjQUFjO0FBQzNELE1BQU15RyxNQUFNLEdBQUl6RyxHQUFHLElBQUswSixZQUFZLENBQUMxSixHQUFHLENBQUMsS0FBSyxlQUFlO0FBQzdELE1BQU0ySixRQUFRLEdBQUkzSixHQUFHLElBQUswSixZQUFZLENBQUMxSixHQUFHLENBQUMsS0FBSyxpQkFBaUI7QUFDakUsTUFBTXdILFVBQVUsR0FBSXhILEdBQUcsSUFBSyxPQUFPQSxHQUFHLEtBQUssVUFBVTtBQUNyRCxNQUFNbUMsUUFBUSxHQUFJbkMsR0FBRyxJQUFLLE9BQU9BLEdBQUcsS0FBSyxRQUFRO0FBQ2pELE1BQU00RyxRQUFRLEdBQUk1RyxHQUFHLElBQUssT0FBT0EsR0FBRyxLQUFLLFFBQVE7QUFDakQsTUFBTXNDLFFBQVEsR0FBSXRDLEdBQUcsSUFBS0EsR0FBRyxLQUFLLElBQUksSUFBSSxPQUFPQSxHQUFHLEtBQUssUUFBUTtBQUNqRSxNQUFNNEosU0FBUyxHQUFJNUosR0FBRyxJQUFLO0VBQ3ZCLE9BQU9zQyxRQUFRLENBQUN0QyxHQUFHLENBQUMsSUFBSXdILFVBQVUsQ0FBQ3hILEdBQUcsQ0FBQzZKLElBQUksQ0FBQyxJQUFJckMsVUFBVSxDQUFDeEgsR0FBRyxDQUFDOEosS0FBSyxDQUFDO0FBQ3pFLENBQUM7QUFDRCxNQUFNdkMsY0FBYyxHQUFHN0gsTUFBTSxDQUFDNEosU0FBUyxDQUFDaEMsUUFBUTtBQUNoRCxNQUFNb0MsWUFBWSxHQUFJM0gsS0FBSyxJQUFLd0YsY0FBYyxDQUFDaUMsSUFBSSxDQUFDekgsS0FBSyxDQUFDO0FBQzFELE1BQU1nSSxTQUFTLEdBQUloSSxLQUFLLElBQUs7RUFDekI7RUFDQSxPQUFPMkgsWUFBWSxDQUFDM0gsS0FBSyxDQUFDLENBQUNnRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFDRCxNQUFNcUMsYUFBYSxHQUFJcEksR0FBRyxJQUFLMEosWUFBWSxDQUFDMUosR0FBRyxDQUFDLEtBQUssaUJBQWlCO0FBQ3RFLE1BQU1nSyxZQUFZLEdBQUkzSCxHQUFHLElBQUtGLFFBQVEsQ0FBQ0UsR0FBRyxDQUFDLElBQ3ZDQSxHQUFHLEtBQUssS0FBSyxJQUNiQSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUNkLEVBQUUsR0FBRzRILFFBQVEsQ0FBQzVILEdBQUcsRUFBRSxFQUFFLENBQUMsS0FBS0EsR0FBRztBQUNsQyxNQUFNNkgsY0FBYyxHQUFHLGFBQWM1SyxPQUFPO0FBQzVDO0FBQ0EsMkJBQTJCLEdBQ3ZCLG9DQUFvQyxHQUNwQyxxQ0FBcUMsR0FDckMsdUNBQXVDLENBQUM7QUFDNUMsTUFBTTZLLGtCQUFrQixHQUFHLGFBQWM3SyxnREFBQUEsT0FBTyxDQUFDLDJFQUEyRSxDQUFDO0FBQzdILE1BQU04SyxtQkFBbUIsR0FBSUMsRUFBRSxJQUFLO0VBQ2hDLE1BQU1DLEtBQUssR0FBRzVLLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQztFQUNqQyxPQUFTSixHQUFHLElBQUs7SUFDYixNQUFNZ0wsR0FBRyxHQUFHRCxLQUFLLENBQUMvSyxHQUFHLENBQUM7SUFDdEIsT0FBT2dMLEdBQUcsS0FBS0QsS0FBSyxDQUFDL0ssR0FBRyxDQUFDLEdBQUc4SyxFQUFFLENBQUM5SyxHQUFHLENBQUMsQ0FBQztFQUN4QyxDQUFDO0FBQ0wsQ0FBQztBQUNELE1BQU1pTCxVQUFVLEdBQUcsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxRQUFRLEdBQUdMLG1CQUFtQixDQUFFN0ssR0FBRyxJQUFLO0VBQzFDLE9BQU9BLEdBQUcsQ0FBQ3FELE9BQU8sQ0FBQzRILFVBQVUsRUFBRSxDQUFDMUosQ0FBQyxFQUFFNEosQ0FBQyxLQUFNQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLENBQUMsR0FBRyxFQUFHLENBQUM7QUFDeEUsQ0FBQyxDQUFDO0FBQ0YsTUFBTUMsV0FBVyxHQUFHLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTXhILFNBQVMsR0FBR2dILG1CQUFtQixDQUFFN0ssR0FBRyxJQUFLQSxHQUFHLENBQUNxRCxPQUFPLENBQUNnSSxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUMzSyxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLE1BQU00SyxVQUFVLEdBQUdULG1CQUFtQixDQUFFN0ssR0FBRyxJQUFLQSxHQUFHLENBQUN1TCxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUNILFdBQVcsQ0FBQyxDQUFDLEdBQUdwTCxHQUFHLENBQUN3RyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTWdGLFlBQVksR0FBR1gsbUJBQW1CLENBQUU3SyxHQUFHLElBQUtBLEdBQUcsR0FBSSxLQUFJc0wsVUFBVSxDQUFDdEwsR0FBRyxDQUFFLEVBQUMsR0FBSSxFQUFDLENBQUM7QUFDcEY7QUFDQSxNQUFNeUwsVUFBVSxHQUFHQSxDQUFDakosS0FBSyxFQUFFa0osUUFBUSxLQUFLLENBQUN2TCxNQUFNLENBQUN3TCxFQUFFLENBQUNuSixLQUFLLEVBQUVrSixRQUFRLENBQUM7QUFDbkUsTUFBTUUsY0FBYyxHQUFHQSxDQUFDQyxHQUFHLEVBQUVDLEdBQUcsS0FBSztFQUNqQyxLQUFLLElBQUl2TCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdzTCxHQUFHLENBQUNyTCxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQ2pDc0wsR0FBRyxDQUFDdEwsQ0FBQyxDQUFDLENBQUN1TCxHQUFHLENBQUM7RUFDZjtBQUNKLENBQUM7QUFDRCxNQUFNQyxHQUFHLEdBQUdBLENBQUNDLEdBQUcsRUFBRWxKLEdBQUcsRUFBRU4sS0FBSyxLQUFLO0VBQzdCckMsTUFBTSxDQUFDOEwsY0FBYyxDQUFDRCxHQUFHLEVBQUVsSixHQUFHLEVBQUU7SUFDNUJvSixZQUFZLEVBQUUsSUFBSTtJQUNsQkMsVUFBVSxFQUFFLEtBQUs7SUFDakIzSjtFQUNKLENBQUMsQ0FBQztBQUNOLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU00SixhQUFhLEdBQUkzTCxHQUFHLElBQUs7RUFDM0IsTUFBTTRMLENBQUMsR0FBR0MsVUFBVSxDQUFDN0wsR0FBRyxDQUFDO0VBQ3pCLE9BQU84TCxLQUFLLENBQUNGLENBQUMsQ0FBQyxHQUFHNUwsR0FBRyxHQUFHNEwsQ0FBQztBQUM3QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRyxRQUFRLEdBQUkvTCxHQUFHLElBQUs7RUFDdEIsTUFBTTRMLENBQUMsR0FBR3pKLFFBQVEsQ0FBQ25DLEdBQUcsQ0FBQyxHQUFHZ00sTUFBTSxDQUFDaE0sR0FBRyxDQUFDLEdBQUdpTSxHQUFHO0VBQzNDLE9BQU9ILEtBQUssQ0FBQ0YsQ0FBQyxDQUFDLEdBQUc1TCxHQUFHLEdBQUc0TCxDQUFDO0FBQzdCLENBQUM7QUFDRCxJQUFJTSxXQUFXO0FBQ2YsTUFBTUMsYUFBYSxHQUFHQSxDQUFBLEtBQU07RUFDeEIsT0FBUUQsV0FBVyxLQUNkQSxXQUFXLEdBQ1IsT0FBT0UsVUFBVSxLQUFLLFdBQVcsR0FDM0JBLFVBQVUsR0FDVixPQUFPQyxJQUFJLEtBQUssV0FBVyxHQUN2QkEsSUFBSSxHQUNKLE9BQU9DLE1BQU0sS0FBSyxXQUFXLEdBQ3pCQSxNQUFNLEdBQ04sT0FBT0MscUJBQU0sS0FBSyxXQUFXLEdBQ3pCQSxxQkFBTSxHQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLENBQUM7QUFDRCxNQUFNQyxPQUFPLEdBQUcsa0RBQWtEO0FBQ2xFLFNBQVNDLGlCQUFpQkEsQ0FBQ25KLElBQUksRUFBRTtFQUM3QixPQUFPa0osT0FBTyxDQUFDN0gsSUFBSSxDQUFDckIsSUFBSSxDQUFDLEdBQ2xCLFdBQVVBLElBQUssRUFBQyxHQUNoQixXQUFVbUUsSUFBSSxDQUFDQyxTQUFTLENBQUNwRSxJQUFJLENBQUUsR0FBRTtBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcz82OWE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xufVxuXG4vKipcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXG4gKi9cbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICAgIFsxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqL106IGBURVhUYCxcbiAgICBbMiAvKiBQYXRjaEZsYWdzLkNMQVNTICovXTogYENMQVNTYCxcbiAgICBbNCAvKiBQYXRjaEZsYWdzLlNUWUxFICovXTogYFNUWUxFYCxcbiAgICBbOCAvKiBQYXRjaEZsYWdzLlBST1BTICovXTogYFBST1BTYCxcbiAgICBbMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxuICAgIFszMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcbiAgICBbNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgICBbMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxuICAgIFsyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxuICAgIFs1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxuICAgIFsxMDI0IC8qIFBhdGNoRmxhZ3MuRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcbiAgICBbMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgICBbLTEgLyogUGF0Y2hGbGFncy5IT0lTVEVEICovXTogYEhPSVNURURgLFxuICAgIFstMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi9dOiBgQkFJTGBcbn07XG5cbi8qKlxuICogRGV2IG9ubHlcbiAqL1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgICBbMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovXTogJ1NUQUJMRScsXG4gICAgWzIgLyogU2xvdEZsYWdzLkRZTkFNSUMgKi9dOiAnRFlOQU1JQycsXG4gICAgWzMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxuICAgIC8vIHRoYXQgc2VwYXJhdGVkIGVhY2ggbGluZS4gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgYWN0dWFsIHNlcXVlbmNlIGlzXG4gICAgLy8gbmVlZGVkIHRvIHByb3Blcmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBmdWxsIGxpbmUgbGVuZ3RoIGZvciBvZmZzZXRcbiAgICAvLyBjb21wYXJpc29uXG4gICAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbGluZXMgYW5kIG5ld2xpbmUgc2VxdWVuY2VzIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYXNpZXIgcmVmZXJlbmNpbmdcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3VudCArPVxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAoKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGgpIHx8IDApO1xuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKi4qP1xcKlxcLy9ncztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNzc1RleHRcbiAgICAgICAgLnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsICcnKVxuICAgICAgICAuc3BsaXQobGlzdERlbGltaXRlclJFKVxuICAgICAgICAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xuICAgICAgICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmVzID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBuYW1lICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcbmNvbnN0IEhUTUxfVEFHUyA9ICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLCcgK1xuICAgICdoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jztcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXG4gICAgJ2ZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXG4gICAgJ2ZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsJyArXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcbiAgICAnbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xuY29uc3QgVk9JRF9UQUdTID0gJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJztcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzU1ZHVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFNWR19UQUdTKTtcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNWb2lkVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbi8qKlxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXG4gKiAtIGlzbWFwIC0+IGlzTWFwXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxuICogLSByZWFkb25seSAtPiByZWFkT25seVxuICovXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbi8qKlxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxuICovXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XG4vKipcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cbiAqIGUuZy4gYDxzZWxlY3QgbXVsdGlwbGU+YCBjb21waWxlcyB0byBgeyBtdWx0aXBsZTogJycgfWBcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09ICcnO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICAgIH1cbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgICBpZiAoaXNVbnNhZmUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xufTtcbi8qKlxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcbiAqL1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXG4gICAgYGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGAgK1xuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xuICAgIGBjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxgICtcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xuICAgIGBoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksYCArXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcbiAgICBgb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LGAgK1xuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXG4gICAgYHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLGAgK1xuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XG4vKipcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGVcbiAqL1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYCArXG4gICAgYGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGAgK1xuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcbiAgICBgY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixgICtcbiAgICBgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGAgK1xuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXG4gICAgYGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGAgK1xuICAgIGBkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGAgK1xuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xuICAgIGBmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxgICtcbiAgICBgZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsYCArXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXG4gICAgYGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxgICtcbiAgICBgaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxgICtcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcbiAgICBgbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsYCArXG4gICAgYG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLGAgK1xuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xuICAgIGBuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixgICtcbiAgICBgb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgsYCArXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xuICAgIGBwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxgICtcbiAgICBgcHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLGAgK1xuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcbiAgICBgcmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsYCArXG4gICAgYHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsYCArXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcbiAgICBgc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLGAgK1xuICAgIGBzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixgICtcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcbiAgICBgc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcixgICtcbiAgICBgdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sYCArXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXG4gICAgYHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyxgICtcbiAgICBgdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsYCArXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcbiAgICBgd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUsYCArXG4gICAgYHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcsYCArXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XG4gICAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBlc2NhcGVkO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XG4gICAgfVxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuLyoqXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHZhbCA9PSBudWxsXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IGlzQXJyYXkodmFsKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwpICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxuICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMilcbiAgICAgICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICAgIC8vIGNhbid0IHVzZSBpc1JlZiBoZXJlIHNpbmNlIEB2dWUvc2hhcmVkIGhhcyBubyBkZXBzXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXG4gICAgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXG4gICAga2V5ICE9PSAnTmFOJyAmJlxuICAgIGtleVswXSAhPT0gJy0nICYmXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4nLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LCcgK1xuICAgICdvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsJyArXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtbycpO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKChzdHIpID0+IHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH0pO1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XG59KTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldKGFyZyk7XG4gICAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICB9KTtcbn07XG4vKipcbiAqIFwiMTIzLWZvb1wiIHdpbGwgYmUgcGFyc2VkIHRvIDEyM1xuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgLm51bWJlciBtb2RpZmllciBpbiB2LW1vZGVsXG4gKi9cbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbi8qKlxuICogT25seSBjb25lcmNlcyBudW1iZXItbGlrZSBzdHJpbmdzXG4gKiBcIjEyMy1mb29cIiB3aWxsIGJlIHJldHVybmVkIGFzLWlzXG4gKi9cbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gICAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKVxuICAgICAgICA/IGBfX3Byb3BzLiR7bmFtZX1gXG4gICAgICAgIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIl0sIm5hbWVzIjpbIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiT2JqZWN0IiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInZhbCIsInRvTG93ZXJDYXNlIiwiUGF0Y2hGbGFnTmFtZXMiLCJzbG90RmxhZ3NUZXh0IiwiR0xPQkFMU19XSElURV9MSVNURUQiLCJpc0dsb2JhbGx5V2hpdGVsaXN0ZWQiLCJyYW5nZSIsImdlbmVyYXRlQ29kZUZyYW1lIiwic291cmNlIiwic3RhcnQiLCJlbmQiLCJsaW5lcyIsIm5ld2xpbmVTZXF1ZW5jZXMiLCJmaWx0ZXIiLCJfIiwiaWR4IiwiY291bnQiLCJyZXMiLCJqIiwibGluZSIsInB1c2giLCJyZXBlYXQiLCJNYXRoIiwibWF4IiwiU3RyaW5nIiwibGluZUxlbmd0aCIsIm5ld0xpbmVTZXFMZW5ndGgiLCJwYWQiLCJtaW4iLCJqb2luIiwibm9ybWFsaXplU3R5bGUiLCJ2YWx1ZSIsImlzQXJyYXkiLCJpdGVtIiwibm9ybWFsaXplZCIsImlzU3RyaW5nIiwicGFyc2VTdHJpbmdTdHlsZSIsImtleSIsImlzT2JqZWN0IiwibGlzdERlbGltaXRlclJFIiwicHJvcGVydHlEZWxpbWl0ZXJSRSIsInN0eWxlQ29tbWVudFJFIiwiY3NzVGV4dCIsInJldCIsInJlcGxhY2UiLCJmb3JFYWNoIiwidG1wIiwidHJpbSIsInN0cmluZ2lmeVN0eWxlIiwic3R5bGVzIiwibm9ybWFsaXplZEtleSIsInN0YXJ0c1dpdGgiLCJoeXBoZW5hdGUiLCJub3JtYWxpemVDbGFzcyIsIm5hbWUiLCJub3JtYWxpemVQcm9wcyIsInByb3BzIiwiY2xhc3MiLCJrbGFzcyIsInN0eWxlIiwiSFRNTF9UQUdTIiwiU1ZHX1RBR1MiLCJWT0lEX1RBR1MiLCJpc0hUTUxUYWciLCJpc1NWR1RhZyIsImlzVm9pZFRhZyIsInNwZWNpYWxCb29sZWFuQXR0cnMiLCJpc1NwZWNpYWxCb29sZWFuQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJpbmNsdWRlQm9vbGVhbkF0dHIiLCJ1bnNhZmVBdHRyQ2hhclJFIiwiYXR0clZhbGlkYXRpb25DYWNoZSIsImlzU1NSU2FmZUF0dHJOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJpc1Vuc2FmZSIsInRlc3QiLCJjb25zb2xlIiwiZXJyb3IiLCJwcm9wc1RvQXR0ck1hcCIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwiaXNLbm93bkh0bWxBdHRyIiwiaXNLbm93blN2Z0F0dHIiLCJlc2NhcGVSRSIsImVzY2FwZUh0bWwiLCJzdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJodG1sIiwiZXNjYXBlZCIsImluZGV4IiwibGFzdEluZGV4IiwiY2hhckNvZGVBdCIsInNsaWNlIiwiY29tbWVudFN0cmlwUkUiLCJlc2NhcGVIdG1sQ29tbWVudCIsInNyYyIsImxvb3NlQ29tcGFyZUFycmF5cyIsImEiLCJiIiwiZXF1YWwiLCJsb29zZUVxdWFsIiwiYVZhbGlkVHlwZSIsImlzRGF0ZSIsImJWYWxpZFR5cGUiLCJnZXRUaW1lIiwiaXNTeW1ib2wiLCJhS2V5c0NvdW50Iiwia2V5cyIsImJLZXlzQ291bnQiLCJhSGFzS2V5IiwiYkhhc0tleSIsImxvb3NlSW5kZXhPZiIsImFyciIsImZpbmRJbmRleCIsInRvRGlzcGxheVN0cmluZyIsInRvU3RyaW5nIiwib2JqZWN0VG9TdHJpbmciLCJpc0Z1bmN0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcGxhY2VyIiwiX2tleSIsIl9fdl9pc1JlZiIsImlzTWFwIiwic2l6ZSIsImVudHJpZXMiLCJyZWR1Y2UiLCJpc1NldCIsInZhbHVlcyIsImlzUGxhaW5PYmplY3QiLCJFTVBUWV9PQkoiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJmcmVlemUiLCJFTVBUWV9BUlIiLCJOT09QIiwiTk8iLCJvblJFIiwiaXNPbiIsImlzTW9kZWxMaXN0ZW5lciIsImV4dGVuZCIsImFzc2lnbiIsInJlbW92ZSIsImVsIiwiaW5kZXhPZiIsInNwbGljZSIsInByb3RvdHlwZSIsImhhc093biIsImNhbGwiLCJBcnJheSIsInRvVHlwZVN0cmluZyIsImlzUmVnRXhwIiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwidG9SYXdUeXBlIiwiaXNJbnRlZ2VyS2V5IiwicGFyc2VJbnQiLCJpc1Jlc2VydmVkUHJvcCIsImlzQnVpbHRJbkRpcmVjdGl2ZSIsImNhY2hlU3RyaW5nRnVuY3Rpb24iLCJmbiIsImNhY2hlIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiYyIsInRvVXBwZXJDYXNlIiwiaHlwaGVuYXRlUkUiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwidG9IYW5kbGVyS2V5IiwiaGFzQ2hhbmdlZCIsIm9sZFZhbHVlIiwiaXMiLCJpbnZva2VBcnJheUZucyIsImZucyIsImFyZyIsImRlZiIsIm9iaiIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImxvb3NlVG9OdW1iZXIiLCJuIiwicGFyc2VGbG9hdCIsImlzTmFOIiwidG9OdW1iZXIiLCJOdW1iZXIiLCJOYU4iLCJfZ2xvYmFsVGhpcyIsImdldEdsb2JhbFRoaXMiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImlkZW50UkUiLCJnZW5Qcm9wc0FjY2Vzc0V4cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7139\n")},89:function(__unused_webpack_module,exports){"use strict";eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.Z = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUNiQSw2QkFBNkM7RUFBRUcsS0FBSyxFQUFFO0FBQUssQ0FBQyxDQUFDO0FBQzdEO0FBQ0E7QUFDQUQsU0FBZSxHQUFHLENBQUNHLEdBQUcsRUFBRUMsS0FBSyxLQUFLO0VBQzlCLE1BQU1DLE1BQU0sR0FBR0YsR0FBRyxDQUFDRyxTQUFTLElBQUlILEdBQUc7RUFDbkMsS0FBSyxNQUFNLENBQUNJLEdBQUcsRUFBRUMsR0FBRyxDQUFDLElBQUlKLEtBQUssRUFBRTtJQUM1QkMsTUFBTSxDQUFDRSxHQUFHLENBQUMsR0FBR0MsR0FBRztFQUNyQjtFQUNBLE9BQU9ILE1BQU07QUFDakIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzPzM3ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBydW50aW1lIGhlbHBlciBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIGNvbXBvbmVudHNcbi8vIGluIGEgdHJlZS1zaGFrYWJsZSB3YXlcbmV4cG9ydHMuZGVmYXVsdCA9IChzZmMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2ZjLl9fdmNjT3B0cyB8fCBzZmM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHByb3BzKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJzZmMiLCJwcm9wcyIsInRhcmdldCIsIl9fdmNjT3B0cyIsImtleSIsInZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89\n")},2483:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MA\": function() { return /* binding */ RouterView; },\n/* harmony export */   \"p7\": function() { return /* binding */ createRouter; },\n/* harmony export */   \"r5\": function() { return /* binding */ createWebHashHistory; }\n/* harmony export */ });\n/* unused harmony exports NavigationFailureType, RouterLink, START_LOCATION, createMemoryHistory, createRouterMatcher, createWebHistory, isNavigationFailure, loadRouteLocation, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey */\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7658);\n/* harmony import */ var core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(541);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3396);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4870);\n\n\n/*!\n  * vue-router v4.1.6\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\n\n\nconst isBrowser = typeof window !== 'undefined';\nfunction isESModule(obj) {\n  return obj.__esModule || obj[Symbol.toStringTag] === 'Module';\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nconst noop = () => {};\n/**\r\n * Typesafe alternative to Array.isArray\r\n * https://github.com/microsoft/TypeScript/pull/48228\r\n */\nconst isArray = Array.isArray;\nfunction warn(msg) {\n  // avoid using ...args as it breaks in older Edge builds\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\n}\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = path => path.replace(TRAILING_SLASH_RE, '');\n/**\r\n * Transforms a URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\nfunction parseURL(parseQuery, location, currentLocation = '/') {\n  let path,\n    query = {},\n    searchString = '',\n    hash = '';\n  // Could use URL and URLSearchParams but IE 11 doesn't support it\n  // TODO: move to new URL()\n  const hashPos = location.indexOf('#');\n  let searchPos = location.indexOf('?');\n  // the hash appears before the search, so it's not part of the search string\n  if (hashPos < searchPos && hashPos >= 0) {\n    searchPos = -1;\n  }\n  if (searchPos > -1) {\n    path = location.slice(0, searchPos);\n    searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n    query = parseQuery(searchString);\n  }\n  if (hashPos > -1) {\n    path = path || location.slice(0, hashPos);\n    // keep the # character\n    hash = location.slice(hashPos, location.length);\n  }\n  // no search and no query\n  path = resolveRelativePath(path != null ? path : location, currentLocation);\n  // empty path means a relative query or hash `?foo=f`, `#thing`\n  return {\n    fullPath: path + (searchString && '?') + searchString + hash,\n    path,\n    query,\n    hash\n  };\n}\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\nfunction stringifyURL(stringifyQuery, location) {\n  const query = location.query ? stringifyQuery(location.query) : '';\n  return location.path + (query && '?') + query + (location.hash || '');\n}\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\nfunction stripBase(pathname, base) {\n  // no base or base is not found at the beginning\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;\n  return pathname.slice(base.length) || '/';\n}\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery(a.query) === stringifyQuery(b.query) && a.hash === b.hash;\n}\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\nfunction isSameRouteRecord(a, b) {\n  // since the original record has an undefined value for aliasOf\n  // but all aliases point to the original record, this will always compare\n  // the original record\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (const key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;\n  }\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\nfunction isEquivalentArray(a, b) {\n  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith('/')) return to;\n  if (false) {}\n  if (!to) return from;\n  const fromSegments = from.split('/');\n  const toSegments = to.split('/');\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    // we stay on the same position\n    if (segment === '.') continue;\n    // go up in the from array\n    if (segment === '..') {\n      // we can't go below zero, but we still need to increment toPosition\n      if (position > 1) position--;\n      // continue\n    }\n    // we reached a non-relative path, we stop here\n    else break;\n  }\n  return fromSegments.slice(0, position).join('/') + '/' + toSegments\n  // ensure we use at least the last element in the toSegments\n  .slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join('/');\n}\nvar NavigationType;\n(function (NavigationType) {\n  NavigationType[\"pop\"] = \"pop\";\n  NavigationType[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function (NavigationDirection) {\n  NavigationDirection[\"back\"] = \"back\";\n  NavigationDirection[\"forward\"] = \"forward\";\n  NavigationDirection[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\r\n * Starting location for Histories\r\n */\nconst START = '';\n// Generic utils\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      // respect <base> tag\n      const baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/';\n      // strip full URL origin\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // ensure leading slash when it was removed by the regex above avoid leading\n  // slash with hash because the file could be read from the disk like file://\n  // and the leading slash would cause problems\n  if (base[0] !== '/' && base[0] !== '#') base = '/' + base;\n  // remove the trailing slash so all other method can just do `base + fullPath`\n  // to build an href\n  return removeTrailingSlash(base);\n}\n// remove any character before the hash\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n  return base.replace(BEFORE_HASH_RE, '#') + location;\n}\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nconst computeScrollPosition = () => ({\n  left: window.pageXOffset,\n  top: window.pageYOffset\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if ('el' in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\n    /**\r\n     * `id`s can accept pretty much any characters, including CSS combinators\r\n     * like `>` or `~`. It's still possible to retrieve elements using\r\n     * `document.getElementById('~')` but it needs to be escaped when using\r\n     * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n     * requirements for `id`s are them to be unique on the page and to not be\r\n     * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n     * be properly escaped for it to work with `querySelector`. We could check\r\n     * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n     * would make things inconsistent since they are valid characters for an\r\n     * `id` but would need to be escaped when using `querySelector`, breaking\r\n     * their usage and ending up in no selector returned. Selectors need to be\r\n     * escaped:\r\n     *\r\n     * - `#1-thing` becomes `#\\31 -thing`\r\n     * - `#with~symbols` becomes `#with\\\\~symbols`\r\n     *\r\n     * - More information about  the topic can be found at\r\n     *   https://mathiasbynens.be/notes/html5-id-class.\r\n     * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n     */\n    if (false) {}\n    const el = typeof positionEl === 'string' ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n       false && 0;\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n  if ('scrollBehavior' in document.documentElement.style) window.scrollTo(scrollToOptions);else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n  }\n}\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\nconst scrollPositions = new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  // consume it so it's not used again\n  scrollPositions.delete(key);\n  return scroll;\n}\n// TODO: RFC about how to save scroll position\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\nfunction createCurrentLocation(base, location) {\n  const {\n    pathname,\n    search,\n    hash\n  } = location;\n  // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\n  const hashPos = base.indexOf('#');\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    // prepend the starting slash to hash so the url starts with /#\n    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash;\n    return stripBase(pathFromHash, '');\n  }\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = [];\n  // TODO: should it be a stack? a Dict. Check if the popstate listener\n  // can trigger twice\n  let pauseState = null;\n  const popStateHandler = ({\n    state\n  }) => {\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      // ignore the popstate and reset the pauseState\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n      delta = fromState ? state.position - fromState.position : 0;\n    } else {\n      replace(to);\n    }\n    // console.log({ deltaFromCurrent })\n    // Here we could also revert the navigation by calling history.go(-delta)\n    // this listener will have to be adapted to not trigger again and to wait for the url\n    // to be updated before triggering the listeners. Some kind of validation function would also\n    // need to be passed to the listeners so the navigation can be accepted\n    // call all listeners\n    listeners.forEach(listener => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n  function listen(callback) {\n    // set up the listener and prepare teardown callbacks\n    listeners.push(callback);\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1) listeners.splice(index, 1);\n    };\n    teardowns.push(teardown);\n    return teardown;\n  }\n  function beforeUnloadListener() {\n    const {\n      history\n    } = window;\n    if (!history.state) return;\n    history.replaceState(assign({}, history.state, {\n      scroll: computeScrollPosition()\n    }), '');\n  }\n  function destroy() {\n    for (const teardown of teardowns) teardown();\n    teardowns = [];\n    window.removeEventListener('popstate', popStateHandler);\n    window.removeEventListener('beforeunload', beforeUnloadListener);\n  }\n  // set up the listeners and prepare teardown callbacks\n  window.addEventListener('popstate', popStateHandler);\n  window.addEventListener('beforeunload', beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\n/**\r\n * Creates a state object\r\n */\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\nfunction useHistoryStateNavigation(base) {\n  const {\n    history,\n    location\n  } = window;\n  // private variables\n  const currentLocation = {\n    value: createCurrentLocation(base, location)\n  };\n  const historyState = {\n    value: history.state\n  };\n  // build current history entry as this is a fresh navigation\n  if (!historyState.value) {\n    changeLocation(currentLocation.value, {\n      back: null,\n      current: currentLocation.value,\n      forward: null,\n      // the length is off by one, we need to decrease it\n      position: history.length - 1,\n      replaced: true,\n      // don't add a scroll as the user may have an anchor, and we want\n      // scrollBehavior to be triggered without a saved position\n      scroll: null\n    }, true);\n  }\n  function changeLocation(to, state, replace) {\n    /**\r\n     * if a base tag is provided, and we are on a normal domain, we have to\r\n     * respect the provided `base` attribute because pushState() will use it and\r\n     * potentially erase anything before the `#` like at\r\n     * https://github.com/vuejs/router/issues/685 where a base of\r\n     * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n     * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n     * base tag we can just use everything after the `#`.\r\n     */\n    const hashIndex = base.indexOf('#');\n    const url = hashIndex > -1 ? (location.host && document.querySelector('base') ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n    try {\n      // BROWSER QUIRK\n      // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n      history[replace ? 'replaceState' : 'pushState'](state, '', url);\n      historyState.value = state;\n    } catch (err) {\n      if (false) {} else {\n        console.error(err);\n      }\n      // Force the navigation, this also resets the call count\n      location[replace ? 'replace' : 'assign'](url);\n    }\n  }\n  function replace(to, data) {\n    const state = assign({}, history.state, buildState(historyState.value.back,\n    // keep back and forward entries but override current position\n    to, historyState.value.forward, true), data, {\n      position: historyState.value.position\n    });\n    changeLocation(to, state, true);\n    currentLocation.value = to;\n  }\n  function push(to, data) {\n    // Add to current entry the information of where we are going\n    // as well as saving the current position\n    const currentState = assign({},\n    // use current history state to gracefully handle a wrong call to\n    // history.replaceState\n    // https://github.com/vuejs/router/issues/366\n    historyState.value, history.state, {\n      forward: to,\n      scroll: computeScrollPosition()\n    });\n    if (false) {}\n    changeLocation(currentState.current, currentState, true);\n    const state = assign({}, buildState(currentLocation.value, to, null), {\n      position: currentState.position + 1\n    }, data);\n    changeLocation(to, state, false);\n    currentLocation.value = to;\n  }\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n  function go(delta, triggerListeners = true) {\n    if (!triggerListeners) historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  const routerHistory = assign({\n    // it's overridden right after\n    location: '',\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, 'state', {\n    enumerable: true,\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\n\n/**\r\n * Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\nfunction createMemoryHistory(base = '') {\n  let listeners = [];\n  let queue = [START];\n  let position = 0;\n  base = normalizeBase(base);\n  function setLocation(location) {\n    position++;\n    if (position === queue.length) {\n      // we are at the end, we can simply append a new entry\n      queue.push(location);\n    } else {\n      // we are in the middle, we remove everything from here in the queue\n      queue.splice(position);\n      queue.push(location);\n    }\n  }\n  function triggerListeners(to, from, {\n    direction,\n    delta\n  }) {\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n    for (const callback of listeners) {\n      callback(to, from, info);\n    }\n  }\n  const routerHistory = {\n    // rewritten by Object.defineProperty\n    location: START,\n    // TODO: should be kept in queue\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n    replace(to) {\n      // remove current entry and decrement position\n      queue.splice(position--, 1);\n      setLocation(to);\n    },\n    push(to, data) {\n      setLocation(to);\n    },\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1) listeners.splice(index, 1);\n      };\n    },\n    destroy() {\n      listeners = [];\n      queue = [START];\n      position = 0;\n    },\n    go(delta, shouldTrigger = true) {\n      const from = this.location;\n      const direction =\n      // we are considering delta === 0 going forward, but in abstract mode\n      // using 0 for the delta doesn't make sense like it does in html5 where\n      // it reloads the page\n      delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n      if (shouldTrigger) {\n        triggerListeners(this.location, from, {\n          direction,\n          delta\n        });\n      }\n    }\n  };\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () => queue[position]\n  });\n  return routerHistory;\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to\r\n * handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag\r\n * in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()\r\n * calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything\r\n * after the `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\nfunction createWebHashHistory(base) {\n  // Make sure this implementation is fine in terms of encoding, specially for IE11\n  // for `file://`, directly use the pathname and ignore the base\n  // location.pathname contains an initial `/` even at the root: `https://example.com`\n  base = location.host ? base || location.pathname + location.search : '';\n  // allow the user to provide a `#` in the middle: `/base/#/app`\n  if (!base.includes('#')) base += '#';\n  if (false) {}\n  return createWebHistory(base);\n}\nfunction isRouteLocation(route) {\n  return typeof route === 'string' || route && typeof route === 'object';\n}\nfunction isRouteName(name) {\n  return typeof name === 'string' || typeof name === 'symbol';\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\nconst START_LOCATION_NORMALIZED = {\n  path: '/',\n  name: undefined,\n  params: {},\n  query: {},\n  hash: '',\n  fullPath: '/',\n  matched: [],\n  meta: {},\n  redirectedFrom: undefined\n};\nconst NavigationFailureSymbol = Symbol( false ? 0 : '');\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\nvar NavigationFailureType;\n(function (NavigationFailureType) {\n  /**\r\n   * An aborted navigation is a navigation that failed because a navigation\r\n   * guard returned `false` or called `next(false)`\r\n   */\n  NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\n  /**\r\n   * A cancelled navigation is a navigation that failed because a more recent\r\n   * navigation finished started (not necessarily finished).\r\n   */\n  NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\n  /**\r\n   * A duplicated navigation is a navigation that failed because it was\r\n   * initiated while already being at the exact same location.\r\n   */\n  NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {}));\n// DEV only debug messages\nconst ErrorTypeMessages = {\n  [1 /* ErrorTypes.MATCHER_NOT_FOUND */]({\n    location,\n    currentLocation\n  }) {\n    return `No match for\\n ${JSON.stringify(location)}${currentLocation ? '\\nwhile being at\\n' + JSON.stringify(currentLocation) : ''}`;\n  },\n  [2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */]({\n    from,\n    to\n  }) {\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n  [4 /* ErrorTypes.NAVIGATION_ABORTED */]({\n    from,\n    to\n  }) {\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n  [8 /* ErrorTypes.NAVIGATION_CANCELLED */]({\n    from,\n    to\n  }) {\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n  [16 /* ErrorTypes.NAVIGATION_DUPLICATED */]({\n    from,\n    to\n  }) {\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n};\nfunction createRouterError(type, params) {\n  // keep full error messages in cjs versions\n  if (false) {} else {\n    return assign(new Error(), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  }\n}\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nconst propertiesToLog = ['params', 'query', 'hash'];\nfunction stringifyRoute(to) {\n  if (typeof to === 'string') return to;\n  if ('path' in to) return to.path;\n  const location = {};\n  for (const key of propertiesToLog) {\n    if (key in to) location[key] = to[key];\n  }\n  return JSON.stringify(location, null, 2);\n}\n\n// default pattern for a param: non-greedy everything but /\nconst BASE_PARAM_PATTERN = '[^/]+?';\nconst BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n};\n// Special Regex characters that must be escaped in static tokens\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n  // the amount of scores is the same as the length of segments except for the root segment \"/\"\n  const score = [];\n  // the regexp as a string\n  let pattern = options.start ? '^' : '';\n  // extracted keys\n  const keys = [];\n  for (const segment of segments) {\n    // the root segment needs special treatment\n    const segmentScores = segment.length ? [] : [90 /* PathScore.Root */];\n    // allow trailing slash\n    if (options.strict && !segment.length) pattern += '/';\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex];\n      // resets the score if we are inside a sub-segment /:a-other-:b\n      let subSegmentScore = 40 /* PathScore.Segment */ + (options.sensitive ? 0.25 /* PathScore.BonusCaseSensitive */ : 0);\n      if (token.type === 0 /* TokenType.Static */) {\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) pattern += '/';\n        pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\n        subSegmentScore += 40 /* PathScore.Static */;\n      } else if (token.type === 1 /* TokenType.Param */) {\n        const {\n          value,\n          repeatable,\n          optional,\n          regexp\n        } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re = regexp ? regexp : BASE_PARAM_PATTERN;\n        // the user provided a custom regexp /:id(\\\\d+)\n        if (re !== BASE_PARAM_PATTERN) {\n          subSegmentScore += 10 /* PathScore.BonusCustomRegExp */;\n          // make sure the regexp is valid before using it\n          try {\n            new RegExp(`(${re})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` + err.message);\n          }\n        }\n        // when we repeat we must take care of the repeating leading slash\n        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) subPattern =\n        // avoid an optional / if there are more segments e.g. /:p?-static\n        // or /:p?-:p2\n        optional && segment.length < 2 ? `(?:/${subPattern})` : '/' + subPattern;\n        if (optional) subPattern += '?';\n        pattern += subPattern;\n        subSegmentScore += 20 /* PathScore.Dynamic */;\n        if (optional) subSegmentScore += -8 /* PathScore.BonusOptional */;\n        if (repeatable) subSegmentScore += -20 /* PathScore.BonusRepeatable */;\n        if (re === '.*') subSegmentScore += -50 /* PathScore.BonusWildcard */;\n      }\n      segmentScores.push(subSegmentScore);\n    }\n    // an empty array like /home/ -> [[{home}], []]\n    // if (!segment.length) pattern += '/'\n    score.push(segmentScores);\n  }\n  // only apply the strict bonus to the last score\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += 0.7000000000000001 /* PathScore.BonusStrict */;\n  }\n  // TODO: dev only warn double trailing slash\n  if (!options.strict) pattern += '/?';\n  if (options.end) pattern += '$';\n  // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n  else if (options.strict) pattern += '(?:/|$)';\n  const re = new RegExp(pattern, options.sensitive ? '' : 'i');\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match) return null;\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || '';\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split('/') : value;\n    }\n    return params;\n  }\n  function stringify(params) {\n    let path = '';\n    // for optional parameters to allow to be empty\n    let avoidDuplicatedSlash = false;\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith('/')) path += '/';\n      avoidDuplicatedSlash = false;\n      for (const token of segment) {\n        if (token.type === 0 /* TokenType.Static */) {\n          path += token.value;\n        } else if (token.type === 1 /* TokenType.Param */) {\n          const {\n            value,\n            repeatable,\n            optional\n          } = token;\n          const param = value in params ? params[value] : '';\n          if (isArray(param) && !repeatable) {\n            throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n          }\n          const text = isArray(param) ? param.join('/') : param;\n          if (!text) {\n            if (optional) {\n              // if we have more than one optional param like /:a?-static we don't need to care about the optional param\n              if (segment.length < 2) {\n                // remove the last slash as we could be at the end\n                if (path.endsWith('/')) path = path.slice(0, -1);\n                // do not append a slash on the next iteration\n                else avoidDuplicatedSlash = true;\n              }\n            } else throw new Error(`Missing required param \"${value}\"`);\n          }\n          path += text;\n        }\n      }\n    }\n    // avoid empty path when we have multiple optional params\n    return path || '/';\n  }\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n *\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\nfunction compareScoreArray(a, b) {\n  let i = 0;\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i];\n    // only keep going if diff === 0\n    if (diff) return diff;\n    i++;\n  }\n  // if the last subsegment was Static, the shorter segments should be sorted first\n  // otherwise sort the longest segment first\n  if (a.length < b.length) {\n    return a.length === 1 && a[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */ ? -1 : 1;\n  } else if (a.length > b.length) {\n    return b.length === 1 && b[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */ ? 1 : -1;\n  }\n  return 0;\n}\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n *\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]);\n    // do not return if both are equal\n    if (comp) return comp;\n    i++;\n  }\n  if (Math.abs(bScore.length - aScore.length) === 1) {\n    if (isLastScoreNegative(aScore)) return 1;\n    if (isLastScoreNegative(bScore)) return -1;\n  }\n  // if a and b share the same score entries but b has more, sort b first\n  return bScore.length - aScore.length;\n  // this is the ternary version\n  // return aScore.length < bScore.length\n  //   ? 1\n  //   : aScore.length > bScore.length\n  //   ? -1\n  //   : 0\n}\n/**\r\n * This allows detecting splats at the end of a path: /home/:id(.*)*\r\n *\r\n * @param score - score to check\r\n * @returns true if the last entry is negative\r\n */\nfunction isLastScoreNegative(score) {\n  const last = score[score.length - 1];\n  return score.length > 0 && last[last.length - 1] < 0;\n}\nconst ROOT_TOKEN = {\n  type: 0 /* TokenType.Static */,\n  value: ''\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\n// After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\nfunction tokenizePath(path) {\n  if (!path) return [[]];\n  if (path === '/') return [[ROOT_TOKEN]];\n  if (!path.startsWith('/')) {\n    throw new Error( false ? 0 : `Invalid path \"${path}\"`);\n  }\n  // if (tokenCache.has(path)) return tokenCache.get(path)!\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n  let state = 0 /* TokenizerState.Static */;\n  let previousState = state;\n  const tokens = [];\n  // the segment will always be valid because we get into the initial state\n  // with the leading /\n  let segment;\n  function finalizeSegment() {\n    if (segment) tokens.push(segment);\n    segment = [];\n  }\n  // index on the path\n  let i = 0;\n  // char at index\n  let char;\n  // buffer of the value read\n  let buffer = '';\n  // custom regexp for a param\n  let customRe = '';\n  function consumeBuffer() {\n    if (!buffer) return;\n    if (state === 0 /* TokenizerState.Static */) {\n      segment.push({\n        type: 0 /* TokenType.Static */,\n        value: buffer\n      });\n    } else if (state === 1 /* TokenizerState.Param */ || state === 2 /* TokenizerState.ParamRegExp */ || state === 3 /* TokenizerState.ParamRegExpEnd */) {\n      if (segment.length > 1 && (char === '*' || char === '+')) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: 1 /* TokenType.Param */,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === '*' || char === '+',\n        optional: char === '*' || char === '?'\n      });\n    } else {\n      crash('Invalid state to consume buffer');\n    }\n    buffer = '';\n  }\n  function addCharToBuffer() {\n    buffer += char;\n  }\n  while (i < path.length) {\n    char = path[i++];\n    if (char === '\\\\' && state !== 2 /* TokenizerState.ParamRegExp */) {\n      previousState = state;\n      state = 4 /* TokenizerState.EscapeNext */;\n      continue;\n    }\n    switch (state) {\n      case 0 /* TokenizerState.Static */:\n        if (char === '/') {\n          if (buffer) {\n            consumeBuffer();\n          }\n          finalizeSegment();\n        } else if (char === ':') {\n          consumeBuffer();\n          state = 1 /* TokenizerState.Param */;\n        } else {\n          addCharToBuffer();\n        }\n        break;\n      case 4 /* TokenizerState.EscapeNext */:\n        addCharToBuffer();\n        state = previousState;\n        break;\n      case 1 /* TokenizerState.Param */:\n        if (char === '(') {\n          state = 2 /* TokenizerState.ParamRegExp */;\n        } else if (VALID_PARAM_RE.test(char)) {\n          addCharToBuffer();\n        } else {\n          consumeBuffer();\n          state = 0 /* TokenizerState.Static */;\n          // go back one character if we were not modifying\n          if (char !== '*' && char !== '?' && char !== '+') i--;\n        }\n        break;\n      case 2 /* TokenizerState.ParamRegExp */:\n        // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n        // it already works by escaping the closing )\n        // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n        // is this really something people need since you can also write\n        // /prefix_:p()_suffix\n        if (char === ')') {\n          // handle the escaped )\n          if (customRe[customRe.length - 1] == '\\\\') customRe = customRe.slice(0, -1) + char;else state = 3 /* TokenizerState.ParamRegExpEnd */;\n        } else {\n          customRe += char;\n        }\n        break;\n      case 3 /* TokenizerState.ParamRegExpEnd */:\n        // same as finalizing a param\n        consumeBuffer();\n        state = 0 /* TokenizerState.Static */;\n        // go back one character if we were not modifying\n        if (char !== '*' && char !== '?' && char !== '+') i--;\n        customRe = '';\n        break;\n      default:\n        crash('Unknown state');\n        break;\n    }\n  }\n  if (state === 2 /* TokenizerState.ParamRegExp */) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment();\n  // tokenCache.set(path, tokens)\n  return tokens;\n}\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options);\n  // warn against params with the same name\n  if (false) {}\n  const matcher = assign(parser, {\n    record,\n    parent,\n    // these needs to be populated by the parent\n    children: [],\n    alias: []\n  });\n  if (parent) {\n    // both are aliases or both are not aliases\n    // we don't want to mix them because the order is used when\n    // passing originalRecord in Matcher.addRoute\n    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n  }\n  return matcher;\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\nfunction createRouterMatcher(routes, globalOptions) {\n  // normalized ordered array of matchers\n  const matchers = [];\n  const matcherMap = new Map();\n  globalOptions = mergeOptions({\n    strict: false,\n    end: true,\n    sensitive: false\n  }, globalOptions);\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n  function addRoute(record, parent, originalRecord) {\n    // used later on to remove by name\n    const isRootAdd = !originalRecord;\n    const mainNormalizedRecord = normalizeRouteRecord(record);\n    if (false) {}\n    // we might be the child of an alias\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record);\n    // generate an array of records to correctly handle aliases\n    const normalizedRecords = [mainNormalizedRecord];\n    if ('alias' in record) {\n      const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\n      for (const alias of aliases) {\n        normalizedRecords.push(assign({}, mainNormalizedRecord, {\n          // this allows us to hold a copy of the `components` option\n          // so that async components cache is hold on the original record\n          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n          path: alias,\n          // we might be the child of an alias\n          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n          // the aliases are always of the same kind as the original since they\n          // are defined on the same record\n        }));\n      }\n    }\n    let matcher;\n    let originalMatcher;\n    for (const normalizedRecord of normalizedRecords) {\n      const {\n        path\n      } = normalizedRecord;\n      // Build up the path for nested routes if the child isn't an absolute\n      // route. Only add the / delimiter if the child path isn't empty and if the\n      // parent path doesn't have a trailing slash\n      if (parent && path[0] !== '/') {\n        const parentPath = parent.record.path;\n        const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n      if (false) {}\n      // create the object beforehand, so it can be passed to children\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (false) {}\n      // if we are an alias we must tell the original record that we exist,\n      // so we can be removed\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n        if (false) {}\n      } else {\n        // otherwise, the first record is the original and others are aliases\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);\n        // remove the route if named and only for the top record (avoid in nested calls)\n        // this works because the original record is the first one\n        if (isRootAdd && record.name && !isAliasRecord(matcher)) removeRoute(record.name);\n      }\n      if (mainNormalizedRecord.children) {\n        const children = mainNormalizedRecord.children;\n        for (let i = 0; i < children.length; i++) {\n          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n        }\n      }\n      // if there was no original record, then the first one was not an alias and all\n      // other aliases (if any) need to reference this record when adding children\n      originalRecord = originalRecord || matcher;\n      // TODO: add normalized records for more flexibility\n      // if (parent && isAliasRecord(originalRecord)) {\n      //   parent.children.push(originalRecord)\n      // }\n      // Avoid adding a record that doesn't display anything. This allows passing through records without a component to\n      // not be reached and pass through the catch all route\n      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {\n        insertMatcher(matcher);\n      }\n    }\n    return originalMatcher ? () => {\n      // since other matchers are aliases, they should be removed by the original matcher\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      const index = matchers.indexOf(matcherRef);\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n  function getRoutes() {\n    return matchers;\n  }\n  function insertMatcher(matcher) {\n    let i = 0;\n    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (\n    // Adding children with empty path should still appear before the parent\n    // https://github.com/vuejs/router/issues/1124\n    matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i]))) i++;\n    matchers.splice(i, 0, matcher);\n    // only add the original record to the name map\n    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n  }\n  function resolve(location, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n    if ('name' in location && location.name) {\n      matcher = matcherMap.get(location.name);\n      if (!matcher) throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {\n        location\n      });\n      // warn if the user is passing invalid params so they can debug it better when they get removed\n      if (false) {}\n      name = matcher.record.name;\n      params = assign(\n      // paramsFromLocation is a new object\n      paramsFromLocation(currentLocation.params,\n      // only keep params that exist in the resolved location\n      // TODO: only keep optional params coming from a parent record\n      matcher.keys.filter(k => !k.optional).map(k => k.name)),\n      // discard any existing params in the current location that do not exist here\n      // #1497 this ensures better active/exact matching\n      location.params && paramsFromLocation(location.params, matcher.keys.map(k => k.name)));\n      // throws if cannot be stringified\n      path = matcher.stringify(params);\n    } else if ('path' in location) {\n      // no need to resolve the path with the matcher as it was provided\n      // this also allows the user to control the encoding\n      path = location.path;\n      if (false) {}\n      matcher = matchers.find(m => m.re.test(path));\n      // matcher should have a value after the loop\n      if (matcher) {\n        // we know the matcher works because we tested the regexp\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      }\n      // location is a relative path\n    } else {\n      // match by name or path of current route\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(m => m.re.test(currentLocation.path));\n      if (!matcher) throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {\n        location,\n        currentLocation\n      });\n      name = matcher.record.name;\n      // since we are navigating to the same location, we don't need to pick the\n      // params like when `name` is provided\n      params = assign({}, currentLocation.params, location.params);\n      path = matcher.stringify(params);\n    }\n    const matched = [];\n    let parentMatcher = matcher;\n    while (parentMatcher) {\n      // reversed order so parents are at the beginning\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  }\n  // add initial routes\n  routes.forEach(route => addRoute(route));\n  return {\n    addRoute,\n    resolve,\n    removeRoute,\n    getRoutes,\n    getRecordMatcher\n  };\n}\nfunction paramsFromLocation(params, keys) {\n  const newParams = {};\n  for (const key of keys) {\n    if (key in params) newParams[key] = params[key];\n  }\n  return newParams;\n}\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\nfunction normalizeRouteRecord(record) {\n  return {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: undefined,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: new Set(),\n    updateGuards: new Set(),\n    enterCallbacks: {},\n    components: 'components' in record ? record.components || null : record.component && {\n      default: record.component\n    }\n  };\n}\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\nfunction normalizeRecordProps(record) {\n  const propsObject = {};\n  // props does not exist on redirect records, but we can set false directly\n  const props = record.props || false;\n  if ('component' in record) {\n    propsObject.default = props;\n  } else {\n    // NOTE: we could also allow a function to be applied to every component.\n    // Would need user feedback for use cases\n    for (const name in record.components) propsObject[name] = typeof props === 'boolean' ? props : props[name];\n  }\n  return propsObject;\n}\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf) return true;\n    record = record.parent;\n  }\n  return false;\n}\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n  const options = {};\n  for (const key in defaults) {\n    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  }\n  return options;\n}\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\n/**\r\n * Check if a path and its alias have the same required params\r\n *\r\n * @param a - original record\r\n * @param b - alias record\r\n */\nfunction checkSameParams(a, b) {\n  for (const key of a.keys) {\n    if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  }\n  for (const key of b.keys) {\n    if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n  }\n}\n/**\r\n * A route with a name and a child with an empty path without a name should warn when adding the route\r\n *\r\n * @param mainNormalizedRecord - RouteRecordNormalized\r\n * @param parent - RouteRecordMatcher\r\n */\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {\n    warn(`The route named \"${String(parent.record.name)}\" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);\n  }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (const key of parent.keys) {\n    if (!record.keys.find(isSameParam.bind(null, key))) return warn(`Absolute path \"${record.record.path}\" must have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n  }\n}\nfunction isRecordChildOf(record, parent) {\n  return parent.children.some(child => child === record || isRecordChildOf(record, child));\n}\n\n/**\r\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\n// const EXTRA_RESERVED_RE = /[!'()*]/g\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\nconst HASH_RE = /#/g; // %23\nconst AMPERSAND_RE = /&/g; // %26\nconst SLASH_RE = /\\//g; // %2F\nconst EQUAL_RE = /=/g; // %3D\nconst IM_RE = /\\?/g; // %3F\nconst PLUS_RE = /\\+/g; // %2B\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query, but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\nconst ENC_CARET_RE = /%5E/g; // ^\nconst ENC_BACKTICK_RE = /%60/g; // `\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\nconst ENC_PIPE_RE = /%7C/g; // |\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\nconst ENC_SPACE_RE = /%20/g; // }\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction commonEncode(text) {\n  return encodeURI('' + text).replace(ENC_PIPE_RE, '|').replace(ENC_BRACKET_OPEN_RE, '[').replace(ENC_BRACKET_CLOSE_RE, ']');\n}\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeQueryValue(text) {\n  return commonEncode(text)\n  // Encode the space as +, encode the + to differentiate it from the space\n  .replace(PLUS_RE, '%2B').replace(ENC_SPACE_RE, '+').replace(HASH_RE, '%23').replace(AMPERSAND_RE, '%26').replace(ENC_BACKTICK_RE, '`').replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\n}\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\n}\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\r\n * string instead.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeParam(text) {\n  return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\n}\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\nfunction decode(text) {\n  try {\n    return decodeURIComponent('' + text);\n  } catch (err) {\n     false && 0;\n  }\n  return '' + text;\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\nfunction parseQuery(search) {\n  const query = {};\n  // avoid creating an object with an empty key and empty value\n  // because of split('&')\n  if (search === '' || search === '?') return query;\n  const hasLeadingIM = search[0] === '?';\n  const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\n  for (let i = 0; i < searchParams.length; ++i) {\n    // pre decode the + into space\n    const searchParam = searchParams[i].replace(PLUS_RE, ' ');\n    // allow the = character\n    const eqPos = searchParam.indexOf('=');\n    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n    if (key in query) {\n      // an extra variable for ts types\n      let currentValue = query[key];\n      if (!isArray(currentValue)) {\n        currentValue = query[key] = [currentValue];\n      }\n      currentValue.push(value);\n    } else {\n      query[key] = value;\n    }\n  }\n  return query;\n}\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\nfunction stringifyQuery(query) {\n  let search = '';\n  for (let key in query) {\n    const value = query[key];\n    key = encodeQueryKey(key);\n    if (value == null) {\n      // only null adds the value\n      if (value !== undefined) {\n        search += (search.length ? '&' : '') + key;\n      }\n      continue;\n    }\n    // keep null values\n    const values = isArray(value) ? value.map(v => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];\n    values.forEach(value => {\n      // skip undefined values in arrays as if they were not present\n      // smaller code than using filter\n      if (value !== undefined) {\n        // only append & with non-empty search\n        search += (search.length ? '&' : '') + key;\n        if (value != null) search += '=' + value;\n      }\n    });\n  }\n  return search;\n}\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n  for (const key in query) {\n    const value = query[key];\n    if (value !== undefined) {\n      normalizedQuery[key] = isArray(value) ? value.map(v => v == null ? null : '' + v) : value == null ? value : '' + value;\n    }\n  }\n  return normalizedQuery;\n}\n\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\nconst matchedRouteKey = Symbol( false ? 0 : '');\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\nconst viewDepthKey = Symbol( false ? 0 : '');\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\nconst routerKey = Symbol( false ? 0 : '');\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\nconst routeLocationKey = Symbol( false ? 0 : '');\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\nconst routerViewLocationKey = Symbol( false ? 0 : '');\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\nfunction useCallbacks() {\n  let handlers = [];\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1) handlers.splice(i, 1);\n    };\n  }\n  function reset() {\n    handlers = [];\n  }\n  return {\n    add,\n    list: () => handlers,\n    reset\n  };\n}\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (false) {}\n  const activeRecord = inject(matchedRouteKey,\n  // to avoid warning\n  {}).value;\n  if (!activeRecord) {\n     false && 0;\n    return;\n  }\n  registerGuard(activeRecord, 'leaveGuards', leaveGuard);\n}\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (false) {}\n  const activeRecord = inject(matchedRouteKey,\n  // to avoid warning\n  {}).value;\n  if (!activeRecord) {\n     false && 0;\n    return;\n  }\n  registerGuard(activeRecord, 'updateGuards', updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n  // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n  const enterCallbackArray = record && (\n  // name is defined if record is because of the function overload\n  record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = valid => {\n      if (valid === false) {\n        reject(createRouterError(4 /* ErrorTypes.NAVIGATION_ABORTED */, {\n          from,\n          to\n        }));\n      } else if (valid instanceof Error) {\n        reject(valid);\n      } else if (isRouteLocation(valid)) {\n        reject(createRouterError(2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */, {\n          from: to,\n          to: valid\n        }));\n      } else {\n        if (enterCallbackArray &&\n        // since enterCallbackArray is truthy, both record and name also are\n        record.enterCallbacks[name] === enterCallbackArray && typeof valid === 'function') {\n          enterCallbackArray.push(valid);\n        }\n        resolve();\n      }\n    };\n    // wrapping with Promise.resolve allows it to work with both async and sync guards\n    const guardReturn = guard.call(record && record.instances[name], to, from,  false ? 0 : next);\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3) guardCall = guardCall.then(next);\n    if (false) {}\n    guardCall.catch(err => reject(err));\n  });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function () {\n    if (called++ === 1) warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n    // @ts-expect-error: we put it in the original one because it's easier to check\n    next._called = true;\n    if (called === 1) next.apply(null, arguments);\n  };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n  const guards = [];\n  for (const record of matched) {\n    if (false) {}\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n      if (false) {}\n      // skip update and leave guards if the route component is not mounted\n      if (guardType !== 'beforeRouteEnter' && !record.instances[name]) continue;\n      if (isRouteComponent(rawComponent)) {\n        // __vccOpts is added by vue-class-component and contain the regular options\n        const options = rawComponent.__vccOpts || rawComponent;\n        const guard = options[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n      } else {\n        // start requesting the chunk already\n        let componentPromise = rawComponent();\n        if (false) {}\n        guards.push(() => componentPromise.then(resolved => {\n          if (!resolved) return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n          // replace the function with the resolved component\n          // cannot be null or undefined because we went into the for loop\n          record.components[name] = resolvedComponent;\n          // __vccOpts is added by vue-class-component and contain the regular options\n          const options = resolvedComponent.__vccOpts || resolvedComponent;\n          const guard = options[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name)();\n        }));\n      }\n    }\n  }\n  return guards;\n}\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @internal\r\n *\r\n * @param component\r\n */\nfunction isRouteComponent(component) {\n  return typeof component === 'object' || 'displayName' in component || 'props' in component || '__vccOpts' in component;\n}\n/**\r\n * Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.\r\n *\r\n * @param route - resolved route to load\r\n */\nfunction loadRouteLocation(route) {\n  return route.matched.every(record => record.redirect) ? Promise.reject(new Error('Cannot load a route that redirects.')) : Promise.all(route.matched.map(record => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {\n    const rawComponent = record.components[name];\n    if (typeof rawComponent === 'function' && !('displayName' in rawComponent)) {\n      promises.push(rawComponent().then(resolved => {\n        if (!resolved) return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\". Ensure you passed a function that returns a promise.`));\n        const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n        // replace the function with the resolved component\n        // cannot be null or undefined because we went into the for loop\n        record.components[name] = resolvedComponent;\n        return;\n      }));\n    }\n    return promises;\n  }, [])))).then(() => route);\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\nfunction useLink(props) {\n  const router = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .inject */ .f3)(routerKey);\n  const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .inject */ .f3)(routeLocationKey);\n  const route = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => router.resolve((0,vue__WEBPACK_IMPORTED_MODULE_3__/* .unref */ .SU)(props.to)));\n  const activeRecordIndex = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => {\n    const {\n      matched\n    } = route.value;\n    const {\n      length\n    } = matched;\n    const routeMatched = matched[length - 1];\n    const currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length) return -1;\n    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1) return index;\n    // possible parent record\n    const parentRecordPath = getOriginalPath(matched[length - 2]);\n    return (\n      // we are dealing with nested routes\n      length > 1 &&\n      // if the parent and matched route have the same path, this link is\n      // referring to the empty child. Or we currently are on a different\n      // child of the same parent\n      getOriginalPath(routeMatched) === parentRecordPath &&\n      // avoid comparing the child with its parent\n      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index\n    );\n  });\n  const isActive = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n  function navigate(e = {}) {\n    if (guardEvent(e)) {\n      return router[(0,vue__WEBPACK_IMPORTED_MODULE_3__/* .unref */ .SU)(props.replace) ? 'replace' : 'push']((0,vue__WEBPACK_IMPORTED_MODULE_3__/* .unref */ .SU)(props.to)\n      // avoid uncaught errors are they are logged anyway\n      ).catch(noop);\n    }\n    return Promise.resolve();\n  }\n  // devtools only\n  if (false) {}\n  /**\r\n   * NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this\r\n   */\n  return {\n    route,\n    href: (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\nconst RouterLinkImpl = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_2__/* .defineComponent */ .aZ)({\n  name: 'RouterLink',\n  compatConfig: {\n    MODE: 3\n  },\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    // inactiveClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: 'page'\n    }\n  },\n  useLink,\n  setup(props, {\n    slots\n  }) {\n    const link = (0,vue__WEBPACK_IMPORTED_MODULE_3__/* .reactive */ .qj)(useLink(props));\n    const {\n      options\n    } = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .inject */ .f3)(routerKey);\n    const elClass = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\n      // [getLinkClass(\n      //   props.inactiveClass,\n      //   options.linkInactiveClass,\n      //   'router-link-inactive'\n      // )]: !link.isExactActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && slots.default(link);\n      return props.custom ? children : (0,vue__WEBPACK_IMPORTED_MODULE_2__.h)('a', {\n        'aria-current': link.isExactActive ? props.ariaCurrentValue : null,\n        href: link.href,\n        // this would override user added attrs but Vue will still add\n        // the listener, so we end up triggering both\n        onClick: link.navigate,\n        class: elClass.value\n      }, children);\n    };\n  }\n});\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) return;\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) return;\n  // don't redirect if `target=\"_blank\"`\n  // @ts-expect-error getAttribute does exist\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    // @ts-expect-error getAttribute exists\n    const target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) return;\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) e.preventDefault();\n  return true;\n}\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === 'string') {\n      if (innerValue !== outerValue) return false;\n    } else {\n      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : '';\n}\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\nconst RouterViewImpl = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_2__/* .defineComponent */ .aZ)({\n  name: 'RouterView',\n  // #674 we manually inherit them\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    },\n    route: Object\n  },\n  // Better compat for @vue/compat users\n  // https://github.com/vuejs/router/issues/1315\n  compatConfig: {\n    MODE: 3\n  },\n  setup(props, {\n    attrs,\n    slots\n  }) {\n     false && 0;\n    const injectedRoute = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .inject */ .f3)(routerViewLocationKey);\n    const routeToDisplay = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => props.route || injectedRoute.value);\n    const injectedDepth = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .inject */ .f3)(viewDepthKey, 0);\n    // The depth changes based on empty components option, which allows passthrough routes e.g. routes with children\n    // that are used to reuse the `path` property\n    const depth = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => {\n      let initialDepth = (0,vue__WEBPACK_IMPORTED_MODULE_3__/* .unref */ .SU)(injectedDepth);\n      const {\n        matched\n      } = routeToDisplay.value;\n      let matchedRoute;\n      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {\n        initialDepth++;\n      }\n      return initialDepth;\n    });\n    const matchedRouteRef = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => routeToDisplay.value.matched[depth.value]);\n    (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .provide */ .JJ)(viewDepthKey, (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => depth.value + 1));\n    (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .provide */ .JJ)(matchedRouteKey, matchedRouteRef);\n    (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .provide */ .JJ)(routerViewLocationKey, routeToDisplay);\n    const viewRef = (0,vue__WEBPACK_IMPORTED_MODULE_3__/* .ref */ .iH)();\n    // watch at the same time the component instance, the route record we are\n    // rendering, and the name\n    (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .watch */ .YP)(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n      // copy reused instances\n      if (to) {\n        // this will update the instance for new instances as well as reused\n        // instances when navigating to a new route\n        to.instances[name] = instance;\n        // the component instance is reused for a different route or name, so\n        // we copy any saved update or leave guards. With async setup, the\n        // mounting component will mount before the matchedRoute changes,\n        // making instance === oldInstance, so we check if guards have been\n        // added before. This works because we remove guards when\n        // unmounting/deactivating components\n        if (from && from !== to && instance && instance === oldInstance) {\n          if (!to.leaveGuards.size) {\n            to.leaveGuards = from.leaveGuards;\n          }\n          if (!to.updateGuards.size) {\n            to.updateGuards = from.updateGuards;\n          }\n        }\n      }\n      // trigger beforeRouteEnter next callbacks\n      if (instance && to && (\n      // if there is no instance but to and from are the same this might be\n      // the first visit\n      !from || !isSameRouteRecord(to, from) || !oldInstance)) {\n        (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n      }\n    }, {\n      flush: 'post'\n    });\n    return () => {\n      const route = routeToDisplay.value;\n      // we need the value at the time we render because when we unmount, we\n      // navigated to a different location so the value is different\n      const currentName = props.name;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[currentName];\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, {\n          Component: ViewComponent,\n          route\n        });\n      }\n      // props from route configuration\n      const routePropsOption = matchedRoute.props[currentName];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === 'function' ? routePropsOption(route) : routePropsOption : null;\n      const onVnodeUnmounted = vnode => {\n        // remove the instance reference to prevent leak\n        if (vnode.component.isUnmounted) {\n          matchedRoute.instances[currentName] = null;\n        }\n      };\n      const component = (0,vue__WEBPACK_IMPORTED_MODULE_2__.h)(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n      if (false) {}\n      return (\n        // pass the vnode to the slot as a prop.\n        // h and <component :is=\"...\"> both accept vnodes\n        normalizeSlot(slots.default, {\n          Component: component,\n          route\n        }) || component\n      );\n    };\n  }\n});\nfunction normalizeSlot(slot, data) {\n  if (!slot) return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\r\n * Component to display the current route the user is at.\r\n */\nconst RouterView = RouterViewImpl;\n// warn against deprecated usage with <transition> & <keep-alive>\n// due to functional component being no longer eager in Vue 3\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n  if (parentName && (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\n    const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\n    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` + `Use slot props instead:\\n\\n` + `<router-view v-slot=\"{ Component }\">\\n` + `  <${comp}>\\n` + `    <component :is=\"Component\" />\\n` + `  </${comp}>\\n` + `</router-view>`);\n  }\n}\n\n/**\r\n * Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).\r\n *\r\n * @param routeLocation - routeLocation to format\r\n * @param tooltip - optional tooltip\r\n * @returns a copy of the routeLocation\r\n */\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    // remove variables that can contain vue instances\n    matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf']))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\n// to support multiple router instances\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n  // Take over router.beforeEach and afterEach\n  // make sure we are not registering the devtool twice\n  if (router.__hasDevtools) return;\n  router.__hasDevtools = true;\n  // increment to support multiple router instances\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: 'org.vuejs.router' + (id ? '.' + id : ''),\n    label: 'Vue Router',\n    packageName: 'vue-router',\n    homepage: 'https://router.vuejs.org',\n    logo: 'https://router.vuejs.org/logo.png',\n    componentStateTypes: ['Routing'],\n    app\n  }, api => {\n    if (typeof api.now !== 'function') {\n      console.warn('[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n    }\n    // display state added by the router\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) {\n        payload.instanceData.state.push({\n          type: 'Routing',\n          key: '$route',\n          editable: false,\n          value: formatRouteLocation(router.currentRoute.value, 'Current Route')\n        });\n      }\n    });\n    // mark router-link as active and display tags on router views\n    api.on.visitComponentTree(({\n      treeNode: node,\n      componentInstance\n    }) => {\n      if (componentInstance.__vrv_devtools) {\n        const info = componentInstance.__vrv_devtools;\n        node.tags.push({\n          label: (info.name ? `${info.name.toString()}: ` : '') + info.path,\n          textColor: 0,\n          tooltip: 'This component is rendered by &lt;router-view&gt;',\n          backgroundColor: PINK_500\n        });\n      }\n      // if multiple useLink are used\n      if (isArray(componentInstance.__vrl_devtools)) {\n        componentInstance.__devtoolsApi = api;\n        componentInstance.__vrl_devtools.forEach(devtoolsData => {\n          let backgroundColor = ORANGE_400;\n          let tooltip = '';\n          if (devtoolsData.isExactActive) {\n            backgroundColor = LIME_500;\n            tooltip = 'This is exactly active';\n          } else if (devtoolsData.isActive) {\n            backgroundColor = BLUE_600;\n            tooltip = 'This link is active';\n          }\n          node.tags.push({\n            label: devtoolsData.route.path,\n            textColor: 0,\n            tooltip,\n            backgroundColor\n          });\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      // refresh active state\n      refreshRoutesView();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n      api.sendInspectorState(routerInspectorId);\n    });\n    const navigationsLayerId = 'router:navigations:' + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? ' ' + id : ''} Navigations`,\n      color: 0x40a8c4\n    });\n    // const errorsLayerId = 'router:errors'\n    // api.addTimelineLayer({\n    //   id: errorsLayerId,\n    //   label: 'Router Errors',\n    //   color: 0xea5455,\n    // })\n    router.onError((error, to) => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: 'Error during Navigation',\n          subtitle: to.fullPath,\n          logType: 'error',\n          time: api.now(),\n          data: {\n            error\n          },\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    // attached to `meta` and used to group events\n    let navigationId = 0;\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay('beforeEach'),\n        from: formatRouteLocation(from, 'Current Location during this navigation'),\n        to: formatRouteLocation(to, 'Target location')\n      };\n      // Used to group navigations together, hide from devtools\n      Object.defineProperty(to.meta, '__navigationId', {\n        value: navigationId++\n      });\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: api.now(),\n          title: 'Start of navigation',\n          subtitle: to.fullPath,\n          data,\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay('afterEach')\n      };\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : '',\n            tooltip: 'Navigation Failure',\n            value: failure\n          }\n        };\n        data.status = formatDisplay('❌');\n      } else {\n        data.status = formatDisplay('✅');\n      }\n      // we set here to have the right order\n      data.from = formatRouteLocation(from, 'Current Location during this navigation');\n      data.to = formatRouteLocation(to, 'Target location');\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: 'End of navigation',\n          subtitle: to.fullPath,\n          time: api.now(),\n          data,\n          logType: failure ? 'warning' : 'default',\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    /**\r\n     * Inspector of Existing routes\r\n     */\n    const routerInspectorId = 'router-inspector:' + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: 'Routes' + (id ? ' ' + id : ''),\n      icon: 'book',\n      treeFilterPlaceholder: 'Search routes'\n    });\n    function refreshRoutesView() {\n      // the routes view isn't active\n      if (!activeRoutesPayload) return;\n      const payload = activeRoutesPayload;\n      // children routes will appear as nested\n      let routes = matcher.getRoutes().filter(route => !route.parent);\n      // reset match state to false\n      routes.forEach(resetMatchStateOnRouteRecord);\n      // apply a match state if there is a payload\n      if (payload.filter) {\n        routes = routes.filter(route =>\n        // save matches state based on the payload\n        isRouteMatching(route, payload.filter.toLowerCase()));\n      }\n      // mark active routes\n      routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n    let activeRoutesPayload;\n    api.on.getInspectorTree(payload => {\n      activeRoutesPayload = payload;\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        refreshRoutesView();\n      }\n    });\n    /**\r\n     * Display information about the currently selected route record\r\n     */\n    api.on.getInspectorState(payload => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const routes = matcher.getRoutes();\n        const route = routes.find(route => route.record.__vd_id === payload.nodeId);\n        if (route) {\n          payload.state = {\n            options: formatRouteRecordMatcherForStateInspector(route)\n          };\n        }\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\nfunction modifierForKey(key) {\n  if (key.optional) {\n    return key.repeatable ? '*' : '?';\n  } else {\n    return key.repeatable ? '+' : '';\n  }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const {\n    record\n  } = route;\n  const fields = [{\n    editable: false,\n    key: 'path',\n    value: record.path\n  }];\n  if (record.name != null) {\n    fields.push({\n      editable: false,\n      key: 'name',\n      value: record.name\n    });\n  }\n  fields.push({\n    editable: false,\n    key: 'regexp',\n    value: route.re\n  });\n  if (route.keys.length) {\n    fields.push({\n      editable: false,\n      key: 'keys',\n      value: {\n        _custom: {\n          type: null,\n          readOnly: true,\n          display: route.keys.map(key => `${key.name}${modifierForKey(key)}`).join(' '),\n          tooltip: 'Param keys',\n          value: route.keys\n        }\n      }\n    });\n  }\n  if (record.redirect != null) {\n    fields.push({\n      editable: false,\n      key: 'redirect',\n      value: record.redirect\n    });\n  }\n  if (route.alias.length) {\n    fields.push({\n      editable: false,\n      key: 'aliases',\n      value: route.alias.map(alias => alias.record.path)\n    });\n  }\n  if (Object.keys(route.record.meta).length) {\n    fields.push({\n      editable: false,\n      key: 'meta',\n      value: route.record.meta\n    });\n  }\n  fields.push({\n    key: 'score',\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map(score => score.join(', ')).join(' | '),\n        tooltip: 'Score used to sort routes',\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\n/**\r\n * Extracted from tailwind palette\r\n */\nconst PINK_500 = 0xec4899;\nconst BLUE_600 = 0x2563eb;\nconst LIME_500 = 0x84cc16;\nconst CYAN_400 = 0x22d3ee;\nconst ORANGE_400 = 0xfb923c;\n// const GRAY_100 = 0xf4f4f5\nconst DARK = 0x666666;\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const {\n    record\n  } = route;\n  if (record.name != null) {\n    tags.push({\n      label: String(record.name),\n      textColor: 0,\n      backgroundColor: CYAN_400\n    });\n  }\n  if (record.aliasOf) {\n    tags.push({\n      label: 'alias',\n      textColor: 0,\n      backgroundColor: ORANGE_400\n    });\n  }\n  if (route.__vd_match) {\n    tags.push({\n      label: 'matches',\n      textColor: 0,\n      backgroundColor: PINK_500\n    });\n  }\n  if (route.__vd_exactActive) {\n    tags.push({\n      label: 'exact',\n      textColor: 0,\n      backgroundColor: LIME_500\n    });\n  }\n  if (route.__vd_active) {\n    tags.push({\n      label: 'active',\n      textColor: 0,\n      backgroundColor: BLUE_600\n    });\n  }\n  if (record.redirect) {\n    tags.push({\n      label: typeof record.redirect === 'string' ? `redirect: ${record.redirect}` : 'redirects',\n      textColor: 0xffffff,\n      backgroundColor: DARK\n    });\n  }\n  // add an id to be able to select it. Using the `path` is not possible because\n  // empty path children would collide with their parents\n  let id = record.__vd_id;\n  if (id == null) {\n    id = String(routeRecordId++);\n    record.__vd_id = id;\n  }\n  return {\n    id,\n    label: record.path,\n    tags,\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n}\n//  incremental id for route records and inspector state\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n  // no route will be active if matched is empty\n  // reset the matching state\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n  if (!isExactActive) {\n    route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n  }\n  route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n  if (!found || found.length < 3) {\n    return false;\n  }\n  // use a regexp without $ at the end to match nested routes better\n  const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\n  if (nonEndingRE.test(filter)) {\n    // mark children as matches\n    route.children.forEach(child => isRouteMatching(child, filter));\n    // exception case: `/`\n    if (route.record.path !== '/' || filter === '/') {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    }\n    // hide the / route\n    return false;\n  }\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path);\n  // also allow partial matching on the path\n  if (!filter.startsWith('/') && (decodedPath.includes(filter) || path.includes(filter))) return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;\n  if (route.record.name && String(route.record.name).includes(filter)) return true;\n  return route.children.some(child => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n  const ret = {};\n  for (const key in obj) {\n    if (!keys.includes(key)) {\n      // @ts-expect-error\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  const parseQuery$1 = options.parseQuery || parseQuery;\n  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  const routerHistory = options.history;\n  if (false) {}\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_3__/* .shallowRef */ .XI)(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED;\n  // leave the scrollRestoration if no scrollBehavior is provided\n  if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\n    history.scrollRestoration = 'manual';\n  }\n  const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams =\n  // @ts-expect-error: intentionally avoid the type check\n  applyToParams.bind(null, decode);\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      record = route;\n    } else {\n      record = parentOrRoute;\n    }\n    return matcher.addRoute(record, parent);\n  }\n  function removeRoute(name) {\n    const recordMatcher = matcher.getRecordMatcher(name);\n    if (recordMatcher) {\n      matcher.removeRoute(recordMatcher);\n    } else if (false) {}\n  }\n  function getRoutes() {\n    return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n  }\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n  function resolve(rawLocation, currentLocation) {\n    // const objectLocation = routerLocationAsObject(rawLocation)\n    // we create a copy to modify it later\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n    if (typeof rawLocation === 'string') {\n      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      const matchedRoute = matcher.resolve({\n        path: locationNormalized.path\n      }, currentLocation);\n      const href = routerHistory.createHref(locationNormalized.fullPath);\n      if (false) {}\n      // locationNormalized is always a new object\n      return assign(locationNormalized, matchedRoute, {\n        params: decodeParams(matchedRoute.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: undefined,\n        href\n      });\n    }\n    let matcherLocation;\n    // path could be relative in object as well\n    if ('path' in rawLocation) {\n      if (false) {}\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      // remove any nullish param\n      const targetParams = assign({}, rawLocation.params);\n      for (const key in targetParams) {\n        if (targetParams[key] == null) {\n          delete targetParams[key];\n        }\n      }\n      // pass encoded values to the matcher, so it can produce encoded path and fullPath\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(rawLocation.params)\n      });\n      // current location params are decoded, we need to encode them in case the\n      // matcher merges the params\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || '';\n    if (false) {}\n    // the matcher might have merged current location params, so\n    // we need to run the decoding again\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    const href = routerHistory.createHref(fullPath);\n    if (false) {}\n    return assign({\n      fullPath,\n      // keep the hash encoded so fullPath is effectively path + encodedQuery +\n      // hash\n      hash,\n      query:\n      // if the user is using a custom query lib like qs, we might have\n      // nested objects, so we keep the query as is, meaning it can contain\n      // numbers at `$route.query`, but at the point, the user will have to\n      // use their own type anyway.\n      // https://github.com/vuejs/router/issues/328#issuecomment-649481567\n      stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n    }, matchedRoute, {\n      redirectedFrom: undefined,\n      href\n    });\n  }\n  function locationAsObject(to) {\n    return typeof to === 'string' ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) {\n      return createRouterError(8 /* ErrorTypes.NAVIGATION_CANCELLED */, {\n        from,\n        to\n      });\n    }\n  }\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n  function replace(to) {\n    return push(assign(locationAsObject(to), {\n      replace: true\n    }));\n  }\n  function handleRedirectRecord(to) {\n    const lastMatched = to.matched[to.matched.length - 1];\n    if (lastMatched && lastMatched.redirect) {\n      const {\n        redirect\n      } = lastMatched;\n      let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\n      if (typeof newTargetLocation === 'string') {\n        newTargetLocation = newTargetLocation.includes('?') || newTargetLocation.includes('#') ? newTargetLocation = locationAsObject(newTargetLocation) :\n        // force empty params\n        {\n          path: newTargetLocation\n        };\n        // @ts-expect-error: force empty params when a string is passed to let\n        // the router parse them again\n        newTargetLocation.params = {};\n      }\n      if (false) {}\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        // avoid transferring params if the redirect has a path\n        params: 'path' in newTargetLocation ? {} : to.params\n      }, newTargetLocation);\n    }\n  }\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force;\n    // to could be a string where `replace` is a function\n    const replace = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation);\n    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n      state: typeof shouldRedirect === 'object' ? assign({}, data, shouldRedirect.state) : data,\n      force,\n      replace\n    }),\n    // keep original redirectedFrom if it exists\n    redirectedFrom || targetLocation);\n    // if it was a redirect we already called `pushWithRedirect` above\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(16 /* ErrorTypes.NAVIGATION_DUPLICATED */, {\n        to: toLocation,\n        from\n      });\n      // trigger scroll to allow scrolling to the same anchor\n      handleScroll(from, from,\n      // this is a push, the only way for it to be triggered from a\n      // history.listen is with a redirect, which makes it become a push\n      true,\n      // This cannot be the first navigation because the initial location\n      // cannot be manually navigated to\n      false);\n    }\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(error => isNavigationFailure(error) ?\n    // navigation redirects still mark the router as ready\n    isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */) ? error : markAsReady(error) // also returns the error\n    :\n    // reject any unknown error\n    triggerError(error, toLocation, from)).then(failure => {\n      if (failure) {\n        if (isNavigationFailure(failure, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {\n          if (false) {}\n          return pushWithRedirect(\n          // keep options\n          assign({\n            // preserve an existing replacement but allow the redirect to override it\n            replace\n          }, locationAsObject(failure.to), {\n            state: typeof failure.to === 'object' ? assign({}, data, failure.to.state) : data,\n            force\n          }),\n          // preserve the original redirectedFrom if any\n          redirectedFrom || toLocation);\n        }\n      } else {\n        // if we fail we don't finalize the navigation\n        failure = finalizeNavigation(toLocation, from, true, replace, data);\n      }\n      triggerAfterEach(toLocation, from, failure);\n      return failure;\n    });\n  }\n  /**\r\n   * Helper to reject and skip all navigation guards if a new navigation happened\r\n   * @param to\r\n   * @param from\r\n   */\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  }\n  // TODO: refactor the whole before guards by internally using router.beforeEach\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n    // all components here have been resolved once because we are leaving\n    guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\n    // leavingRecords is already reversed\n    for (const record of leavingRecords) {\n      record.leaveGuards.forEach(guard => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n    }\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck);\n    // run the queue of per route beforeRouteLeave guards\n    return runGuardQueue(guards).then(() => {\n      // check global guards beforeEach\n      guards = [];\n      for (const guard of beforeGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check in components beforeRouteUpdate\n      guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\n      for (const record of updatingRecords) {\n        record.updateGuards.forEach(guard => {\n          guards.push(guardToPromiseFn(guard, to, from));\n        });\n      }\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check the route beforeEnter\n      guards = [];\n      for (const record of to.matched) {\n        // do not trigger beforeEnter on reused views\n        if (record.beforeEnter && !from.matched.includes(record)) {\n          if (isArray(record.beforeEnter)) {\n            for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));\n          } else {\n            guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n          }\n        }\n      }\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n      // clear existing enterCallbacks, these are added by extractComponentsGuards\n      to.matched.forEach(record => record.enterCallbacks = {});\n      // check in-component beforeRouteEnter\n      guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check global guards beforeResolve\n      guards = [];\n      for (const guard of beforeResolveGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    })\n    // catch any navigation canceled\n    .catch(err => isNavigationFailure(err, 8 /* ErrorTypes.NAVIGATION_CANCELLED */) ? err : Promise.reject(err));\n  }\n  function triggerAfterEach(to, from, failure) {\n    // navigation is confirmed, call afterGuards\n    // TODO: wrap with error handlers\n    for (const guard of afterGuards.list()) guard(to, from, failure);\n  }\n  /**\r\n   * - Cleans up any navigation guards\r\n   * - Changes the url if necessary\r\n   * - Calls the scrollBehavior\r\n   */\n  function finalizeNavigation(toLocation, from, isPush, replace, data) {\n    // a more recent navigation took place\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error) return error;\n    // only consider as push if it's not the first navigation\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state;\n    // change URL only if the user did a push/replace and if it's not the initial navigation because\n    // it's just reflecting the url\n    if (isPush) {\n      // on the initial navigation, we want to reuse the scroll position from\n      // history state if it exists\n      if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({\n        scroll: isFirstNavigation && state && state.scroll\n      }, data));else routerHistory.push(toLocation.fullPath, data);\n    }\n    // accept current navigation\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n  let removeHistoryListener;\n  // attach listener to history to trigger navigations\n  function setupListeners() {\n    // avoid setting up listeners twice due to an invalid first navigation\n    if (removeHistoryListener) return;\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      if (!router.listening) return;\n      // cannot be a redirect route because it was in history\n      const toLocation = resolve(to);\n      // due to dynamic routing, and to hash history with manual navigation\n      // (manually changing the url or calling history.hash = '#/somewhere'),\n      // there could be a redirect record in history\n      const shouldRedirect = handleRedirectRecord(toLocation);\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, {\n          replace: true\n        }), toLocation).catch(noop);\n        return;\n      }\n      pendingLocation = toLocation;\n      const from = currentRoute.value;\n      // TODO: should be moved to web history?\n      if (isBrowser) {\n        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      }\n      navigate(toLocation, from).catch(error => {\n        if (isNavigationFailure(error, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {\n          return error;\n        }\n        if (isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {\n          // Here we could call if (info.delta) routerHistory.go(-info.delta,\n          // false) but this is bug prone as we have no way to wait the\n          // navigation to be finished before calling pushWithRedirect. Using\n          // a setTimeout of 16ms seems to work but there is no guarantee for\n          // it to work on every browser. So instead we do not restore the\n          // history entry and trigger a new navigation as requested by the\n          // navigation guard.\n          // the error is already handled by router.push we just want to avoid\n          // logging the error\n          pushWithRedirect(error.to, toLocation\n          // avoid an uncaught rejection, let push call triggerError\n          ).then(failure => {\n            // manual change in hash history #916 ending up in the URL not\n            // changing, but it was changed by the manual url change, so we\n            // need to manually change it ourselves\n            if (isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 16 /* ErrorTypes.NAVIGATION_DUPLICATED */) && !info.delta && info.type === NavigationType.pop) {\n              routerHistory.go(-1, false);\n            }\n          }).catch(noop);\n          // avoid the then branch\n          return Promise.reject();\n        }\n        // do not restore history on unknown direction\n        if (info.delta) {\n          routerHistory.go(-info.delta, false);\n        }\n        // unrecognized error, transfer to the global handler\n        return triggerError(error, toLocation, from);\n      }).then(failure => {\n        failure = failure || finalizeNavigation(\n        // after navigation, all matched components are resolved\n        toLocation, from, false);\n        // revert the navigation\n        if (failure) {\n          if (info.delta &&\n          // a new navigation has been triggered, so we do not want to revert, that will change the current history\n          // entry while a different route is displayed\n          !isNavigationFailure(failure, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {\n            routerHistory.go(-info.delta, false);\n          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 16 /* ErrorTypes.NAVIGATION_DUPLICATED */)) {\n            // manual change in hash history #916\n            // it's like a push but lacks the information of the direction\n            routerHistory.go(-1, false);\n          }\n        }\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  }\n  // Initialization and Errors\n  let readyHandlers = useCallbacks();\n  let errorHandlers = useCallbacks();\n  let ready;\n  /**\r\n   * Trigger errorHandlers added via onError and throws the error as well\r\n   *\r\n   * @param error - error to throw\r\n   * @param to - location we were navigating to when the error happened\r\n   * @param from - location we were navigating from when the error happened\r\n   * @returns the error as a rejected promise\r\n   */\n  function triggerError(error, to, from) {\n    markAsReady(error);\n    const list = errorHandlers.list();\n    if (list.length) {\n      list.forEach(handler => handler(error, to, from));\n    } else {\n      if (false) {}\n      console.error(error);\n    }\n    return Promise.reject(error);\n  }\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n    return new Promise((resolve, reject) => {\n      readyHandlers.add([resolve, reject]);\n    });\n  }\n  function markAsReady(err) {\n    if (!ready) {\n      // still not ready if an error happened\n      ready = !err;\n      setupListeners();\n      readyHandlers.list().forEach(([resolve, reject]) => err ? reject(err) : resolve());\n      readyHandlers.reset();\n    }\n    return err;\n  }\n  // Scroll behavior\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const {\n      scrollBehavior\n    } = options;\n    if (!isBrowser || !scrollBehavior) return Promise.resolve();\n    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .nextTick */ .Y3)().then(() => scrollBehavior(to, from, scrollPosition)).then(position => position && scrollToPosition(position)).catch(err => triggerError(err, to, from));\n  }\n  const go = delta => routerHistory.go(delta);\n  let started;\n  const installedApps = new Set();\n  const router = {\n    currentRoute,\n    listening: true,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorHandlers.add,\n    isReady,\n    install(app) {\n      const router = this;\n      app.component('RouterLink', RouterLink);\n      app.component('RouterView', RouterView);\n      app.config.globalProperties.$router = router;\n      Object.defineProperty(app.config.globalProperties, '$route', {\n        enumerable: true,\n        get: () => (0,vue__WEBPACK_IMPORTED_MODULE_3__/* .unref */ .SU)(currentRoute)\n      });\n      // this initial navigation is only necessary on client, on server it doesn't\n      // make sense because it will create an extra unnecessary navigation and could\n      // lead to problems\n      if (isBrowser &&\n      // used for the initial navigation client side to avoid pushing\n      // multiple times when the router is used in multiple apps\n      !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        // see above\n        started = true;\n        push(routerHistory.location).catch(err => {\n          if (false) {}\n        });\n      }\n      const reactiveRoute = {};\n      for (const key in START_LOCATION_NORMALIZED) {\n        // @ts-expect-error: the key matches\n        reactiveRoute[key] = (0,vue__WEBPACK_IMPORTED_MODULE_2__/* .computed */ .Fl)(() => currentRoute.value[key]);\n      }\n      app.provide(routerKey, router);\n      app.provide(routeLocationKey, (0,vue__WEBPACK_IMPORTED_MODULE_3__/* .reactive */ .qj)(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      const unmountApp = app.unmount;\n      installedApps.add(app);\n      app.unmount = function () {\n        installedApps.delete(app);\n        // the router is not attached to an app anymore\n        if (installedApps.size < 1) {\n          // invalidate the current navigation\n          pendingLocation = START_LOCATION_NORMALIZED;\n          removeHistoryListener && removeHistoryListener();\n          removeHistoryListener = null;\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n        unmountApp();\n      };\n      // TODO: this probably needs to be updated so it can be used by vue-termui\n      if (false) {}\n    }\n  };\n  return router;\n}\nfunction runGuardQueue(guards) {\n  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n    if (recordFrom) {\n      if (to.matched.find(record => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);\n    }\n    const recordTo = to.matched[i];\n    if (recordTo) {\n      // the type doesn't matter because we are comparing per reference\n      if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n        enteringRecords.push(recordTo);\n      }\n    }\n  }\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\nfunction useRouter() {\n  return inject(routerKey);\n}\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\nfunction useRoute() {\n  return inject(routeLocationKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDa0MsT0FBTyxDQUFDUyxDQUFDLENBQUM7SUFDbEMsSUFBSXlrQixVQUFVLEVBQUU7TUFDWixJQUFJeGtCLEVBQUUsQ0FBQ1YsT0FBTyxDQUFDb1AsSUFBSSxDQUFDM0MsTUFBTSxJQUFJdk0saUJBQWlCLENBQUN1TSxNQUFNLEVBQUV5WSxVQUFVLENBQUMsQ0FBQyxFQUNoRTNCLGVBQWUsQ0FBQzNkLElBQUksQ0FBQ3NmLFVBQVUsQ0FBQyxDQUFDLEtBRWpDNUIsY0FBYyxDQUFDMWQsSUFBSSxDQUFDc2YsVUFBVSxDQUFDO0lBQ3ZDO0lBQ0EsTUFBTUMsUUFBUSxHQUFHemtCLEVBQUUsQ0FBQ1YsT0FBTyxDQUFDUyxDQUFDLENBQUM7SUFDOUIsSUFBSTBrQixRQUFRLEVBQUU7TUFDVjtNQUNBLElBQUksQ0FBQ3JuQixJQUFJLENBQUNrQyxPQUFPLENBQUNvUCxJQUFJLENBQUMzQyxNQUFNLElBQUl2TSxpQkFBaUIsQ0FBQ3VNLE1BQU0sRUFBRTBZLFFBQVEsQ0FBQyxDQUFDLEVBQUU7UUFDbkUzQixlQUFlLENBQUM1ZCxJQUFJLENBQUN1ZixRQUFRLENBQUM7TUFDbEM7SUFDSjtFQUNKO0VBQ0EsT0FBTyxDQUFDN0IsY0FBYyxFQUFFQyxlQUFlLEVBQUVDLGVBQWUsQ0FBQztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM0QixTQUFTQSxDQUFBLEVBQUc7RUFDakIsT0FBTzVwQixNQUFNLENBQUNzWCxTQUFTLENBQUM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVN1UyxRQUFRQSxDQUFBLEVBQUc7RUFDaEIsT0FBTzdwQixNQUFNLENBQUN1WCxnQkFBZ0IsQ0FBQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5tanM/ZjE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiB2dWUtcm91dGVyIHY0LjEuNlxuICAqIChjKSAyMDIyIEVkdWFyZG8gU2FuIE1hcnRpbiBNb3JvdGVcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbmltcG9ydCB7IGdldEN1cnJlbnRJbnN0YW5jZSwgaW5qZWN0LCBvblVubW91bnRlZCwgb25EZWFjdGl2YXRlZCwgb25BY3RpdmF0ZWQsIGNvbXB1dGVkLCB1bnJlZiwgd2F0Y2hFZmZlY3QsIGRlZmluZUNvbXBvbmVudCwgcmVhY3RpdmUsIGgsIHByb3ZpZGUsIHJlZiwgd2F0Y2gsIHNoYWxsb3dSZWYsIG5leHRUaWNrIH0gZnJvbSAndnVlJztcbmltcG9ydCB7IHNldHVwRGV2dG9vbHNQbHVnaW4gfSBmcm9tICdAdnVlL2RldnRvb2xzLWFwaSc7XG5cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpc0VTTW9kdWxlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IG9ialtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJztcclxufVxyXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xyXG5mdW5jdGlvbiBhcHBseVRvUGFyYW1zKGZuLCBwYXJhbXMpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcclxuICAgICAgICBuZXdQYXJhbXNba2V5XSA9IGlzQXJyYXkodmFsdWUpXHJcbiAgICAgICAgICAgID8gdmFsdWUubWFwKGZuKVxyXG4gICAgICAgICAgICA6IGZuKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIFR5cGVzYWZlIGFsdGVybmF0aXZlIHRvIEFycmF5LmlzQXJyYXlcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNDgyMjhcclxuICovXHJcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xyXG4gICAgLy8gYXZvaWQgdXNpbmcgLi4uYXJncyBhcyBpdCBicmVha3MgaW4gb2xkZXIgRWRnZSBidWlsZHNcclxuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSk7XHJcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgWydbVnVlIFJvdXRlciB3YXJuXTogJyArIG1zZ10uY29uY2F0KGFyZ3MpKTtcclxufVxuXG5jb25zdCBUUkFJTElOR19TTEFTSF9SRSA9IC9cXC8kLztcclxuY29uc3QgcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IChwYXRoKSA9PiBwYXRoLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfUkUsICcnKTtcclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgYSBVUkkgaW50byBhIG5vcm1hbGl6ZWQgaGlzdG9yeSBsb2NhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyc2VRdWVyeVxyXG4gKiBAcGFyYW0gbG9jYXRpb24gLSBVUkkgdG8gbm9ybWFsaXplXHJcbiAqIEBwYXJhbSBjdXJyZW50TG9jYXRpb24gLSBjdXJyZW50IGFic29sdXRlIGxvY2F0aW9uLiBBbGxvd3MgcmVzb2x2aW5nIHJlbGF0aXZlXHJcbiAqIHBhdGhzLiBNdXN0IHN0YXJ0IHdpdGggYC9gLiBEZWZhdWx0cyB0byBgL2BcclxuICogQHJldHVybnMgYSBub3JtYWxpemVkIGhpc3RvcnkgbG9jYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVVJMKHBhcnNlUXVlcnksIGxvY2F0aW9uLCBjdXJyZW50TG9jYXRpb24gPSAnLycpIHtcclxuICAgIGxldCBwYXRoLCBxdWVyeSA9IHt9LCBzZWFyY2hTdHJpbmcgPSAnJywgaGFzaCA9ICcnO1xyXG4gICAgLy8gQ291bGQgdXNlIFVSTCBhbmQgVVJMU2VhcmNoUGFyYW1zIGJ1dCBJRSAxMSBkb2Vzbid0IHN1cHBvcnQgaXRcclxuICAgIC8vIFRPRE86IG1vdmUgdG8gbmV3IFVSTCgpXHJcbiAgICBjb25zdCBoYXNoUG9zID0gbG9jYXRpb24uaW5kZXhPZignIycpO1xyXG4gICAgbGV0IHNlYXJjaFBvcyA9IGxvY2F0aW9uLmluZGV4T2YoJz8nKTtcclxuICAgIC8vIHRoZSBoYXNoIGFwcGVhcnMgYmVmb3JlIHRoZSBzZWFyY2gsIHNvIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNlYXJjaCBzdHJpbmdcclxuICAgIGlmIChoYXNoUG9zIDwgc2VhcmNoUG9zICYmIGhhc2hQb3MgPj0gMCkge1xyXG4gICAgICAgIHNlYXJjaFBvcyA9IC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlYXJjaFBvcyA+IC0xKSB7XHJcbiAgICAgICAgcGF0aCA9IGxvY2F0aW9uLnNsaWNlKDAsIHNlYXJjaFBvcyk7XHJcbiAgICAgICAgc2VhcmNoU3RyaW5nID0gbG9jYXRpb24uc2xpY2Uoc2VhcmNoUG9zICsgMSwgaGFzaFBvcyA+IC0xID8gaGFzaFBvcyA6IGxvY2F0aW9uLmxlbmd0aCk7XHJcbiAgICAgICAgcXVlcnkgPSBwYXJzZVF1ZXJ5KHNlYXJjaFN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzaFBvcyA+IC0xKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGggfHwgbG9jYXRpb24uc2xpY2UoMCwgaGFzaFBvcyk7XHJcbiAgICAgICAgLy8ga2VlcCB0aGUgIyBjaGFyYWN0ZXJcclxuICAgICAgICBoYXNoID0gbG9jYXRpb24uc2xpY2UoaGFzaFBvcywgbG9jYXRpb24ubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8vIG5vIHNlYXJjaCBhbmQgbm8gcXVlcnlcclxuICAgIHBhdGggPSByZXNvbHZlUmVsYXRpdmVQYXRoKHBhdGggIT0gbnVsbCA/IHBhdGggOiBsb2NhdGlvbiwgY3VycmVudExvY2F0aW9uKTtcclxuICAgIC8vIGVtcHR5IHBhdGggbWVhbnMgYSByZWxhdGl2ZSBxdWVyeSBvciBoYXNoIGA/Zm9vPWZgLCBgI3RoaW5nYFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmdWxsUGF0aDogcGF0aCArIChzZWFyY2hTdHJpbmcgJiYgJz8nKSArIHNlYXJjaFN0cmluZyArIGhhc2gsXHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBxdWVyeSxcclxuICAgICAgICBoYXNoLFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogU3RyaW5naWZpZXMgYSBVUkwgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBzdHJpbmdpZnlRdWVyeVxyXG4gKiBAcGFyYW0gbG9jYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVVSTChzdHJpbmdpZnlRdWVyeSwgbG9jYXRpb24pIHtcclxuICAgIGNvbnN0IHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnkgPyBzdHJpbmdpZnlRdWVyeShsb2NhdGlvbi5xdWVyeSkgOiAnJztcclxuICAgIHJldHVybiBsb2NhdGlvbi5wYXRoICsgKHF1ZXJ5ICYmICc/JykgKyBxdWVyeSArIChsb2NhdGlvbi5oYXNoIHx8ICcnKTtcclxufVxyXG4vKipcclxuICogU3RyaXBzIG9mZiB0aGUgYmFzZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYSBsb2NhdGlvbi5wYXRobmFtZSBpbiBhIG5vbi1jYXNlLXNlbnNpdGl2ZSB3YXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRobmFtZSAtIGxvY2F0aW9uLnBhdGhuYW1lXHJcbiAqIEBwYXJhbSBiYXNlIC0gYmFzZSB0byBzdHJpcCBvZmZcclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwQmFzZShwYXRobmFtZSwgYmFzZSkge1xyXG4gICAgLy8gbm8gYmFzZSBvciBiYXNlIGlzIG5vdCBmb3VuZCBhdCB0aGUgYmVnaW5uaW5nXHJcbiAgICBpZiAoIWJhc2UgfHwgIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlLnRvTG93ZXJDYXNlKCkpKVxyXG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcclxuICAgIHJldHVybiBwYXRobmFtZS5zbGljZShiYXNlLmxlbmd0aCkgfHwgJy8nO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIFJvdXRlTG9jYXRpb24gYXJlIGVxdWFsLiBUaGlzIG1lYW5zIHRoYXQgYm90aCBsb2NhdGlvbnMgYXJlXHJcbiAqIHBvaW50aW5nIHRvd2FyZHMgdGhlIHNhbWUge0BsaW5rIFJvdXRlUmVjb3JkfSBhbmQgdGhhdCBhbGwgYHBhcmFtc2AsIGBxdWVyeWBcclxuICogcGFyYW1ldGVycyBhbmQgYGhhc2hgIGFyZSB0aGUgc2FtZVxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIGZpcnN0IHtAbGluayBSb3V0ZUxvY2F0aW9ufVxyXG4gKiBAcGFyYW0gYiAtIHNlY29uZCB7QGxpbmsgUm91dGVMb2NhdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzU2FtZVJvdXRlTG9jYXRpb24oc3RyaW5naWZ5UXVlcnksIGEsIGIpIHtcclxuICAgIGNvbnN0IGFMYXN0SW5kZXggPSBhLm1hdGNoZWQubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IGJMYXN0SW5kZXggPSBiLm1hdGNoZWQubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiAoYUxhc3RJbmRleCA+IC0xICYmXHJcbiAgICAgICAgYUxhc3RJbmRleCA9PT0gYkxhc3RJbmRleCAmJlxyXG4gICAgICAgIGlzU2FtZVJvdXRlUmVjb3JkKGEubWF0Y2hlZFthTGFzdEluZGV4XSwgYi5tYXRjaGVkW2JMYXN0SW5kZXhdKSAmJlxyXG4gICAgICAgIGlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXMoYS5wYXJhbXMsIGIucGFyYW1zKSAmJlxyXG4gICAgICAgIHN0cmluZ2lmeVF1ZXJ5KGEucXVlcnkpID09PSBzdHJpbmdpZnlRdWVyeShiLnF1ZXJ5KSAmJlxyXG4gICAgICAgIGEuaGFzaCA9PT0gYi5oYXNoKTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdHdvIGBSb3V0ZVJlY29yZHNgIGFyZSBlcXVhbC4gVGFrZXMgaW50byBhY2NvdW50IGFsaWFzZXM6IHRoZXkgYXJlXHJcbiAqIGNvbnNpZGVyZWQgZXF1YWwgdG8gdGhlIGBSb3V0ZVJlY29yZGAgdGhleSBhcmUgYWxpYXNpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gZmlyc3Qge0BsaW5rIFJvdXRlUmVjb3JkfVxyXG4gKiBAcGFyYW0gYiAtIHNlY29uZCB7QGxpbmsgUm91dGVSZWNvcmR9XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZVJlY29yZChhLCBiKSB7XHJcbiAgICAvLyBzaW5jZSB0aGUgb3JpZ2luYWwgcmVjb3JkIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgZm9yIGFsaWFzT2ZcclxuICAgIC8vIGJ1dCBhbGwgYWxpYXNlcyBwb2ludCB0byB0aGUgb3JpZ2luYWwgcmVjb3JkLCB0aGlzIHdpbGwgYWx3YXlzIGNvbXBhcmVcclxuICAgIC8vIHRoZSBvcmlnaW5hbCByZWNvcmRcclxuICAgIHJldHVybiAoYS5hbGlhc09mIHx8IGEpID09PSAoYi5hbGlhc09mIHx8IGIpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXMoYSwgYikge1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKGEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgICBpZiAoIWlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXNWYWx1ZShhW2tleV0sIGJba2V5XSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXNWYWx1ZShhLCBiKSB7XHJcbiAgICByZXR1cm4gaXNBcnJheShhKVxyXG4gICAgICAgID8gaXNFcXVpdmFsZW50QXJyYXkoYSwgYilcclxuICAgICAgICA6IGlzQXJyYXkoYilcclxuICAgICAgICAgICAgPyBpc0VxdWl2YWxlbnRBcnJheShiLCBhKVxyXG4gICAgICAgICAgICA6IGEgPT09IGI7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byBhcnJheXMgYXJlIHRoZSBzYW1lIG9yIGlmIGFuIGFycmF5IHdpdGggb25lIHNpbmdsZSBlbnRyeSBpcyB0aGVcclxuICogc2FtZSBhcyBhbm90aGVyIHByaW1pdGl2ZSB2YWx1ZS4gVXNlZCB0byBjaGVjayBxdWVyeSBhbmQgcGFyYW1ldGVyc1xyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIGFycmF5IG9mIHZhbHVlc1xyXG4gKiBAcGFyYW0gYiAtIGFycmF5IG9mIHZhbHVlcyBvciBhIHNpbmdsZSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFcXVpdmFsZW50QXJyYXkoYSwgYikge1xyXG4gICAgcmV0dXJuIGlzQXJyYXkoYilcclxuICAgICAgICA/IGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh2YWx1ZSwgaSkgPT4gdmFsdWUgPT09IGJbaV0pXHJcbiAgICAgICAgOiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID09PSBiO1xyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlcyBhIHJlbGF0aXZlIHBhdGggdGhhdCBzdGFydHMgd2l0aCBgLmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB0byAtIHBhdGggbG9jYXRpb24gd2UgYXJlIHJlc29sdmluZ1xyXG4gKiBAcGFyYW0gZnJvbSAtIGN1cnJlbnRMb2NhdGlvbi5wYXRoLCBzaG91bGQgc3RhcnQgd2l0aCBgL2BcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVBhdGgodG8sIGZyb20pIHtcclxuICAgIGlmICh0by5zdGFydHNXaXRoKCcvJykpXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZnJvbS5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICB3YXJuKGBDYW5ub3QgcmVzb2x2ZSBhIHJlbGF0aXZlIGxvY2F0aW9uIHdpdGhvdXQgYW4gYWJzb2x1dGUgcGF0aC4gVHJ5aW5nIHRvIHJlc29sdmUgXCIke3RvfVwiIGZyb20gXCIke2Zyb219XCIuIEl0IHNob3VsZCBsb29rIGxpa2UgXCIvJHtmcm9tfVwiLmApO1xyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxuICAgIGlmICghdG8pXHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICBjb25zdCBmcm9tU2VnbWVudHMgPSBmcm9tLnNwbGl0KCcvJyk7XHJcbiAgICBjb25zdCB0b1NlZ21lbnRzID0gdG8uc3BsaXQoJy8nKTtcclxuICAgIGxldCBwb3NpdGlvbiA9IGZyb21TZWdtZW50cy5sZW5ndGggLSAxO1xyXG4gICAgbGV0IHRvUG9zaXRpb247XHJcbiAgICBsZXQgc2VnbWVudDtcclxuICAgIGZvciAodG9Qb3NpdGlvbiA9IDA7IHRvUG9zaXRpb24gPCB0b1NlZ21lbnRzLmxlbmd0aDsgdG9Qb3NpdGlvbisrKSB7XHJcbiAgICAgICAgc2VnbWVudCA9IHRvU2VnbWVudHNbdG9Qb3NpdGlvbl07XHJcbiAgICAgICAgLy8gd2Ugc3RheSBvbiB0aGUgc2FtZSBwb3NpdGlvblxyXG4gICAgICAgIGlmIChzZWdtZW50ID09PSAnLicpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIGdvIHVwIGluIHRoZSBmcm9tIGFycmF5XHJcbiAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcclxuICAgICAgICAgICAgLy8gd2UgY2FuJ3QgZ28gYmVsb3cgemVybywgYnV0IHdlIHN0aWxsIG5lZWQgdG8gaW5jcmVtZW50IHRvUG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMSlcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLS07XHJcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIHJlYWNoZWQgYSBub24tcmVsYXRpdmUgcGF0aCwgd2Ugc3RvcCBoZXJlXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiAoZnJvbVNlZ21lbnRzLnNsaWNlKDAsIHBvc2l0aW9uKS5qb2luKCcvJykgK1xyXG4gICAgICAgICcvJyArXHJcbiAgICAgICAgdG9TZWdtZW50c1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgd2UgdXNlIGF0IGxlYXN0IHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHRvU2VnbWVudHNcclxuICAgICAgICAgICAgLnNsaWNlKHRvUG9zaXRpb24gLSAodG9Qb3NpdGlvbiA9PT0gdG9TZWdtZW50cy5sZW5ndGggPyAxIDogMCkpXHJcbiAgICAgICAgICAgIC5qb2luKCcvJykpO1xyXG59XG5cbnZhciBOYXZpZ2F0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChOYXZpZ2F0aW9uVHlwZSkge1xyXG4gICAgTmF2aWdhdGlvblR5cGVbXCJwb3BcIl0gPSBcInBvcFwiO1xyXG4gICAgTmF2aWdhdGlvblR5cGVbXCJwdXNoXCJdID0gXCJwdXNoXCI7XHJcbn0pKE5hdmlnYXRpb25UeXBlIHx8IChOYXZpZ2F0aW9uVHlwZSA9IHt9KSk7XHJcbnZhciBOYXZpZ2F0aW9uRGlyZWN0aW9uO1xyXG4oZnVuY3Rpb24gKE5hdmlnYXRpb25EaXJlY3Rpb24pIHtcclxuICAgIE5hdmlnYXRpb25EaXJlY3Rpb25bXCJiYWNrXCJdID0gXCJiYWNrXCI7XHJcbiAgICBOYXZpZ2F0aW9uRGlyZWN0aW9uW1wiZm9yd2FyZFwiXSA9IFwiZm9yd2FyZFwiO1xyXG4gICAgTmF2aWdhdGlvbkRpcmVjdGlvbltcInVua25vd25cIl0gPSBcIlwiO1xyXG59KShOYXZpZ2F0aW9uRGlyZWN0aW9uIHx8IChOYXZpZ2F0aW9uRGlyZWN0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIFN0YXJ0aW5nIGxvY2F0aW9uIGZvciBIaXN0b3JpZXNcclxuICovXHJcbmNvbnN0IFNUQVJUID0gJyc7XHJcbi8vIEdlbmVyaWMgdXRpbHNcclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgYSBiYXNlIGJ5IHJlbW92aW5nIGFueSB0cmFpbGluZyBzbGFzaCBhbmQgcmVhZGluZyB0aGUgYmFzZSB0YWcgaWZcclxuICogcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIGJhc2UgLSBiYXNlIHRvIG5vcm1hbGl6ZVxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZShiYXNlKSB7XHJcbiAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XHJcbiAgICAgICAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xyXG4gICAgICAgICAgICAvLyBzdHJpcCBmdWxsIFVSTCBvcmlnaW5cclxuICAgICAgICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvXlxcdys6XFwvXFwvW15cXC9dKy8sICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJhc2UgPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2ggd2hlbiBpdCB3YXMgcmVtb3ZlZCBieSB0aGUgcmVnZXggYWJvdmUgYXZvaWQgbGVhZGluZ1xyXG4gICAgLy8gc2xhc2ggd2l0aCBoYXNoIGJlY2F1c2UgdGhlIGZpbGUgY291bGQgYmUgcmVhZCBmcm9tIHRoZSBkaXNrIGxpa2UgZmlsZTovL1xyXG4gICAgLy8gYW5kIHRoZSBsZWFkaW5nIHNsYXNoIHdvdWxkIGNhdXNlIHByb2JsZW1zXHJcbiAgICBpZiAoYmFzZVswXSAhPT0gJy8nICYmIGJhc2VbMF0gIT09ICcjJylcclxuICAgICAgICBiYXNlID0gJy8nICsgYmFzZTtcclxuICAgIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2ggc28gYWxsIG90aGVyIG1ldGhvZCBjYW4ganVzdCBkbyBgYmFzZSArIGZ1bGxQYXRoYFxyXG4gICAgLy8gdG8gYnVpbGQgYW4gaHJlZlxyXG4gICAgcmV0dXJuIHJlbW92ZVRyYWlsaW5nU2xhc2goYmFzZSk7XHJcbn1cclxuLy8gcmVtb3ZlIGFueSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBoYXNoXHJcbmNvbnN0IEJFRk9SRV9IQVNIX1JFID0gL15bXiNdKyMvO1xyXG5mdW5jdGlvbiBjcmVhdGVIcmVmKGJhc2UsIGxvY2F0aW9uKSB7XHJcbiAgICByZXR1cm4gYmFzZS5yZXBsYWNlKEJFRk9SRV9IQVNIX1JFLCAnIycpICsgbG9jYXRpb247XHJcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpIHtcclxuICAgIGNvbnN0IGRvY1JlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYmVoYXZpb3I6IG9mZnNldC5iZWhhdmlvcixcclxuICAgICAgICBsZWZ0OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIChvZmZzZXQubGVmdCB8fCAwKSxcclxuICAgICAgICB0b3A6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcCAtIChvZmZzZXQudG9wIHx8IDApLFxyXG4gICAgfTtcclxufVxyXG5jb25zdCBjb21wdXRlU2Nyb2xsUG9zaXRpb24gPSAoKSA9PiAoe1xyXG4gICAgbGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0LFxyXG4gICAgdG9wOiB3aW5kb3cucGFnZVlPZmZzZXQsXHJcbn0pO1xyXG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICBsZXQgc2Nyb2xsVG9PcHRpb25zO1xyXG4gICAgaWYgKCdlbCcgaW4gcG9zaXRpb24pIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkVsID0gcG9zaXRpb24uZWw7XHJcbiAgICAgICAgY29uc3QgaXNJZFNlbGVjdG9yID0gdHlwZW9mIHBvc2l0aW9uRWwgPT09ICdzdHJpbmcnICYmIHBvc2l0aW9uRWwuc3RhcnRzV2l0aCgnIycpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGBpZGBzIGNhbiBhY2NlcHQgcHJldHR5IG11Y2ggYW55IGNoYXJhY3RlcnMsIGluY2x1ZGluZyBDU1MgY29tYmluYXRvcnNcclxuICAgICAgICAgKiBsaWtlIGA+YCBvciBgfmAuIEl0J3Mgc3RpbGwgcG9zc2libGUgdG8gcmV0cmlldmUgZWxlbWVudHMgdXNpbmdcclxuICAgICAgICAgKiBgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ34nKWAgYnV0IGl0IG5lZWRzIHRvIGJlIGVzY2FwZWQgd2hlbiB1c2luZ1xyXG4gICAgICAgICAqIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjXFxcXH4nKWAgZm9yIGl0IHRvIGJlIHZhbGlkLiBUaGUgb25seVxyXG4gICAgICAgICAqIHJlcXVpcmVtZW50cyBmb3IgYGlkYHMgYXJlIHRoZW0gdG8gYmUgdW5pcXVlIG9uIHRoZSBwYWdlIGFuZCB0byBub3QgYmVcclxuICAgICAgICAgKiBlbXB0eSAoYGlkPVwiXCJgKS4gQmVjYXVzZSBvZiB0aGF0LCB3aGVuIHBhc3NpbmcgYW4gaWQgc2VsZWN0b3IsIGl0IHNob3VsZFxyXG4gICAgICAgICAqIGJlIHByb3Blcmx5IGVzY2FwZWQgZm9yIGl0IHRvIHdvcmsgd2l0aCBgcXVlcnlTZWxlY3RvcmAuIFdlIGNvdWxkIGNoZWNrXHJcbiAgICAgICAgICogZm9yIHRoZSBpZCBzZWxlY3RvciB0byBiZSBzaW1wbGUgKG5vIENTUyBjb21iaW5hdG9ycyBgKyA+fmApIGJ1dCB0aGF0XHJcbiAgICAgICAgICogd291bGQgbWFrZSB0aGluZ3MgaW5jb25zaXN0ZW50IHNpbmNlIHRoZXkgYXJlIHZhbGlkIGNoYXJhY3RlcnMgZm9yIGFuXHJcbiAgICAgICAgICogYGlkYCBidXQgd291bGQgbmVlZCB0byBiZSBlc2NhcGVkIHdoZW4gdXNpbmcgYHF1ZXJ5U2VsZWN0b3JgLCBicmVha2luZ1xyXG4gICAgICAgICAqIHRoZWlyIHVzYWdlIGFuZCBlbmRpbmcgdXAgaW4gbm8gc2VsZWN0b3IgcmV0dXJuZWQuIFNlbGVjdG9ycyBuZWVkIHRvIGJlXHJcbiAgICAgICAgICogZXNjYXBlZDpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0gYCMxLXRoaW5nYCBiZWNvbWVzIGAjXFwzMSAtdGhpbmdgXHJcbiAgICAgICAgICogLSBgI3dpdGh+c3ltYm9sc2AgYmVjb21lcyBgI3dpdGhcXFxcfnN5bWJvbHNgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAtIE1vcmUgaW5mb3JtYXRpb24gYWJvdXQgIHRoZSB0b3BpYyBjYW4gYmUgZm91bmQgYXRcclxuICAgICAgICAgKiAgIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9odG1sNS1pZC1jbGFzcy5cclxuICAgICAgICAgKiAtIFByYWN0aWNhbCBleGFtcGxlOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby9odG1sNS1pZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHlwZW9mIHBvc2l0aW9uLmVsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoIWlzSWRTZWxlY3RvciB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24uZWwuc2xpY2UoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBvc2l0aW9uLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZFNlbGVjdG9yICYmIGZvdW5kRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgVGhlIHNlbGVjdG9yIFwiJHtwb3NpdGlvbi5lbH1cIiBzaG91bGQgYmUgcGFzc2VkIGFzIFwiZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyR7cG9zaXRpb24uZWx9JylcIiBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIFwiI1wiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdG8gYXZvaWQgb3RoZXIgd2FybmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGUgc2VsZWN0b3IgXCIke3Bvc2l0aW9uLmVsfVwiIGlzIGludmFsaWQuIElmIHlvdSBhcmUgdXNpbmcgYW4gaWQgc2VsZWN0b3IsIG1ha2Ugc3VyZSB0byBlc2NhcGUgaXQuIFlvdSBjYW4gZmluZCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGVzY2FwaW5nIGNoYXJhY3RlcnMgaW4gc2VsZWN0b3JzIGF0IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyBvciB1c2UgQ1NTLmVzY2FwZSAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTUy9lc2NhcGUpLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0byBhdm9pZCBvdGhlciB3YXJuaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbCA9IHR5cGVvZiBwb3NpdGlvbkVsID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IGlzSWRTZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3NpdGlvbkVsLnNsaWNlKDEpKVxyXG4gICAgICAgICAgICAgICAgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBvc2l0aW9uRWwpXHJcbiAgICAgICAgICAgIDogcG9zaXRpb25FbDtcclxuICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ291bGRuJ3QgZmluZCBlbGVtZW50IHVzaW5nIHNlbGVjdG9yIFwiJHtwb3NpdGlvbi5lbH1cIiByZXR1cm5lZCBieSBzY3JvbGxCZWhhdmlvci5gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzY3JvbGxUb09wdGlvbnMgPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNjcm9sbFRvT3B0aW9ucyA9IHBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgaWYgKCdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKVxyXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFRvT3B0aW9ucy5sZWZ0ICE9IG51bGwgPyBzY3JvbGxUb09wdGlvbnMubGVmdCA6IHdpbmRvdy5wYWdlWE9mZnNldCwgc2Nyb2xsVG9PcHRpb25zLnRvcCAhPSBudWxsID8gc2Nyb2xsVG9PcHRpb25zLnRvcCA6IHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KHBhdGgsIGRlbHRhKSB7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGhpc3Rvcnkuc3RhdGUgPyBoaXN0b3J5LnN0YXRlLnBvc2l0aW9uIC0gZGVsdGEgOiAtMTtcclxuICAgIHJldHVybiBwb3NpdGlvbiArIHBhdGg7XHJcbn1cclxuY29uc3Qgc2Nyb2xsUG9zaXRpb25zID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24oa2V5LCBzY3JvbGxQb3NpdGlvbikge1xyXG4gICAgc2Nyb2xsUG9zaXRpb25zLnNldChrZXksIHNjcm9sbFBvc2l0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGtleSkge1xyXG4gICAgY29uc3Qgc2Nyb2xsID0gc2Nyb2xsUG9zaXRpb25zLmdldChrZXkpO1xyXG4gICAgLy8gY29uc3VtZSBpdCBzbyBpdCdzIG5vdCB1c2VkIGFnYWluXHJcbiAgICBzY3JvbGxQb3NpdGlvbnMuZGVsZXRlKGtleSk7XHJcbiAgICByZXR1cm4gc2Nyb2xsO1xyXG59XHJcbi8vIFRPRE86IFJGQyBhYm91dCBob3cgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25cclxuLyoqXHJcbiAqIFNjcm9sbEJlaGF2aW9yIGluc3RhbmNlIHVzZWQgYnkgdGhlIHJvdXRlciB0byBjb21wdXRlIGFuZCByZXN0b3JlIHRoZSBzY3JvbGxcclxuICogcG9zaXRpb24gd2hlbiBuYXZpZ2F0aW5nLlxyXG4gKi9cclxuLy8gZXhwb3J0IGludGVyZmFjZSBTY3JvbGxIYW5kbGVyPFNjcm9sbFBvc2l0aW9uRW50cnkgZXh0ZW5kcyBIaXN0b3J5U3RhdGVWYWx1ZSwgU2Nyb2xsUG9zaXRpb24gZXh0ZW5kcyBTY3JvbGxQb3NpdGlvbkVudHJ5PiB7XHJcbi8vICAgLy8gcmV0dXJucyBhIHNjcm9sbCBwb3NpdGlvbiB0aGF0IGNhbiBiZSBzYXZlZCBpbiBoaXN0b3J5XHJcbi8vICAgY29tcHV0ZSgpOiBTY3JvbGxQb3NpdGlvbkVudHJ5XHJcbi8vICAgLy8gY2FuIHRha2UgYW4gZXh0ZW5kZWQgU2Nyb2xsUG9zaXRpb25FbnRyeVxyXG4vLyAgIHNjcm9sbChwb3NpdGlvbjogU2Nyb2xsUG9zaXRpb24pOiB2b2lkXHJcbi8vIH1cclxuLy8gZXhwb3J0IGNvbnN0IHNjcm9sbEhhbmRsZXI6IFNjcm9sbEhhbmRsZXI8U2Nyb2xsUG9zaXRpb24+ID0ge1xyXG4vLyAgIGNvbXB1dGU6IGNvbXB1dGVTY3JvbGwsXHJcbi8vICAgc2Nyb2xsOiBzY3JvbGxUb1Bvc2l0aW9uLFxyXG4vLyB9XG5cbmxldCBjcmVhdGVCYXNlTG9jYXRpb24gPSAoKSA9PiBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0O1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgaGlzdG9yeSBsb2NhdGlvbiBmcm9tIGEgd2luZG93LmxvY2F0aW9uIG9iamVjdFxyXG4gKiBAcGFyYW0gbG9jYXRpb24gLVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ3VycmVudExvY2F0aW9uKGJhc2UsIGxvY2F0aW9uKSB7XHJcbiAgICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IGxvY2F0aW9uO1xyXG4gICAgLy8gYWxsb3dzIGhhc2ggYmFzZXMgbGlrZSAjLCAvIywgIy8sICMhLCAjIS8sIC8jIS8sIG9yIGV2ZW4gL2ZvbGRlciNlbmRcclxuICAgIGNvbnN0IGhhc2hQb3MgPSBiYXNlLmluZGV4T2YoJyMnKTtcclxuICAgIGlmIChoYXNoUG9zID4gLTEpIHtcclxuICAgICAgICBsZXQgc2xpY2VQb3MgPSBoYXNoLmluY2x1ZGVzKGJhc2Uuc2xpY2UoaGFzaFBvcykpXHJcbiAgICAgICAgICAgID8gYmFzZS5zbGljZShoYXNoUG9zKS5sZW5ndGhcclxuICAgICAgICAgICAgOiAxO1xyXG4gICAgICAgIGxldCBwYXRoRnJvbUhhc2ggPSBoYXNoLnNsaWNlKHNsaWNlUG9zKTtcclxuICAgICAgICAvLyBwcmVwZW5kIHRoZSBzdGFydGluZyBzbGFzaCB0byBoYXNoIHNvIHRoZSB1cmwgc3RhcnRzIHdpdGggLyNcclxuICAgICAgICBpZiAocGF0aEZyb21IYXNoWzBdICE9PSAnLycpXHJcbiAgICAgICAgICAgIHBhdGhGcm9tSGFzaCA9ICcvJyArIHBhdGhGcm9tSGFzaDtcclxuICAgICAgICByZXR1cm4gc3RyaXBCYXNlKHBhdGhGcm9tSGFzaCwgJycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGF0aCA9IHN0cmlwQmFzZShwYXRobmFtZSwgYmFzZSk7XHJcbiAgICByZXR1cm4gcGF0aCArIHNlYXJjaCArIGhhc2g7XHJcbn1cclxuZnVuY3Rpb24gdXNlSGlzdG9yeUxpc3RlbmVycyhiYXNlLCBoaXN0b3J5U3RhdGUsIGN1cnJlbnRMb2NhdGlvbiwgcmVwbGFjZSkge1xyXG4gICAgbGV0IGxpc3RlbmVycyA9IFtdO1xyXG4gICAgbGV0IHRlYXJkb3ducyA9IFtdO1xyXG4gICAgLy8gVE9ETzogc2hvdWxkIGl0IGJlIGEgc3RhY2s/IGEgRGljdC4gQ2hlY2sgaWYgdGhlIHBvcHN0YXRlIGxpc3RlbmVyXHJcbiAgICAvLyBjYW4gdHJpZ2dlciB0d2ljZVxyXG4gICAgbGV0IHBhdXNlU3RhdGUgPSBudWxsO1xyXG4gICAgY29uc3QgcG9wU3RhdGVIYW5kbGVyID0gKHsgc3RhdGUsIH0pID0+IHtcclxuICAgICAgICBjb25zdCB0byA9IGNyZWF0ZUN1cnJlbnRMb2NhdGlvbihiYXNlLCBsb2NhdGlvbik7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IGN1cnJlbnRMb2NhdGlvbi52YWx1ZTtcclxuICAgICAgICBjb25zdCBmcm9tU3RhdGUgPSBoaXN0b3J5U3RhdGUudmFsdWU7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gMDtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLnZhbHVlID0gdG87XHJcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhlIHBvcHN0YXRlIGFuZCByZXNldCB0aGUgcGF1c2VTdGF0ZVxyXG4gICAgICAgICAgICBpZiAocGF1c2VTdGF0ZSAmJiBwYXVzZVN0YXRlID09PSBmcm9tKSB7XHJcbiAgICAgICAgICAgICAgICBwYXVzZVN0YXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWx0YSA9IGZyb21TdGF0ZSA/IHN0YXRlLnBvc2l0aW9uIC0gZnJvbVN0YXRlLnBvc2l0aW9uIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2UodG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh7IGRlbHRhRnJvbUN1cnJlbnQgfSlcclxuICAgICAgICAvLyBIZXJlIHdlIGNvdWxkIGFsc28gcmV2ZXJ0IHRoZSBuYXZpZ2F0aW9uIGJ5IGNhbGxpbmcgaGlzdG9yeS5nbygtZGVsdGEpXHJcbiAgICAgICAgLy8gdGhpcyBsaXN0ZW5lciB3aWxsIGhhdmUgdG8gYmUgYWRhcHRlZCB0byBub3QgdHJpZ2dlciBhZ2FpbiBhbmQgdG8gd2FpdCBmb3IgdGhlIHVybFxyXG4gICAgICAgIC8vIHRvIGJlIHVwZGF0ZWQgYmVmb3JlIHRyaWdnZXJpbmcgdGhlIGxpc3RlbmVycy4gU29tZSBraW5kIG9mIHZhbGlkYXRpb24gZnVuY3Rpb24gd291bGQgYWxzb1xyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcGFzc2VkIHRvIHRoZSBsaXN0ZW5lcnMgc28gdGhlIG5hdmlnYXRpb24gY2FuIGJlIGFjY2VwdGVkXHJcbiAgICAgICAgLy8gY2FsbCBhbGwgbGlzdGVuZXJzXHJcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihjdXJyZW50TG9jYXRpb24udmFsdWUsIGZyb20sIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogTmF2aWdhdGlvblR5cGUucG9wLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkZWx0YVxyXG4gICAgICAgICAgICAgICAgICAgID8gZGVsdGEgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTmF2aWdhdGlvbkRpcmVjdGlvbi5mb3J3YXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTmF2aWdhdGlvbkRpcmVjdGlvbi5iYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgOiBOYXZpZ2F0aW9uRGlyZWN0aW9uLnVua25vd24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhdXNlTGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHBhdXNlU3RhdGUgPSBjdXJyZW50TG9jYXRpb24udmFsdWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsaXN0ZW4oY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBzZXQgdXAgdGhlIGxpc3RlbmVyIGFuZCBwcmVwYXJlIHRlYXJkb3duIGNhbGxiYWNrc1xyXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCB0ZWFyZG93biA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0ZWFyZG93bnMucHVzaCh0ZWFyZG93bik7XHJcbiAgICAgICAgcmV0dXJuIHRlYXJkb3duO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYmVmb3JlVW5sb2FkTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeyBoaXN0b3J5IH0gPSB3aW5kb3c7XHJcbiAgICAgICAgaWYgKCFoaXN0b3J5LnN0YXRlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoYXNzaWduKHt9LCBoaXN0b3J5LnN0YXRlLCB7IHNjcm9sbDogY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCkgfSksICcnKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZWFyZG93biBvZiB0ZWFyZG93bnMpXHJcbiAgICAgICAgICAgIHRlYXJkb3duKCk7XHJcbiAgICAgICAgdGVhcmRvd25zID0gW107XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgcG9wU3RhdGVIYW5kbGVyKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgYmVmb3JlVW5sb2FkTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0IHVwIHRoZSBsaXN0ZW5lcnMgYW5kIHByZXBhcmUgdGVhcmRvd24gY2FsbGJhY2tzXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBwb3BTdGF0ZUhhbmRsZXIpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGJlZm9yZVVubG9hZExpc3RlbmVyKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF1c2VMaXN0ZW5lcnMsXHJcbiAgICAgICAgbGlzdGVuLFxyXG4gICAgICAgIGRlc3Ryb3ksXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc3RhdGUgb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZFN0YXRlKGJhY2ssIGN1cnJlbnQsIGZvcndhcmQsIHJlcGxhY2VkID0gZmFsc2UsIGNvbXB1dGVTY3JvbGwgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBiYWNrLFxyXG4gICAgICAgIGN1cnJlbnQsXHJcbiAgICAgICAgZm9yd2FyZCxcclxuICAgICAgICByZXBsYWNlZCxcclxuICAgICAgICBwb3NpdGlvbjogd2luZG93Lmhpc3RvcnkubGVuZ3RoLFxyXG4gICAgICAgIHNjcm9sbDogY29tcHV0ZVNjcm9sbCA/IGNvbXB1dGVTY3JvbGxQb3NpdGlvbigpIDogbnVsbCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdXNlSGlzdG9yeVN0YXRlTmF2aWdhdGlvbihiYXNlKSB7XHJcbiAgICBjb25zdCB7IGhpc3RvcnksIGxvY2F0aW9uIH0gPSB3aW5kb3c7XHJcbiAgICAvLyBwcml2YXRlIHZhcmlhYmxlc1xyXG4gICAgY29uc3QgY3VycmVudExvY2F0aW9uID0ge1xyXG4gICAgICAgIHZhbHVlOiBjcmVhdGVDdXJyZW50TG9jYXRpb24oYmFzZSwgbG9jYXRpb24pLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHsgdmFsdWU6IGhpc3Rvcnkuc3RhdGUgfTtcclxuICAgIC8vIGJ1aWxkIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSBhcyB0aGlzIGlzIGEgZnJlc2ggbmF2aWdhdGlvblxyXG4gICAgaWYgKCFoaXN0b3J5U3RhdGUudmFsdWUpIHtcclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbihjdXJyZW50TG9jYXRpb24udmFsdWUsIHtcclxuICAgICAgICAgICAgYmFjazogbnVsbCxcclxuICAgICAgICAgICAgY3VycmVudDogY3VycmVudExvY2F0aW9uLnZhbHVlLFxyXG4gICAgICAgICAgICBmb3J3YXJkOiBudWxsLFxyXG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIGlzIG9mZiBieSBvbmUsIHdlIG5lZWQgdG8gZGVjcmVhc2UgaXRcclxuICAgICAgICAgICAgcG9zaXRpb246IGhpc3RvcnkubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgcmVwbGFjZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCBhIHNjcm9sbCBhcyB0aGUgdXNlciBtYXkgaGF2ZSBhbiBhbmNob3IsIGFuZCB3ZSB3YW50XHJcbiAgICAgICAgICAgIC8vIHNjcm9sbEJlaGF2aW9yIHRvIGJlIHRyaWdnZXJlZCB3aXRob3V0IGEgc2F2ZWQgcG9zaXRpb25cclxuICAgICAgICAgICAgc2Nyb2xsOiBudWxsLFxyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hhbmdlTG9jYXRpb24odG8sIHN0YXRlLCByZXBsYWNlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaWYgYSBiYXNlIHRhZyBpcyBwcm92aWRlZCwgYW5kIHdlIGFyZSBvbiBhIG5vcm1hbCBkb21haW4sIHdlIGhhdmUgdG9cclxuICAgICAgICAgKiByZXNwZWN0IHRoZSBwcm92aWRlZCBgYmFzZWAgYXR0cmlidXRlIGJlY2F1c2UgcHVzaFN0YXRlKCkgd2lsbCB1c2UgaXQgYW5kXHJcbiAgICAgICAgICogcG90ZW50aWFsbHkgZXJhc2UgYW55dGhpbmcgYmVmb3JlIHRoZSBgI2AgbGlrZSBhdFxyXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzY4NSB3aGVyZSBhIGJhc2Ugb2ZcclxuICAgICAgICAgKiBgL2ZvbGRlci8jYCBidXQgYSBiYXNlIG9mIGAvYCB3b3VsZCBlcmFzZSB0aGUgYC9mb2xkZXIvYCBzZWN0aW9uLiBJZlxyXG4gICAgICAgICAqIHRoZXJlIGlzIG5vIGhvc3QsIHRoZSBgPGJhc2U+YCB0YWcgbWFrZXMgbm8gc2Vuc2UgYW5kIGlmIHRoZXJlIGlzbid0IGFcclxuICAgICAgICAgKiBiYXNlIHRhZyB3ZSBjYW4ganVzdCB1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgYCNgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGJhc2UuaW5kZXhPZignIycpO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IGhhc2hJbmRleCA+IC0xXHJcbiAgICAgICAgICAgID8gKGxvY2F0aW9uLmhvc3QgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpXHJcbiAgICAgICAgICAgICAgICA/IGJhc2VcclxuICAgICAgICAgICAgICAgIDogYmFzZS5zbGljZShoYXNoSW5kZXgpKSArIHRvXHJcbiAgICAgICAgICAgIDogY3JlYXRlQmFzZUxvY2F0aW9uKCkgKyBiYXNlICsgdG87XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQlJPV1NFUiBRVUlSS1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBTYWZhcmkgdGhyb3dzIGEgU2VjdXJpdHlFcnJvciB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiAxMDAgdGltZXMgaW4gMzAgc2Vjb25kc1xyXG4gICAgICAgICAgICBoaXN0b3J5W3JlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXShzdGF0ZSwgJycsIHVybCk7XHJcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSA9IHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0Vycm9yIHdpdGggcHVzaC9yZXBsYWNlIFN0YXRlJywgZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgbmF2aWdhdGlvbiwgdGhpcyBhbHNvIHJlc2V0cyB0aGUgY2FsbCBjb3VudFxyXG4gICAgICAgICAgICBsb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZSh0bywgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXNzaWduKHt9LCBoaXN0b3J5LnN0YXRlLCBidWlsZFN0YXRlKGhpc3RvcnlTdGF0ZS52YWx1ZS5iYWNrLCBcclxuICAgICAgICAvLyBrZWVwIGJhY2sgYW5kIGZvcndhcmQgZW50cmllcyBidXQgb3ZlcnJpZGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgIHRvLCBoaXN0b3J5U3RhdGUudmFsdWUuZm9yd2FyZCwgdHJ1ZSksIGRhdGEsIHsgcG9zaXRpb246IGhpc3RvcnlTdGF0ZS52YWx1ZS5wb3NpdGlvbiB9KTtcclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIHRydWUpO1xyXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbi52YWx1ZSA9IHRvO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaCh0bywgZGF0YSkge1xyXG4gICAgICAgIC8vIEFkZCB0byBjdXJyZW50IGVudHJ5IHRoZSBpbmZvcm1hdGlvbiBvZiB3aGVyZSB3ZSBhcmUgZ29pbmdcclxuICAgICAgICAvLyBhcyB3ZWxsIGFzIHNhdmluZyB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFzc2lnbih7fSwgXHJcbiAgICAgICAgLy8gdXNlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZSB0byBncmFjZWZ1bGx5IGhhbmRsZSBhIHdyb25nIGNhbGwgdG9cclxuICAgICAgICAvLyBoaXN0b3J5LnJlcGxhY2VTdGF0ZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzM2NlxyXG4gICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSwgaGlzdG9yeS5zdGF0ZSwge1xyXG4gICAgICAgICAgICBmb3J3YXJkOiB0byxcclxuICAgICAgICAgICAgc2Nyb2xsOiBjb21wdXRlU2Nyb2xsUG9zaXRpb24oKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoaXN0b3J5LnN0YXRlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGhpc3Rvcnkuc3RhdGUgc2VlbXMgdG8gaGF2ZSBiZWVuIG1hbnVhbGx5IHJlcGxhY2VkIHdpdGhvdXQgcHJlc2VydmluZyB0aGUgbmVjZXNzYXJ5IHZhbHVlcy4gTWFrZSBzdXJlIHRvIHByZXNlcnZlIGV4aXN0aW5nIGhpc3Rvcnkgc3RhdGUgaWYgeW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGhpc3RvcnkucmVwbGFjZVN0YXRlOlxcblxcbmAgK1xyXG4gICAgICAgICAgICAgICAgYGhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3Rvcnkuc3RhdGUsICcnLCB1cmwpXFxuXFxuYCArXHJcbiAgICAgICAgICAgICAgICBgWW91IGNhbiBmaW5kIG1vcmUgaW5mb3JtYXRpb24gYXQgaHR0cHM6Ly9uZXh0LnJvdXRlci52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uLyN1c2FnZS1vZi1oaXN0b3J5LXN0YXRlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbihjdXJyZW50U3RhdGUuY3VycmVudCwgY3VycmVudFN0YXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IGFzc2lnbih7fSwgYnVpbGRTdGF0ZShjdXJyZW50TG9jYXRpb24udmFsdWUsIHRvLCBudWxsKSwgeyBwb3NpdGlvbjogY3VycmVudFN0YXRlLnBvc2l0aW9uICsgMSB9LCBkYXRhKTtcclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIGZhbHNlKTtcclxuICAgICAgICBjdXJyZW50TG9jYXRpb24udmFsdWUgPSB0bztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbG9jYXRpb246IGN1cnJlbnRMb2NhdGlvbixcclxuICAgICAgICBzdGF0ZTogaGlzdG9yeVN0YXRlLFxyXG4gICAgICAgIHB1c2gsXHJcbiAgICAgICAgcmVwbGFjZSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gSFRNTDUgaGlzdG9yeS4gTW9zdCBjb21tb24gaGlzdG9yeSBmb3Igc2luZ2xlIHBhZ2UgYXBwbGljYXRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFzZSAtXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJIaXN0b3J5KGJhc2UpIHtcclxuICAgIGJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xyXG4gICAgY29uc3QgaGlzdG9yeU5hdmlnYXRpb24gPSB1c2VIaXN0b3J5U3RhdGVOYXZpZ2F0aW9uKGJhc2UpO1xyXG4gICAgY29uc3QgaGlzdG9yeUxpc3RlbmVycyA9IHVzZUhpc3RvcnlMaXN0ZW5lcnMoYmFzZSwgaGlzdG9yeU5hdmlnYXRpb24uc3RhdGUsIGhpc3RvcnlOYXZpZ2F0aW9uLmxvY2F0aW9uLCBoaXN0b3J5TmF2aWdhdGlvbi5yZXBsYWNlKTtcclxuICAgIGZ1bmN0aW9uIGdvKGRlbHRhLCB0cmlnZ2VyTGlzdGVuZXJzID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICghdHJpZ2dlckxpc3RlbmVycylcclxuICAgICAgICAgICAgaGlzdG9yeUxpc3RlbmVycy5wYXVzZUxpc3RlbmVycygpO1xyXG4gICAgICAgIGhpc3RvcnkuZ28oZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgcm91dGVySGlzdG9yeSA9IGFzc2lnbih7XHJcbiAgICAgICAgLy8gaXQncyBvdmVycmlkZGVuIHJpZ2h0IGFmdGVyXHJcbiAgICAgICAgbG9jYXRpb246ICcnLFxyXG4gICAgICAgIGJhc2UsXHJcbiAgICAgICAgZ28sXHJcbiAgICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZi5iaW5kKG51bGwsIGJhc2UpLFxyXG4gICAgfSwgaGlzdG9yeU5hdmlnYXRpb24sIGhpc3RvcnlMaXN0ZW5lcnMpO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvdXRlckhpc3RvcnksICdsb2NhdGlvbicsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaGlzdG9yeU5hdmlnYXRpb24ubG9jYXRpb24udmFsdWUsXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnc3RhdGUnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGhpc3RvcnlOYXZpZ2F0aW9uLnN0YXRlLnZhbHVlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcm91dGVySGlzdG9yeTtcclxufVxuXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbi1tZW1vcnkgYmFzZWQgaGlzdG9yeS4gVGhlIG1haW4gcHVycG9zZSBvZiB0aGlzIGhpc3RvcnkgaXMgdG8gaGFuZGxlIFNTUi4gSXQgc3RhcnRzIGluIGEgc3BlY2lhbCBsb2NhdGlvbiB0aGF0IGlzIG5vd2hlcmUuXHJcbiAqIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gcmVwbGFjZSB0aGF0IGxvY2F0aW9uIHdpdGggdGhlIHN0YXJ0ZXIgbG9jYXRpb24gYnkgZWl0aGVyIGNhbGxpbmcgYHJvdXRlci5wdXNoYCBvciBgcm91dGVyLnJlcGxhY2VgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFzZSAtIEJhc2UgYXBwbGllZCB0byBhbGwgdXJscywgZGVmYXVsdHMgdG8gJy8nXHJcbiAqIEByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSByb3V0ZXIgY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoYmFzZSA9ICcnKSB7XHJcbiAgICBsZXQgbGlzdGVuZXJzID0gW107XHJcbiAgICBsZXQgcXVldWUgPSBbU1RBUlRdO1xyXG4gICAgbGV0IHBvc2l0aW9uID0gMDtcclxuICAgIGJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xyXG4gICAgZnVuY3Rpb24gc2V0TG9jYXRpb24obG9jYXRpb24pIHtcclxuICAgICAgICBwb3NpdGlvbisrO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gcXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGFyZSBhdCB0aGUgZW5kLCB3ZSBjYW4gc2ltcGx5IGFwcGVuZCBhIG5ldyBlbnRyeVxyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGFyZSBpbiB0aGUgbWlkZGxlLCB3ZSByZW1vdmUgZXZlcnl0aGluZyBmcm9tIGhlcmUgaW4gdGhlIHF1ZXVlXHJcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJMaXN0ZW5lcnModG8sIGZyb20sIHsgZGlyZWN0aW9uLCBkZWx0YSB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBkZWx0YSxcclxuICAgICAgICAgICAgdHlwZTogTmF2aWdhdGlvblR5cGUucG9wLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sodG8sIGZyb20sIGluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJvdXRlckhpc3RvcnkgPSB7XHJcbiAgICAgICAgLy8gcmV3cml0dGVuIGJ5IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxyXG4gICAgICAgIGxvY2F0aW9uOiBTVEFSVCxcclxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUga2VwdCBpbiBxdWV1ZVxyXG4gICAgICAgIHN0YXRlOiB7fSxcclxuICAgICAgICBiYXNlLFxyXG4gICAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYuYmluZChudWxsLCBiYXNlKSxcclxuICAgICAgICByZXBsYWNlKHRvKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IGVudHJ5IGFuZCBkZWNyZW1lbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKHBvc2l0aW9uLS0sIDEpO1xyXG4gICAgICAgICAgICBzZXRMb2NhdGlvbih0byk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoKHRvLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHNldExvY2F0aW9uKHRvKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpc3RlbihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIHF1ZXVlID0gW1NUQVJUXTtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ28oZGVsdGEsIHNob3VsZFRyaWdnZXIgPSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBcclxuICAgICAgICAgICAgLy8gd2UgYXJlIGNvbnNpZGVyaW5nIGRlbHRhID09PSAwIGdvaW5nIGZvcndhcmQsIGJ1dCBpbiBhYnN0cmFjdCBtb2RlXHJcbiAgICAgICAgICAgIC8vIHVzaW5nIDAgZm9yIHRoZSBkZWx0YSBkb2Vzbid0IG1ha2Ugc2Vuc2UgbGlrZSBpdCBkb2VzIGluIGh0bWw1IHdoZXJlXHJcbiAgICAgICAgICAgIC8vIGl0IHJlbG9hZHMgdGhlIHBhZ2VcclxuICAgICAgICAgICAgZGVsdGEgPCAwID8gTmF2aWdhdGlvbkRpcmVjdGlvbi5iYWNrIDogTmF2aWdhdGlvbkRpcmVjdGlvbi5mb3J3YXJkO1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBvc2l0aW9uICsgZGVsdGEsIHF1ZXVlLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJMaXN0ZW5lcnModGhpcy5sb2NhdGlvbiwgZnJvbSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm91dGVySGlzdG9yeSwgJ2xvY2F0aW9uJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiBxdWV1ZVtwb3NpdGlvbl0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByb3V0ZXJIaXN0b3J5O1xyXG59XG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgaGFzaCBoaXN0b3J5LiBVc2VmdWwgZm9yIHdlYiBhcHBsaWNhdGlvbnMgd2l0aCBubyBob3N0IChlLmcuIGBmaWxlOi8vYCkgb3Igd2hlbiBjb25maWd1cmluZyBhIHNlcnZlciB0b1xyXG4gKiBoYW5kbGUgYW55IFVSTCBpcyBub3QgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYXNlIC0gb3B0aW9uYWwgYmFzZSB0byBwcm92aWRlLiBEZWZhdWx0cyB0byBgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2hgIElmIHRoZXJlIGlzIGEgYDxiYXNlPmAgdGFnXHJcbiAqIGluIHRoZSBgaGVhZGAsIGl0cyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3Igb2YgdGhpcyBwYXJhbWV0ZXIgKipidXQgbm90ZSBpdCBhZmZlY3RzIGFsbCB0aGUgaGlzdG9yeS5wdXNoU3RhdGUoKVxyXG4gKiBjYWxscyoqLCBtZWFuaW5nIHRoYXQgaWYgeW91IHVzZSBhIGA8YmFzZT5gIHRhZywgaXQncyBgaHJlZmAgdmFsdWUgKipoYXMgdG8gbWF0Y2ggdGhpcyBwYXJhbWV0ZXIqKiAoaWdub3JpbmcgYW55dGhpbmdcclxuICogYWZ0ZXIgdGhlIGAjYCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGF0IGh0dHBzOi8vZXhhbXBsZS5jb20vZm9sZGVyXHJcbiAqIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KCkgLy8gZ2l2ZXMgYSB1cmwgb2YgYGh0dHBzOi8vZXhhbXBsZS5jb20vZm9sZGVyI2BcclxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoJy9mb2xkZXIvJykgLy8gZ2l2ZXMgYSB1cmwgb2YgYGh0dHBzOi8vZXhhbXBsZS5jb20vZm9sZGVyLyNgXHJcbiAqIC8vIGlmIHRoZSBgI2AgaXMgcHJvdmlkZWQgaW4gdGhlIGJhc2UsIGl0IHdvbid0IGJlIGFkZGVkIGJ5IGBjcmVhdGVXZWJIYXNoSGlzdG9yeWBcclxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoJy9mb2xkZXIvIy9hcHAvJykgLy8gZ2l2ZXMgYSB1cmwgb2YgYGh0dHBzOi8vZXhhbXBsZS5jb20vZm9sZGVyLyMvYXBwL2BcclxuICogLy8geW91IHNob3VsZCBhdm9pZCBkb2luZyB0aGlzIGJlY2F1c2UgaXQgY2hhbmdlcyB0aGUgb3JpZ2luYWwgdXJsIGFuZCBicmVha3MgY29weWluZyB1cmxzXHJcbiAqIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KCcvb3RoZXItZm9sZGVyLycpIC8vIGdpdmVzIGEgdXJsIG9mIGBodHRwczovL2V4YW1wbGUuY29tL290aGVyLWZvbGRlci8jYFxyXG4gKlxyXG4gKiAvLyBhdCBmaWxlOi8vL3Vzci9ldGMvZm9sZGVyL2luZGV4Lmh0bWxcclxuICogLy8gZm9yIGxvY2F0aW9ucyB3aXRoIG5vIGBob3N0YCwgdGhlIGJhc2UgaXMgaWdub3JlZFxyXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgnL2lBbUlnbm9yZWQnKSAvLyBnaXZlcyBhIHVybCBvZiBgZmlsZTovLy91c3IvZXRjL2ZvbGRlci9pbmRleC5odG1sI2BcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJIYXNoSGlzdG9yeShiYXNlKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBmaW5lIGluIHRlcm1zIG9mIGVuY29kaW5nLCBzcGVjaWFsbHkgZm9yIElFMTFcclxuICAgIC8vIGZvciBgZmlsZTovL2AsIGRpcmVjdGx5IHVzZSB0aGUgcGF0aG5hbWUgYW5kIGlnbm9yZSB0aGUgYmFzZVxyXG4gICAgLy8gbG9jYXRpb24ucGF0aG5hbWUgY29udGFpbnMgYW4gaW5pdGlhbCBgL2AgZXZlbiBhdCB0aGUgcm9vdDogYGh0dHBzOi8vZXhhbXBsZS5jb21gXHJcbiAgICBiYXNlID0gbG9jYXRpb24uaG9zdCA/IGJhc2UgfHwgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggOiAnJztcclxuICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHByb3ZpZGUgYSBgI2AgaW4gdGhlIG1pZGRsZTogYC9iYXNlLyMvYXBwYFxyXG4gICAgaWYgKCFiYXNlLmluY2x1ZGVzKCcjJykpXHJcbiAgICAgICAgYmFzZSArPSAnIyc7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFiYXNlLmVuZHNXaXRoKCcjLycpICYmICFiYXNlLmVuZHNXaXRoKCcjJykpIHtcclxuICAgICAgICB3YXJuKGBBIGhhc2ggYmFzZSBtdXN0IGVuZCB3aXRoIGEgXCIjXCI6XFxuXCIke2Jhc2V9XCIgc2hvdWxkIGJlIFwiJHtiYXNlLnJlcGxhY2UoLyMuKiQvLCAnIycpfVwiLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVdlYkhpc3RvcnkoYmFzZSk7XHJcbn1cblxuZnVuY3Rpb24gaXNSb3V0ZUxvY2F0aW9uKHJvdXRlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHJvdXRlID09PSAnc3RyaW5nJyB8fCAocm91dGUgJiYgdHlwZW9mIHJvdXRlID09PSAnb2JqZWN0Jyk7XHJcbn1cclxuZnVuY3Rpb24gaXNSb3V0ZU5hbWUobmFtZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmFtZSA9PT0gJ3N5bWJvbCc7XHJcbn1cblxuLyoqXHJcbiAqIEluaXRpYWwgcm91dGUgbG9jYXRpb24gd2hlcmUgdGhlIHJvdXRlciBpcy4gQ2FuIGJlIHVzZWQgaW4gbmF2aWdhdGlvbiBndWFyZHNcclxuICogdG8gZGlmZmVyZW50aWF0ZSB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBpbXBvcnQgeyBTVEFSVF9MT0NBVElPTiB9IGZyb20gJ3Z1ZS1yb3V0ZXInXHJcbiAqXHJcbiAqIHJvdXRlci5iZWZvcmVFYWNoKCh0bywgZnJvbSkgPT4ge1xyXG4gKiAgIGlmIChmcm9tID09PSBTVEFSVF9MT0NBVElPTikge1xyXG4gKiAgICAgLy8gaW5pdGlhbCBuYXZpZ2F0aW9uXHJcbiAqICAgfVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbmNvbnN0IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQgPSB7XHJcbiAgICBwYXRoOiAnLycsXHJcbiAgICBuYW1lOiB1bmRlZmluZWQsXHJcbiAgICBwYXJhbXM6IHt9LFxyXG4gICAgcXVlcnk6IHt9LFxyXG4gICAgaGFzaDogJycsXHJcbiAgICBmdWxsUGF0aDogJy8nLFxyXG4gICAgbWF0Y2hlZDogW10sXHJcbiAgICBtZXRhOiB7fSxcclxuICAgIHJlZGlyZWN0ZWRGcm9tOiB1bmRlZmluZWQsXHJcbn07XG5cbmNvbnN0IE5hdmlnYXRpb25GYWlsdXJlU3ltYm9sID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICduYXZpZ2F0aW9uIGZhaWx1cmUnIDogJycpO1xyXG4vKipcclxuICogRW51bWVyYXRpb24gd2l0aCBhbGwgcG9zc2libGUgdHlwZXMgZm9yIG5hdmlnYXRpb24gZmFpbHVyZXMuIENhbiBiZSBwYXNzZWQgdG9cclxuICoge0BsaW5rIGlzTmF2aWdhdGlvbkZhaWx1cmV9IHRvIGNoZWNrIGZvciBzcGVjaWZpYyBmYWlsdXJlcy5cclxuICovXHJcbnZhciBOYXZpZ2F0aW9uRmFpbHVyZVR5cGU7XHJcbihmdW5jdGlvbiAoTmF2aWdhdGlvbkZhaWx1cmVUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFib3J0ZWQgbmF2aWdhdGlvbiBpcyBhIG5hdmlnYXRpb24gdGhhdCBmYWlsZWQgYmVjYXVzZSBhIG5hdmlnYXRpb25cclxuICAgICAqIGd1YXJkIHJldHVybmVkIGBmYWxzZWAgb3IgY2FsbGVkIGBuZXh0KGZhbHNlKWBcclxuICAgICAqL1xyXG4gICAgTmF2aWdhdGlvbkZhaWx1cmVUeXBlW05hdmlnYXRpb25GYWlsdXJlVHlwZVtcImFib3J0ZWRcIl0gPSA0XSA9IFwiYWJvcnRlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhbmNlbGxlZCBuYXZpZ2F0aW9uIGlzIGEgbmF2aWdhdGlvbiB0aGF0IGZhaWxlZCBiZWNhdXNlIGEgbW9yZSByZWNlbnRcclxuICAgICAqIG5hdmlnYXRpb24gZmluaXNoZWQgc3RhcnRlZCAobm90IG5lY2Vzc2FyaWx5IGZpbmlzaGVkKS5cclxuICAgICAqL1xyXG4gICAgTmF2aWdhdGlvbkZhaWx1cmVUeXBlW05hdmlnYXRpb25GYWlsdXJlVHlwZVtcImNhbmNlbGxlZFwiXSA9IDhdID0gXCJjYW5jZWxsZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBkdXBsaWNhdGVkIG5hdmlnYXRpb24gaXMgYSBuYXZpZ2F0aW9uIHRoYXQgZmFpbGVkIGJlY2F1c2UgaXQgd2FzXHJcbiAgICAgKiBpbml0aWF0ZWQgd2hpbGUgYWxyZWFkeSBiZWluZyBhdCB0aGUgZXhhY3Qgc2FtZSBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgTmF2aWdhdGlvbkZhaWx1cmVUeXBlW05hdmlnYXRpb25GYWlsdXJlVHlwZVtcImR1cGxpY2F0ZWRcIl0gPSAxNl0gPSBcImR1cGxpY2F0ZWRcIjtcclxufSkoTmF2aWdhdGlvbkZhaWx1cmVUeXBlIHx8IChOYXZpZ2F0aW9uRmFpbHVyZVR5cGUgPSB7fSkpO1xyXG4vLyBERVYgb25seSBkZWJ1ZyBtZXNzYWdlc1xyXG5jb25zdCBFcnJvclR5cGVNZXNzYWdlcyA9IHtcclxuICAgIFsxIC8qIEVycm9yVHlwZXMuTUFUQ0hFUl9OT1RfRk9VTkQgKi9dKHsgbG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbiB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBObyBtYXRjaCBmb3JcXG4gJHtKU09OLnN0cmluZ2lmeShsb2NhdGlvbil9JHtjdXJyZW50TG9jYXRpb25cclxuICAgICAgICAgICAgPyAnXFxud2hpbGUgYmVpbmcgYXRcXG4nICsgSlNPTi5zdHJpbmdpZnkoY3VycmVudExvY2F0aW9uKVxyXG4gICAgICAgICAgICA6ICcnfWA7XHJcbiAgICB9LFxyXG4gICAgWzIgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovXSh7IGZyb20sIHRvLCB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBSZWRpcmVjdGVkIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3N0cmluZ2lmeVJvdXRlKHRvKX1cIiB2aWEgYSBuYXZpZ2F0aW9uIGd1YXJkLmA7XHJcbiAgICB9LFxyXG4gICAgWzQgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0FCT1JURUQgKi9dKHsgZnJvbSwgdG8gfSkge1xyXG4gICAgICAgIHJldHVybiBgTmF2aWdhdGlvbiBhYm9ydGVkIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3RvLmZ1bGxQYXRofVwiIHZpYSBhIG5hdmlnYXRpb24gZ3VhcmQuYDtcclxuICAgIH0sXHJcbiAgICBbOCAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fQ0FOQ0VMTEVEICovXSh7IGZyb20sIHRvIH0pIHtcclxuICAgICAgICByZXR1cm4gYE5hdmlnYXRpb24gY2FuY2VsbGVkIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3RvLmZ1bGxQYXRofVwiIHdpdGggYSBuZXcgbmF2aWdhdGlvbi5gO1xyXG4gICAgfSxcclxuICAgIFsxNiAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fRFVQTElDQVRFRCAqL10oeyBmcm9tLCB0byB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBBdm9pZGVkIHJlZHVuZGFudCBuYXZpZ2F0aW9uIHRvIGN1cnJlbnQgbG9jYXRpb246IFwiJHtmcm9tLmZ1bGxQYXRofVwiLmA7XHJcbiAgICB9LFxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJFcnJvcih0eXBlLCBwYXJhbXMpIHtcclxuICAgIC8vIGtlZXAgZnVsbCBlcnJvciBtZXNzYWdlcyBpbiBjanMgdmVyc2lvbnNcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcclxuICAgICAgICByZXR1cm4gYXNzaWduKG5ldyBFcnJvcihFcnJvclR5cGVNZXNzYWdlc1t0eXBlXShwYXJhbXMpKSwge1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBbTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2xdOiB0cnVlLFxyXG4gICAgICAgIH0sIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXNzaWduKG5ldyBFcnJvcigpLCB7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIFtOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbF06IHRydWUsXHJcbiAgICAgICAgfSwgcGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc05hdmlnYXRpb25GYWlsdXJlKGVycm9yLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcclxuICAgICAgICBOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbCBpbiBlcnJvciAmJlxyXG4gICAgICAgICh0eXBlID09IG51bGwgfHwgISEoZXJyb3IudHlwZSAmIHR5cGUpKSk7XHJcbn1cclxuY29uc3QgcHJvcGVydGllc1RvTG9nID0gWydwYXJhbXMnLCAncXVlcnknLCAnaGFzaCddO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlSb3V0ZSh0bykge1xyXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgaWYgKCdwYXRoJyBpbiB0bylcclxuICAgICAgICByZXR1cm4gdG8ucGF0aDtcclxuICAgIGNvbnN0IGxvY2F0aW9uID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wZXJ0aWVzVG9Mb2cpIHtcclxuICAgICAgICBpZiAoa2V5IGluIHRvKVxyXG4gICAgICAgICAgICBsb2NhdGlvbltrZXldID0gdG9ba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhdGlvbiwgbnVsbCwgMik7XHJcbn1cblxuLy8gZGVmYXVsdCBwYXR0ZXJuIGZvciBhIHBhcmFtOiBub24tZ3JlZWR5IGV2ZXJ5dGhpbmcgYnV0IC9cclxuY29uc3QgQkFTRV9QQVJBTV9QQVRURVJOID0gJ1teL10rPyc7XHJcbmNvbnN0IEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUyA9IHtcclxuICAgIHNlbnNpdGl2ZTogZmFsc2UsXHJcbiAgICBzdHJpY3Q6IGZhbHNlLFxyXG4gICAgc3RhcnQ6IHRydWUsXHJcbiAgICBlbmQ6IHRydWUsXHJcbn07XHJcbi8vIFNwZWNpYWwgUmVnZXggY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZCBpbiBzdGF0aWMgdG9rZW5zXHJcbmNvbnN0IFJFR0VYX0NIQVJTX1JFID0gL1suKyo/XiR7fSgpW1xcXS9cXFxcXS9nO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHBhdGggcGFyc2VyIGZyb20gYW4gYXJyYXkgb2YgU2VnbWVudHMgKGEgc2VnbWVudCBpcyBhbiBhcnJheSBvZiBUb2tlbnMpXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWdtZW50cyAtIGFycmF5IG9mIHNlZ21lbnRzIHJldHVybmVkIGJ5IHRva2VuaXplUGF0aFxyXG4gKiBAcGFyYW0gZXh0cmFPcHRpb25zIC0gb3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlZ2V4cFxyXG4gKiBAcmV0dXJucyBhIFBhdGhQYXJzZXJcclxuICovXHJcbmZ1bmN0aW9uIHRva2Vuc1RvUGFyc2VyKHNlZ21lbnRzLCBleHRyYU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NpZ24oe30sIEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUywgZXh0cmFPcHRpb25zKTtcclxuICAgIC8vIHRoZSBhbW91bnQgb2Ygc2NvcmVzIGlzIHRoZSBzYW1lIGFzIHRoZSBsZW5ndGggb2Ygc2VnbWVudHMgZXhjZXB0IGZvciB0aGUgcm9vdCBzZWdtZW50IFwiL1wiXHJcbiAgICBjb25zdCBzY29yZSA9IFtdO1xyXG4gICAgLy8gdGhlIHJlZ2V4cCBhcyBhIHN0cmluZ1xyXG4gICAgbGV0IHBhdHRlcm4gPSBvcHRpb25zLnN0YXJ0ID8gJ14nIDogJyc7XHJcbiAgICAvLyBleHRyYWN0ZWQga2V5c1xyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XHJcbiAgICAgICAgLy8gdGhlIHJvb3Qgc2VnbWVudCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRTY29yZXMgPSBzZWdtZW50Lmxlbmd0aCA/IFtdIDogWzkwIC8qIFBhdGhTY29yZS5Sb290ICovXTtcclxuICAgICAgICAvLyBhbGxvdyB0cmFpbGluZyBzbGFzaFxyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiAhc2VnbWVudC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gJy8nO1xyXG4gICAgICAgIGZvciAobGV0IHRva2VuSW5kZXggPSAwOyB0b2tlbkluZGV4IDwgc2VnbWVudC5sZW5ndGg7IHRva2VuSW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHNlZ21lbnRbdG9rZW5JbmRleF07XHJcbiAgICAgICAgICAgIC8vIHJlc2V0cyB0aGUgc2NvcmUgaWYgd2UgYXJlIGluc2lkZSBhIHN1Yi1zZWdtZW50IC86YS1vdGhlci06YlxyXG4gICAgICAgICAgICBsZXQgc3ViU2VnbWVudFNjb3JlID0gNDAgLyogUGF0aFNjb3JlLlNlZ21lbnQgKi8gK1xyXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuc2Vuc2l0aXZlID8gMC4yNSAvKiBQYXRoU2NvcmUuQm9udXNDYXNlU2Vuc2l0aXZlICovIDogMCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAwIC8qIFRva2VuVHlwZS5TdGF0aWMgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIHNsYXNoIGlmIHdlIGFyZSBzdGFydGluZyBhIG5ldyBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSAnLyc7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHRva2VuLnZhbHVlLnJlcGxhY2UoUkVHRVhfQ0hBUlNfUkUsICdcXFxcJCYnKTtcclxuICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSA0MCAvKiBQYXRoU2NvcmUuU3RhdGljICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDEgLyogVG9rZW5UeXBlLlBhcmFtICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCByZXBlYXRhYmxlLCBvcHRpb25hbCwgcmVnZXhwIH0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0YWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmUgPSByZWdleHAgPyByZWdleHAgOiBCQVNFX1BBUkFNX1BBVFRFUk47XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBwcm92aWRlZCBhIGN1c3RvbSByZWdleHAgLzppZChcXFxcZCspXHJcbiAgICAgICAgICAgICAgICBpZiAocmUgIT09IEJBU0VfUEFSQU1fUEFUVEVSTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAxMCAvKiBQYXRoU2NvcmUuQm9udXNDdXN0b21SZWdFeHAgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSByZWdleHAgaXMgdmFsaWQgYmVmb3JlIHVzaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChgKCR7cmV9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjdXN0b20gUmVnRXhwIGZvciBwYXJhbSBcIiR7dmFsdWV9XCIgKCR7cmV9KTogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXBlYXQgd2UgbXVzdCB0YWtlIGNhcmUgb2YgdGhlIHJlcGVhdGluZyBsZWFkaW5nIHNsYXNoXHJcbiAgICAgICAgICAgICAgICBsZXQgc3ViUGF0dGVybiA9IHJlcGVhdGFibGUgPyBgKCg/OiR7cmV9KSg/Oi8oPzoke3JlfSkpKilgIDogYCgke3JlfSlgO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgc2xhc2ggaWYgd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5JbmRleClcclxuICAgICAgICAgICAgICAgICAgICBzdWJQYXR0ZXJuID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgYW4gb3B0aW9uYWwgLyBpZiB0aGVyZSBhcmUgbW9yZSBzZWdtZW50cyBlLmcuIC86cD8tc3RhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIC86cD8tOnAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsICYmIHNlZ21lbnQubGVuZ3RoIDwgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKD86LyR7c3ViUGF0dGVybn0pYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnLycgKyBzdWJQYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdHRlcm4gKz0gJz8nO1xyXG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdWJQYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgc3ViU2VnbWVudFNjb3JlICs9IDIwIC8qIFBhdGhTY29yZS5EeW5hbWljICovO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAtOCAvKiBQYXRoU2NvcmUuQm9udXNPcHRpb25hbCAqLztcclxuICAgICAgICAgICAgICAgIGlmIChyZXBlYXRhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAtMjAgLyogUGF0aFNjb3JlLkJvbnVzUmVwZWF0YWJsZSAqLztcclxuICAgICAgICAgICAgICAgIGlmIChyZSA9PT0gJy4qJylcclxuICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gLTUwIC8qIFBhdGhTY29yZS5Cb251c1dpbGRjYXJkICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZ21lbnRTY29yZXMucHVzaChzdWJTZWdtZW50U2NvcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiBlbXB0eSBhcnJheSBsaWtlIC9ob21lLyAtPiBbW3tob21lfV0sIFtdXVxyXG4gICAgICAgIC8vIGlmICghc2VnbWVudC5sZW5ndGgpIHBhdHRlcm4gKz0gJy8nXHJcbiAgICAgICAgc2NvcmUucHVzaChzZWdtZW50U2NvcmVzKTtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgYXBwbHkgdGhlIHN0cmljdCBib251cyB0byB0aGUgbGFzdCBzY29yZVxyXG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0ICYmIG9wdGlvbnMuZW5kKSB7XHJcbiAgICAgICAgY29uc3QgaSA9IHNjb3JlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgc2NvcmVbaV1bc2NvcmVbaV0ubGVuZ3RoIC0gMV0gKz0gMC43MDAwMDAwMDAwMDAwMDAxIC8qIFBhdGhTY29yZS5Cb251c1N0cmljdCAqLztcclxuICAgIH1cclxuICAgIC8vIFRPRE86IGRldiBvbmx5IHdhcm4gZG91YmxlIHRyYWlsaW5nIHNsYXNoXHJcbiAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KVxyXG4gICAgICAgIHBhdHRlcm4gKz0gJy8/JztcclxuICAgIGlmIChvcHRpb25zLmVuZClcclxuICAgICAgICBwYXR0ZXJuICs9ICckJztcclxuICAgIC8vIGFsbG93IHBhdGhzIGxpa2UgL2R5bmFtaWMgdG8gb25seSBtYXRjaCBkeW5hbWljIG9yIGR5bmFtaWMvLi4uIGJ1dCBub3QgZHluYW1pY19zb21ldGhpbmdfZWxzZVxyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5zdHJpY3QpXHJcbiAgICAgICAgcGF0dGVybiArPSAnKD86L3wkKSc7XHJcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJyk7XHJcbiAgICBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXRoLm1hdGNoKHJlKTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7fTtcclxuICAgICAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaV0gfHwgJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaSAtIDFdO1xyXG4gICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsdWUgJiYga2V5LnJlcGVhdGFibGUgPyB2YWx1ZS5zcGxpdCgnLycpIDogdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkocGFyYW1zKSB7XHJcbiAgICAgICAgbGV0IHBhdGggPSAnJztcclxuICAgICAgICAvLyBmb3Igb3B0aW9uYWwgcGFyYW1ldGVycyB0byBhbGxvdyB0byBiZSBlbXB0eVxyXG4gICAgICAgIGxldCBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xyXG4gICAgICAgICAgICBpZiAoIWF2b2lkRHVwbGljYXRlZFNsYXNoIHx8ICFwYXRoLmVuZHNXaXRoKCcvJykpXHJcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcvJztcclxuICAgICAgICAgICAgYXZvaWREdXBsaWNhdGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBzZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBUb2tlblR5cGUuU3RhdGljICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDEgLyogVG9rZW5UeXBlLlBhcmFtICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgcmVwZWF0YWJsZSwgb3B0aW9uYWwgfSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdmFsdWUgaW4gcGFyYW1zID8gcGFyYW1zW3ZhbHVlXSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHBhcmFtKSAmJiAhcmVwZWF0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIHBhcmFtIFwiJHt2YWx1ZX1cIiBpcyBhbiBhcnJheSBidXQgaXQgaXMgbm90IHJlcGVhdGFibGUgKCogb3IgKyBtb2RpZmllcnMpYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpc0FycmF5KHBhcmFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtLmpvaW4oJy8nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBvcHRpb25hbCBwYXJhbSBsaWtlIC86YT8tc3RhdGljIHdlIGRvbid0IG5lZWQgdG8gY2FyZSBhYm91dCB0aGUgb3B0aW9uYWwgcGFyYW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxhc3Qgc2xhc2ggYXMgd2UgY291bGQgYmUgYXQgdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgYXBwZW5kIGEgc2xhc2ggb24gdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtIFwiJHt2YWx1ZX1cImApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXZvaWQgZW1wdHkgcGF0aCB3aGVuIHdlIGhhdmUgbXVsdGlwbGUgb3B0aW9uYWwgcGFyYW1zXHJcbiAgICAgICAgcmV0dXJuIHBhdGggfHwgJy8nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZSxcclxuICAgICAgICBzY29yZSxcclxuICAgICAgICBrZXlzLFxyXG4gICAgICAgIHBhcnNlLFxyXG4gICAgICAgIHN0cmluZ2lmeSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIGFuIGFycmF5IG9mIG51bWJlcnMgYXMgdXNlZCBpbiBQYXRoUGFyc2VyLnNjb3JlIGFuZCByZXR1cm5zIGFcclxuICogbnVtYmVyLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGBzb3J0YCBhbiBhcnJheVxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIGZpcnN0IGFycmF5IG9mIG51bWJlcnNcclxuICogQHBhcmFtIGIgLSBzZWNvbmQgYXJyYXkgb2YgbnVtYmVyc1xyXG4gKiBAcmV0dXJucyAwIGlmIGJvdGggYXJlIGVxdWFsLCA8IDAgaWYgYSBzaG91bGQgYmUgc29ydGVkIGZpcnN0LCA+IDAgaWYgYlxyXG4gKiBzaG91bGQgYmUgc29ydGVkIGZpcnN0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlU2NvcmVBcnJheShhLCBiKSB7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGRpZmYgPSBiW2ldIC0gYVtpXTtcclxuICAgICAgICAvLyBvbmx5IGtlZXAgZ29pbmcgaWYgZGlmZiA9PT0gMFxyXG4gICAgICAgIGlmIChkaWZmKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGUgbGFzdCBzdWJzZWdtZW50IHdhcyBTdGF0aWMsIHRoZSBzaG9ydGVyIHNlZ21lbnRzIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3RcclxuICAgIC8vIG90aGVyd2lzZSBzb3J0IHRoZSBsb25nZXN0IHNlZ21lbnQgZmlyc3RcclxuICAgIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPT09IDQwIC8qIFBhdGhTY29yZS5TdGF0aWMgKi8gKyA0MCAvKiBQYXRoU2NvcmUuU2VnbWVudCAqL1xyXG4gICAgICAgICAgICA/IC0xXHJcbiAgICAgICAgICAgIDogMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYi5sZW5ndGggPT09IDEgJiYgYlswXSA9PT0gNDAgLyogUGF0aFNjb3JlLlN0YXRpYyAqLyArIDQwIC8qIFBhdGhTY29yZS5TZWdtZW50ICovXHJcbiAgICAgICAgICAgID8gMVxyXG4gICAgICAgICAgICA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGBzb3J0YCB0byBzb3J0IGFuIGFycmF5IG9mIFBhdGhQYXJzZXJcclxuICpcclxuICogQHBhcmFtIGEgLSBmaXJzdCBQYXRoUGFyc2VyXHJcbiAqIEBwYXJhbSBiIC0gc2Vjb25kIFBhdGhQYXJzZXJcclxuICogQHJldHVybnMgMCBpZiBib3RoIGFyZSBlcXVhbCwgPCAwIGlmIGEgc2hvdWxkIGJlIHNvcnRlZCBmaXJzdCwgPiAwIGlmIGJcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVQYXRoUGFyc2VyU2NvcmUoYSwgYikge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgY29uc3QgYVNjb3JlID0gYS5zY29yZTtcclxuICAgIGNvbnN0IGJTY29yZSA9IGIuc2NvcmU7XHJcbiAgICB3aGlsZSAoaSA8IGFTY29yZS5sZW5ndGggJiYgaSA8IGJTY29yZS5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjb21wID0gY29tcGFyZVNjb3JlQXJyYXkoYVNjb3JlW2ldLCBiU2NvcmVbaV0pO1xyXG4gICAgICAgIC8vIGRvIG5vdCByZXR1cm4gaWYgYm90aCBhcmUgZXF1YWxcclxuICAgICAgICBpZiAoY29tcClcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgaWYgKE1hdGguYWJzKGJTY29yZS5sZW5ndGggLSBhU2NvcmUubGVuZ3RoKSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChpc0xhc3RTY29yZU5lZ2F0aXZlKGFTY29yZSkpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGlmIChpc0xhc3RTY29yZU5lZ2F0aXZlKGJTY29yZSkpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIC8vIGlmIGEgYW5kIGIgc2hhcmUgdGhlIHNhbWUgc2NvcmUgZW50cmllcyBidXQgYiBoYXMgbW9yZSwgc29ydCBiIGZpcnN0XHJcbiAgICByZXR1cm4gYlNjb3JlLmxlbmd0aCAtIGFTY29yZS5sZW5ndGg7XHJcbiAgICAvLyB0aGlzIGlzIHRoZSB0ZXJuYXJ5IHZlcnNpb25cclxuICAgIC8vIHJldHVybiBhU2NvcmUubGVuZ3RoIDwgYlNjb3JlLmxlbmd0aFxyXG4gICAgLy8gICA/IDFcclxuICAgIC8vICAgOiBhU2NvcmUubGVuZ3RoID4gYlNjb3JlLmxlbmd0aFxyXG4gICAgLy8gICA/IC0xXHJcbiAgICAvLyAgIDogMFxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGFsbG93cyBkZXRlY3Rpbmcgc3BsYXRzIGF0IHRoZSBlbmQgb2YgYSBwYXRoOiAvaG9tZS86aWQoLiopKlxyXG4gKlxyXG4gKiBAcGFyYW0gc2NvcmUgLSBzY29yZSB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBsYXN0IGVudHJ5IGlzIG5lZ2F0aXZlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xhc3RTY29yZU5lZ2F0aXZlKHNjb3JlKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gc2NvcmVbc2NvcmUubGVuZ3RoIC0gMV07XHJcbiAgICByZXR1cm4gc2NvcmUubGVuZ3RoID4gMCAmJiBsYXN0W2xhc3QubGVuZ3RoIC0gMV0gPCAwO1xyXG59XG5cbmNvbnN0IFJPT1RfVE9LRU4gPSB7XHJcbiAgICB0eXBlOiAwIC8qIFRva2VuVHlwZS5TdGF0aWMgKi8sXHJcbiAgICB2YWx1ZTogJycsXHJcbn07XHJcbmNvbnN0IFZBTElEX1BBUkFNX1JFID0gL1thLXpBLVowLTlfXS87XHJcbi8vIEFmdGVyIHNvbWUgcHJvZmlsaW5nLCB0aGUgY2FjaGUgc2VlbXMgdG8gYmUgdW5uZWNlc3NhcnkgYmVjYXVzZSB0b2tlbml6ZVBhdGhcclxuLy8gKHRoZSBzbG93ZXN0IHBhcnQgb2YgYWRkaW5nIGEgcm91dGUpIGlzIHZlcnkgZmFzdFxyXG4vLyBjb25zdCB0b2tlbkNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFRva2VuW11bXT4oKVxyXG5mdW5jdGlvbiB0b2tlbml6ZVBhdGgocGF0aCkge1xyXG4gICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHJldHVybiBbW11dO1xyXG4gICAgaWYgKHBhdGggPT09ICcvJylcclxuICAgICAgICByZXR1cm4gW1tST09UX1RPS0VOXV07XHJcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICA/IGBSb3V0ZSBwYXRocyBzaG91bGQgc3RhcnQgd2l0aCBhIFwiL1wiOiBcIiR7cGF0aH1cIiBzaG91bGQgYmUgXCIvJHtwYXRofVwiLmBcclxuICAgICAgICAgICAgOiBgSW52YWxpZCBwYXRoIFwiJHtwYXRofVwiYCk7XHJcbiAgICB9XHJcbiAgICAvLyBpZiAodG9rZW5DYWNoZS5oYXMocGF0aCkpIHJldHVybiB0b2tlbkNhY2hlLmdldChwYXRoKSFcclxuICAgIGZ1bmN0aW9uIGNyYXNoKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVSUiAoJHtzdGF0ZX0pL1wiJHtidWZmZXJ9XCI6ICR7bWVzc2FnZX1gKTtcclxuICAgIH1cclxuICAgIGxldCBzdGF0ZSA9IDAgLyogVG9rZW5pemVyU3RhdGUuU3RhdGljICovO1xyXG4gICAgbGV0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcclxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG4gICAgLy8gdGhlIHNlZ21lbnQgd2lsbCBhbHdheXMgYmUgdmFsaWQgYmVjYXVzZSB3ZSBnZXQgaW50byB0aGUgaW5pdGlhbCBzdGF0ZVxyXG4gICAgLy8gd2l0aCB0aGUgbGVhZGluZyAvXHJcbiAgICBsZXQgc2VnbWVudDtcclxuICAgIGZ1bmN0aW9uIGZpbmFsaXplU2VnbWVudCgpIHtcclxuICAgICAgICBpZiAoc2VnbWVudClcclxuICAgICAgICAgICAgdG9rZW5zLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgc2VnbWVudCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gaW5kZXggb24gdGhlIHBhdGhcclxuICAgIGxldCBpID0gMDtcclxuICAgIC8vIGNoYXIgYXQgaW5kZXhcclxuICAgIGxldCBjaGFyO1xyXG4gICAgLy8gYnVmZmVyIG9mIHRoZSB2YWx1ZSByZWFkXHJcbiAgICBsZXQgYnVmZmVyID0gJyc7XHJcbiAgICAvLyBjdXN0b20gcmVnZXhwIGZvciBhIHBhcmFtXHJcbiAgICBsZXQgY3VzdG9tUmUgPSAnJztcclxuICAgIGZ1bmN0aW9uIGNvbnN1bWVCdWZmZXIoKSB7XHJcbiAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoc3RhdGUgPT09IDAgLyogVG9rZW5pemVyU3RhdGUuU3RhdGljICovKSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIFRva2VuVHlwZS5TdGF0aWMgKi8sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEgLyogVG9rZW5pemVyU3RhdGUuUGFyYW0gKi8gfHxcclxuICAgICAgICAgICAgc3RhdGUgPT09IDIgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHAgKi8gfHxcclxuICAgICAgICAgICAgc3RhdGUgPT09IDMgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHBFbmQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSAmJiAoY2hhciA9PT0gJyonIHx8IGNoYXIgPT09ICcrJykpXHJcbiAgICAgICAgICAgICAgICBjcmFzaChgQSByZXBlYXRhYmxlIHBhcmFtICgke2J1ZmZlcn0pIG11c3QgYmUgYWxvbmUgaW4gaXRzIHNlZ21lbnQuIGVnOiAnLzppZHMrLmApO1xyXG4gICAgICAgICAgICBzZWdtZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMSAvKiBUb2tlblR5cGUuUGFyYW0gKi8sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgcmVnZXhwOiBjdXN0b21SZSxcclxuICAgICAgICAgICAgICAgIHJlcGVhdGFibGU6IGNoYXIgPT09ICcqJyB8fCBjaGFyID09PSAnKycsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogY2hhciA9PT0gJyonIHx8IGNoYXIgPT09ICc/JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjcmFzaCgnSW52YWxpZCBzdGF0ZSB0byBjb25zdW1lIGJ1ZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIgPSAnJztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZENoYXJUb0J1ZmZlcigpIHtcclxuICAgICAgICBidWZmZXIgKz0gY2hhcjtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICBjaGFyID0gcGF0aFtpKytdO1xyXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcgJiYgc3RhdGUgIT09IDIgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHAgKi8pIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBzdGF0ZSA9IDQgLyogVG9rZW5pemVyU3RhdGUuRXNjYXBlTmV4dCAqLztcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFRva2VuaXplclN0YXRlLlN0YXRpYyAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVTZWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdW1lQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFRva2VuaXplclN0YXRlLlBhcmFtICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhclRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0IC8qIFRva2VuaXplclN0YXRlLkVzY2FwZU5leHQgKi86XHJcbiAgICAgICAgICAgICAgICBhZGRDaGFyVG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogVG9rZW5pemVyU3RhdGUuUGFyYW0gKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyIC8qIFRva2VuaXplclN0YXRlLlBhcmFtUmVnRXhwICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoVkFMSURfUEFSQU1fUkUudGVzdChjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYXJUb0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMCAvKiBUb2tlbml6ZXJTdGF0ZS5TdGF0aWMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyIGlmIHdlIHdlcmUgbm90IG1vZGlmeWluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSAnKicgJiYgY2hhciAhPT0gJz8nICYmIGNoYXIgIT09ICcrJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUb2tlbml6ZXJTdGF0ZS5QYXJhbVJlZ0V4cCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzIGl0IHdvcnRoIGhhbmRsaW5nIG5lc3RlZCByZWdleHA/IGxpa2UgOnAoPzpwcmVmaXhfKFteL10rKV9zdWZmaXgpXHJcbiAgICAgICAgICAgICAgICAvLyBpdCBhbHJlYWR5IHdvcmtzIGJ5IGVzY2FwaW5nIHRoZSBjbG9zaW5nIClcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcGF0aHMuZXNtLmRldi8/cD1BQU1lSmJpQXdRRWNES2JBb0FBa1A2MFBHMlI2UUF2Z05hQTZBRkFDTTJBQnVRQkIjXHJcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHJlYWxseSBzb21ldGhpbmcgcGVvcGxlIG5lZWQgc2luY2UgeW91IGNhbiBhbHNvIHdyaXRlXHJcbiAgICAgICAgICAgICAgICAvLyAvcHJlZml4XzpwKClfc3VmZml4XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBlc2NhcGVkIClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tUmVbY3VzdG9tUmUubGVuZ3RoIC0gMV0gPT0gJ1xcXFwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSA9IGN1c3RvbVJlLnNsaWNlKDAsIC0xKSArIGNoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHBFbmQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSArPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUb2tlbml6ZXJTdGF0ZS5QYXJhbVJlZ0V4cEVuZCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgZmluYWxpemluZyBhIHBhcmFtXHJcbiAgICAgICAgICAgICAgICBjb25zdW1lQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogVG9rZW5pemVyU3RhdGUuU3RhdGljICovO1xyXG4gICAgICAgICAgICAgICAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyIGlmIHdlIHdlcmUgbm90IG1vZGlmeWluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09ICcqJyAmJiBjaGFyICE9PSAnPycgJiYgY2hhciAhPT0gJysnKVxyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbVJlID0gJyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNyYXNoKCdVbmtub3duIHN0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdGUgPT09IDIgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHAgKi8pXHJcbiAgICAgICAgY3Jhc2goYFVuZmluaXNoZWQgY3VzdG9tIFJlZ0V4cCBmb3IgcGFyYW0gXCIke2J1ZmZlcn1cImApO1xyXG4gICAgY29uc3VtZUJ1ZmZlcigpO1xyXG4gICAgZmluYWxpemVTZWdtZW50KCk7XHJcbiAgICAvLyB0b2tlbkNhY2hlLnNldChwYXRoLCB0b2tlbnMpXHJcbiAgICByZXR1cm4gdG9rZW5zO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlUmVjb3JkTWF0Y2hlcihyZWNvcmQsIHBhcmVudCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcGFyc2VyID0gdG9rZW5zVG9QYXJzZXIodG9rZW5pemVQYXRoKHJlY29yZC5wYXRoKSwgb3B0aW9ucyk7XHJcbiAgICAvLyB3YXJuIGFnYWluc3QgcGFyYW1zIHdpdGggdGhlIHNhbWUgbmFtZVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJzZXIua2V5cykge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdLZXlzLmhhcyhrZXkubmFtZSkpXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBGb3VuZCBkdXBsaWNhdGVkIHBhcmFtcyB3aXRoIG5hbWUgXCIke2tleS5uYW1lfVwiIGZvciBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIi4gT25seSB0aGUgbGFzdCBvbmUgd2lsbCBiZSBhdmFpbGFibGUgb24gXCIkcm91dGUucGFyYW1zXCIuYCk7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nS2V5cy5hZGQoa2V5Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG1hdGNoZXIgPSBhc3NpZ24ocGFyc2VyLCB7XHJcbiAgICAgICAgcmVjb3JkLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICAvLyB0aGVzZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYnkgdGhlIHBhcmVudFxyXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICBhbGlhczogW10sXHJcbiAgICB9KTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAvLyBib3RoIGFyZSBhbGlhc2VzIG9yIGJvdGggYXJlIG5vdCBhbGlhc2VzXHJcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtaXggdGhlbSBiZWNhdXNlIHRoZSBvcmRlciBpcyB1c2VkIHdoZW5cclxuICAgICAgICAvLyBwYXNzaW5nIG9yaWdpbmFsUmVjb3JkIGluIE1hdGNoZXIuYWRkUm91dGVcclxuICAgICAgICBpZiAoIW1hdGNoZXIucmVjb3JkLmFsaWFzT2YgPT09ICFwYXJlbnQucmVjb3JkLmFsaWFzT2YpXHJcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG1hdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZXI7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBSb3V0ZXIgTWF0Y2hlci5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSByb3V0ZXMgLSBhcnJheSBvZiBpbml0aWFsIHJvdXRlc1xyXG4gKiBAcGFyYW0gZ2xvYmFsT3B0aW9ucyAtIGdsb2JhbCByb3V0ZSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJNYXRjaGVyKHJvdXRlcywgZ2xvYmFsT3B0aW9ucykge1xyXG4gICAgLy8gbm9ybWFsaXplZCBvcmRlcmVkIGFycmF5IG9mIG1hdGNoZXJzXHJcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xyXG4gICAgY29uc3QgbWF0Y2hlck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGdsb2JhbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoeyBzdHJpY3Q6IGZhbHNlLCBlbmQ6IHRydWUsIHNlbnNpdGl2ZTogZmFsc2UgfSwgZ2xvYmFsT3B0aW9ucyk7XHJcbiAgICBmdW5jdGlvbiBnZXRSZWNvcmRNYXRjaGVyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlck1hcC5nZXQobmFtZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRSb3V0ZShyZWNvcmQsIHBhcmVudCwgb3JpZ2luYWxSZWNvcmQpIHtcclxuICAgICAgICAvLyB1c2VkIGxhdGVyIG9uIHRvIHJlbW92ZSBieSBuYW1lXHJcbiAgICAgICAgY29uc3QgaXNSb290QWRkID0gIW9yaWdpbmFsUmVjb3JkO1xyXG4gICAgICAgIGNvbnN0IG1haW5Ob3JtYWxpemVkUmVjb3JkID0gbm9ybWFsaXplUm91dGVSZWNvcmQocmVjb3JkKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNoZWNrQ2hpbGRNaXNzaW5nTmFtZVdpdGhFbXB0eVBhdGgobWFpbk5vcm1hbGl6ZWRSZWNvcmQsIHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIG1pZ2h0IGJlIHRoZSBjaGlsZCBvZiBhbiBhbGlhc1xyXG4gICAgICAgIG1haW5Ob3JtYWxpemVkUmVjb3JkLmFsaWFzT2YgPSBvcmlnaW5hbFJlY29yZCAmJiBvcmlnaW5hbFJlY29yZC5yZWNvcmQ7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhnbG9iYWxPcHRpb25zLCByZWNvcmQpO1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIGFuIGFycmF5IG9mIHJlY29yZHMgdG8gY29ycmVjdGx5IGhhbmRsZSBhbGlhc2VzXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlY29yZHMgPSBbXHJcbiAgICAgICAgICAgIG1haW5Ob3JtYWxpemVkUmVjb3JkLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKCdhbGlhcycgaW4gcmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSB0eXBlb2YgcmVjb3JkLmFsaWFzID09PSAnc3RyaW5nJyA/IFtyZWNvcmQuYWxpYXNdIDogcmVjb3JkLmFsaWFzO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRSZWNvcmRzLnB1c2goYXNzaWduKHt9LCBtYWluTm9ybWFsaXplZFJlY29yZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIHVzIHRvIGhvbGQgYSBjb3B5IG9mIHRoZSBgY29tcG9uZW50c2Agb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCBhc3luYyBjb21wb25lbnRzIGNhY2hlIGlzIGhvbGQgb24gdGhlIG9yaWdpbmFsIHJlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9yaWdpbmFsUmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxSZWNvcmQucmVjb3JkLmNvbXBvbmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYWluTm9ybWFsaXplZFJlY29yZC5jb21wb25lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGFsaWFzLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGJlIHRoZSBjaGlsZCBvZiBhbiBhbGlhc1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzT2Y6IG9yaWdpbmFsUmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxSZWNvcmQucmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWFpbk5vcm1hbGl6ZWRSZWNvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFsaWFzZXMgYXJlIGFsd2F5cyBvZiB0aGUgc2FtZSBraW5kIGFzIHRoZSBvcmlnaW5hbCBzaW5jZSB0aGV5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgcmVjb3JkXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1hdGNoZXI7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsTWF0Y2hlcjtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRSZWNvcmQgb2Ygbm9ybWFsaXplZFJlY29yZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBub3JtYWxpemVkUmVjb3JkO1xyXG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcGF0aCBmb3IgbmVzdGVkIHJvdXRlcyBpZiB0aGUgY2hpbGQgaXNuJ3QgYW4gYWJzb2x1dGVcclxuICAgICAgICAgICAgLy8gcm91dGUuIE9ubHkgYWRkIHRoZSAvIGRlbGltaXRlciBpZiB0aGUgY2hpbGQgcGF0aCBpc24ndCBlbXB0eSBhbmQgaWYgdGhlXHJcbiAgICAgICAgICAgIC8vIHBhcmVudCBwYXRoIGRvZXNuJ3QgaGF2ZSBhIHRyYWlsaW5nIHNsYXNoXHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGF0aFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGFyZW50LnJlY29yZC5wYXRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ1NsYXNoID0gcGFyZW50UGF0aFtwYXJlbnRQYXRoLmxlbmd0aCAtIDFdID09PSAnLycgPyAnJyA6ICcvJztcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRSZWNvcmQucGF0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlY29yZC5wYXRoICsgKHBhdGggJiYgY29ubmVjdGluZ1NsYXNoICsgcGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBub3JtYWxpemVkUmVjb3JkLnBhdGggPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXRjaCBhbGwgcm91dGVzIChcIipcIikgbXVzdCBub3cgYmUgZGVmaW5lZCB1c2luZyBhIHBhcmFtIHdpdGggYSBjdXN0b20gcmVnZXhwLlxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICdTZWUgbW9yZSBhdCBodHRwczovL25leHQucm91dGVyLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vI3JlbW92ZWQtc3Rhci1vci1jYXRjaC1hbGwtcm91dGVzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgb2JqZWN0IGJlZm9yZWhhbmQsIHNvIGl0IGNhbiBiZSBwYXNzZWQgdG8gY2hpbGRyZW5cclxuICAgICAgICAgICAgbWF0Y2hlciA9IGNyZWF0ZVJvdXRlUmVjb3JkTWF0Y2hlcihub3JtYWxpemVkUmVjb3JkLCBwYXJlbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudCAmJiBwYXRoWzBdID09PSAnLycpXHJcbiAgICAgICAgICAgICAgICBjaGVja01pc3NpbmdQYXJhbXNJbkFic29sdXRlUGF0aChtYXRjaGVyLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgYW4gYWxpYXMgd2UgbXVzdCB0ZWxsIHRoZSBvcmlnaW5hbCByZWNvcmQgdGhhdCB3ZSBleGlzdCxcclxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFJlY29yZC5hbGlhcy5wdXNoKG1hdGNoZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2FtZVBhcmFtcyhvcmlnaW5hbFJlY29yZCwgbWF0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBmaXJzdCByZWNvcmQgaXMgdGhlIG9yaWdpbmFsIGFuZCBvdGhlcnMgYXJlIGFsaWFzZXNcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF0Y2hlciA9IG9yaWdpbmFsTWF0Y2hlciB8fCBtYXRjaGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTWF0Y2hlciAhPT0gbWF0Y2hlcilcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE1hdGNoZXIuYWxpYXMucHVzaChtYXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcm91dGUgaWYgbmFtZWQgYW5kIG9ubHkgZm9yIHRoZSB0b3AgcmVjb3JkIChhdm9pZCBpbiBuZXN0ZWQgY2FsbHMpXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdvcmtzIGJlY2F1c2UgdGhlIG9yaWdpbmFsIHJlY29yZCBpcyB0aGUgZmlyc3Qgb25lXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSb290QWRkICYmIHJlY29yZC5uYW1lICYmICFpc0FsaWFzUmVjb3JkKG1hdGNoZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJvdXRlKHJlY29yZC5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFpbk5vcm1hbGl6ZWRSZWNvcmQuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbWFpbk5vcm1hbGl6ZWRSZWNvcmQuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUm91dGUoY2hpbGRyZW5baV0sIG1hdGNoZXIsIG9yaWdpbmFsUmVjb3JkICYmIG9yaWdpbmFsUmVjb3JkLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gb3JpZ2luYWwgcmVjb3JkLCB0aGVuIHRoZSBmaXJzdCBvbmUgd2FzIG5vdCBhbiBhbGlhcyBhbmQgYWxsXHJcbiAgICAgICAgICAgIC8vIG90aGVyIGFsaWFzZXMgKGlmIGFueSkgbmVlZCB0byByZWZlcmVuY2UgdGhpcyByZWNvcmQgd2hlbiBhZGRpbmcgY2hpbGRyZW5cclxuICAgICAgICAgICAgb3JpZ2luYWxSZWNvcmQgPSBvcmlnaW5hbFJlY29yZCB8fCBtYXRjaGVyO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgbm9ybWFsaXplZCByZWNvcmRzIGZvciBtb3JlIGZsZXhpYmlsaXR5XHJcbiAgICAgICAgICAgIC8vIGlmIChwYXJlbnQgJiYgaXNBbGlhc1JlY29yZChvcmlnaW5hbFJlY29yZCkpIHtcclxuICAgICAgICAgICAgLy8gICBwYXJlbnQuY2hpbGRyZW4ucHVzaChvcmlnaW5hbFJlY29yZClcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAvLyBBdm9pZCBhZGRpbmcgYSByZWNvcmQgdGhhdCBkb2Vzbid0IGRpc3BsYXkgYW55dGhpbmcuIFRoaXMgYWxsb3dzIHBhc3NpbmcgdGhyb3VnaCByZWNvcmRzIHdpdGhvdXQgYSBjb21wb25lbnQgdG9cclxuICAgICAgICAgICAgLy8gbm90IGJlIHJlYWNoZWQgYW5kIHBhc3MgdGhyb3VnaCB0aGUgY2F0Y2ggYWxsIHJvdXRlXHJcbiAgICAgICAgICAgIGlmICgobWF0Y2hlci5yZWNvcmQuY29tcG9uZW50cyAmJlxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWF0Y2hlci5yZWNvcmQuY29tcG9uZW50cykubGVuZ3RoKSB8fFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlci5yZWNvcmQubmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlci5yZWNvcmQucmVkaXJlY3QpIHtcclxuICAgICAgICAgICAgICAgIGluc2VydE1hdGNoZXIobWF0Y2hlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWF0Y2hlclxyXG4gICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIG90aGVyIG1hdGNoZXJzIGFyZSBhbGlhc2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGJ5IHRoZSBvcmlnaW5hbCBtYXRjaGVyXHJcbiAgICAgICAgICAgICAgICByZW1vdmVSb3V0ZShvcmlnaW5hbE1hdGNoZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogbm9vcDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZVJvdXRlKG1hdGNoZXJSZWYpIHtcclxuICAgICAgICBpZiAoaXNSb3V0ZU5hbWUobWF0Y2hlclJlZikpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IG1hdGNoZXJNYXAuZ2V0KG1hdGNoZXJSZWYpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlck1hcC5kZWxldGUobWF0Y2hlclJlZik7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVycy5zcGxpY2UobWF0Y2hlcnMuaW5kZXhPZihtYXRjaGVyKSwgMSk7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmNoaWxkcmVuLmZvckVhY2gocmVtb3ZlUm91dGUpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlci5hbGlhcy5mb3JFYWNoKHJlbW92ZVJvdXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBtYXRjaGVycy5pbmRleE9mKG1hdGNoZXJSZWYpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyUmVmLnJlY29yZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJNYXAuZGVsZXRlKG1hdGNoZXJSZWYucmVjb3JkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlclJlZi5jaGlsZHJlbi5mb3JFYWNoKHJlbW92ZVJvdXRlKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXJSZWYuYWxpYXMuZm9yRWFjaChyZW1vdmVSb3V0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRSb3V0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0TWF0Y2hlcihtYXRjaGVyKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgbWF0Y2hlcnMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIGNvbXBhcmVQYXRoUGFyc2VyU2NvcmUobWF0Y2hlciwgbWF0Y2hlcnNbaV0pID49IDAgJiZcclxuICAgICAgICAgICAgLy8gQWRkaW5nIGNoaWxkcmVuIHdpdGggZW1wdHkgcGF0aCBzaG91bGQgc3RpbGwgYXBwZWFyIGJlZm9yZSB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzExMjRcclxuICAgICAgICAgICAgKG1hdGNoZXIucmVjb3JkLnBhdGggIT09IG1hdGNoZXJzW2ldLnJlY29yZC5wYXRoIHx8XHJcbiAgICAgICAgICAgICAgICAhaXNSZWNvcmRDaGlsZE9mKG1hdGNoZXIsIG1hdGNoZXJzW2ldKSkpXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICBtYXRjaGVycy5zcGxpY2UoaSwgMCwgbWF0Y2hlcik7XHJcbiAgICAgICAgLy8gb25seSBhZGQgdGhlIG9yaWdpbmFsIHJlY29yZCB0byB0aGUgbmFtZSBtYXBcclxuICAgICAgICBpZiAobWF0Y2hlci5yZWNvcmQubmFtZSAmJiAhaXNBbGlhc1JlY29yZChtYXRjaGVyKSlcclxuICAgICAgICAgICAgbWF0Y2hlck1hcC5zZXQobWF0Y2hlci5yZWNvcmQubmFtZSwgbWF0Y2hlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKGxvY2F0aW9uLCBjdXJyZW50TG9jYXRpb24pIHtcclxuICAgICAgICBsZXQgbWF0Y2hlcjtcclxuICAgICAgICBsZXQgcGFyYW1zID0ge307XHJcbiAgICAgICAgbGV0IHBhdGg7XHJcbiAgICAgICAgbGV0IG5hbWU7XHJcbiAgICAgICAgaWYgKCduYW1lJyBpbiBsb2NhdGlvbiAmJiBsb2NhdGlvbi5uYW1lKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZXIgPSBtYXRjaGVyTWFwLmdldChsb2NhdGlvbi5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaGVyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUm91dGVyRXJyb3IoMSAvKiBFcnJvclR5cGVzLk1BVENIRVJfTk9UX0ZPVU5EICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gd2FybiBpZiB0aGUgdXNlciBpcyBwYXNzaW5nIGludmFsaWQgcGFyYW1zIHNvIHRoZXkgY2FuIGRlYnVnIGl0IGJldHRlciB3aGVuIHRoZXkgZ2V0IHJlbW92ZWRcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFBhcmFtcyA9IE9iamVjdC5rZXlzKGxvY2F0aW9uLnBhcmFtcyB8fCB7fSkuZmlsdGVyKHBhcmFtTmFtZSA9PiAhbWF0Y2hlci5rZXlzLmZpbmQoayA9PiBrLm5hbWUgPT09IHBhcmFtTmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRQYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlzY2FyZGVkIGludmFsaWQgcGFyYW0ocykgXCIke2ludmFsaWRQYXJhbXMuam9pbignXCIsIFwiJyl9XCIgd2hlbiBuYXZpZ2F0aW5nLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvdXRlci9ibG9iL21haW4vcGFja2FnZXMvcm91dGVyL0NIQU5HRUxPRy5tZCM0MTQtMjAyMi0wOC0yMiBmb3IgbW9yZSBkZXRhaWxzLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaGVyLnJlY29yZC5uYW1lO1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBhc3NpZ24oXHJcbiAgICAgICAgICAgIC8vIHBhcmFtc0Zyb21Mb2NhdGlvbiBpcyBhIG5ldyBvYmplY3RcclxuICAgICAgICAgICAgcGFyYW1zRnJvbUxvY2F0aW9uKGN1cnJlbnRMb2NhdGlvbi5wYXJhbXMsIFxyXG4gICAgICAgICAgICAvLyBvbmx5IGtlZXAgcGFyYW1zIHRoYXQgZXhpc3QgaW4gdGhlIHJlc29sdmVkIGxvY2F0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE86IG9ubHkga2VlcCBvcHRpb25hbCBwYXJhbXMgY29taW5nIGZyb20gYSBwYXJlbnQgcmVjb3JkXHJcbiAgICAgICAgICAgIG1hdGNoZXIua2V5cy5maWx0ZXIoayA9PiAhay5vcHRpb25hbCkubWFwKGsgPT4gay5uYW1lKSksIFxyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGFueSBleGlzdGluZyBwYXJhbXMgaW4gdGhlIGN1cnJlbnQgbG9jYXRpb24gdGhhdCBkbyBub3QgZXhpc3QgaGVyZVxyXG4gICAgICAgICAgICAvLyAjMTQ5NyB0aGlzIGVuc3VyZXMgYmV0dGVyIGFjdGl2ZS9leGFjdCBtYXRjaGluZ1xyXG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXMgJiZcclxuICAgICAgICAgICAgICAgIHBhcmFtc0Zyb21Mb2NhdGlvbihsb2NhdGlvbi5wYXJhbXMsIG1hdGNoZXIua2V5cy5tYXAoayA9PiBrLm5hbWUpKSk7XHJcbiAgICAgICAgICAgIC8vIHRocm93cyBpZiBjYW5ub3QgYmUgc3RyaW5naWZpZWRcclxuICAgICAgICAgICAgcGF0aCA9IG1hdGNoZXIuc3RyaW5naWZ5KHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdwYXRoJyBpbiBsb2NhdGlvbikge1xyXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHJlc29sdmUgdGhlIHBhdGggd2l0aCB0aGUgbWF0Y2hlciBhcyBpdCB3YXMgcHJvdmlkZWRcclxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGFsbG93cyB0aGUgdXNlciB0byBjb250cm9sIHRoZSBlbmNvZGluZ1xyXG4gICAgICAgICAgICBwYXRoID0gbG9jYXRpb24ucGF0aDtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBNYXRjaGVyIGNhbm5vdCByZXNvbHZlIHJlbGF0aXZlIHBhdGhzIGJ1dCByZWNlaXZlZCBcIiR7cGF0aH1cIi4gVW5sZXNzIHlvdSBkaXJlY3RseSBjYWxsZWQgXFxgbWF0Y2hlci5yZXNvbHZlKFwiJHtwYXRofVwiKVxcYCwgdGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiB2dWUtcm91dGVyLiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvcm91dGVyLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hdGNoZXIgPSBtYXRjaGVycy5maW5kKG0gPT4gbS5yZS50ZXN0KHBhdGgpKTtcclxuICAgICAgICAgICAgLy8gbWF0Y2hlciBzaG91bGQgaGF2ZSBhIHZhbHVlIGFmdGVyIHRoZSBsb29wXHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoZSBtYXRjaGVyIHdvcmtzIGJlY2F1c2Ugd2UgdGVzdGVkIHRoZSByZWdleHBcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG1hdGNoZXIucGFyc2UocGF0aCk7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hlci5yZWNvcmQubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBsb2NhdGlvbiBpcyBhIHJlbGF0aXZlIHBhdGhcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1hdGNoIGJ5IG5hbWUgb3IgcGF0aCBvZiBjdXJyZW50IHJvdXRlXHJcbiAgICAgICAgICAgIG1hdGNoZXIgPSBjdXJyZW50TG9jYXRpb24ubmFtZVxyXG4gICAgICAgICAgICAgICAgPyBtYXRjaGVyTWFwLmdldChjdXJyZW50TG9jYXRpb24ubmFtZSlcclxuICAgICAgICAgICAgICAgIDogbWF0Y2hlcnMuZmluZChtID0+IG0ucmUudGVzdChjdXJyZW50TG9jYXRpb24ucGF0aCkpO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVSb3V0ZXJFcnJvcigxIC8qIEVycm9yVHlwZXMuTUFUQ0hFUl9OT1RfRk9VTkQgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIHRoZSBzYW1lIGxvY2F0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHBpY2sgdGhlXHJcbiAgICAgICAgICAgIC8vIHBhcmFtcyBsaWtlIHdoZW4gYG5hbWVgIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGFzc2lnbih7fSwgY3VycmVudExvY2F0aW9uLnBhcmFtcywgbG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICAgICAgcGF0aCA9IG1hdGNoZXIuc3RyaW5naWZ5KHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcclxuICAgICAgICBsZXQgcGFyZW50TWF0Y2hlciA9IG1hdGNoZXI7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudE1hdGNoZXIpIHtcclxuICAgICAgICAgICAgLy8gcmV2ZXJzZWQgb3JkZXIgc28gcGFyZW50cyBhcmUgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICBtYXRjaGVkLnVuc2hpZnQocGFyZW50TWF0Y2hlci5yZWNvcmQpO1xyXG4gICAgICAgICAgICBwYXJlbnRNYXRjaGVyID0gcGFyZW50TWF0Y2hlci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgbWF0Y2hlZCxcclxuICAgICAgICAgICAgbWV0YTogbWVyZ2VNZXRhRmllbGRzKG1hdGNoZWQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgaW5pdGlhbCByb3V0ZXNcclxuICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IGFkZFJvdXRlKHJvdXRlKSk7XHJcbiAgICByZXR1cm4geyBhZGRSb3V0ZSwgcmVzb2x2ZSwgcmVtb3ZlUm91dGUsIGdldFJvdXRlcywgZ2V0UmVjb3JkTWF0Y2hlciB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcmFtc0Zyb21Mb2NhdGlvbihwYXJhbXMsIGtleXMpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIGlmIChrZXkgaW4gcGFyYW1zKVxyXG4gICAgICAgICAgICBuZXdQYXJhbXNba2V5XSA9IHBhcmFtc1trZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG4vKipcclxuICogTm9ybWFsaXplcyBhIFJvdXRlUmVjb3JkUmF3LiBDcmVhdGVzIGEgY29weVxyXG4gKlxyXG4gKiBAcGFyYW0gcmVjb3JkXHJcbiAqIEByZXR1cm5zIHRoZSBub3JtYWxpemVkIHZlcnNpb25cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlUmVjb3JkKHJlY29yZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXRoOiByZWNvcmQucGF0aCxcclxuICAgICAgICByZWRpcmVjdDogcmVjb3JkLnJlZGlyZWN0LFxyXG4gICAgICAgIG5hbWU6IHJlY29yZC5uYW1lLFxyXG4gICAgICAgIG1ldGE6IHJlY29yZC5tZXRhIHx8IHt9LFxyXG4gICAgICAgIGFsaWFzT2Y6IHVuZGVmaW5lZCxcclxuICAgICAgICBiZWZvcmVFbnRlcjogcmVjb3JkLmJlZm9yZUVudGVyLFxyXG4gICAgICAgIHByb3BzOiBub3JtYWxpemVSZWNvcmRQcm9wcyhyZWNvcmQpLFxyXG4gICAgICAgIGNoaWxkcmVuOiByZWNvcmQuY2hpbGRyZW4gfHwgW10sXHJcbiAgICAgICAgaW5zdGFuY2VzOiB7fSxcclxuICAgICAgICBsZWF2ZUd1YXJkczogbmV3IFNldCgpLFxyXG4gICAgICAgIHVwZGF0ZUd1YXJkczogbmV3IFNldCgpLFxyXG4gICAgICAgIGVudGVyQ2FsbGJhY2tzOiB7fSxcclxuICAgICAgICBjb21wb25lbnRzOiAnY29tcG9uZW50cycgaW4gcmVjb3JkXHJcbiAgICAgICAgICAgID8gcmVjb3JkLmNvbXBvbmVudHMgfHwgbnVsbFxyXG4gICAgICAgICAgICA6IHJlY29yZC5jb21wb25lbnQgJiYgeyBkZWZhdWx0OiByZWNvcmQuY29tcG9uZW50IH0sXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgdGhlIG9wdGlvbmFsIGBwcm9wc2AgaW4gYSByZWNvcmQgdG8gYWx3YXlzIGJlIGFuIG9iamVjdCBzaW1pbGFyIHRvXHJcbiAqIGNvbXBvbmVudHMuIEFsc28gYWNjZXB0IGEgYm9vbGVhbiBmb3IgY29tcG9uZW50cy5cclxuICogQHBhcmFtIHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplUmVjb3JkUHJvcHMocmVjb3JkKSB7XHJcbiAgICBjb25zdCBwcm9wc09iamVjdCA9IHt9O1xyXG4gICAgLy8gcHJvcHMgZG9lcyBub3QgZXhpc3Qgb24gcmVkaXJlY3QgcmVjb3JkcywgYnV0IHdlIGNhbiBzZXQgZmFsc2UgZGlyZWN0bHlcclxuICAgIGNvbnN0IHByb3BzID0gcmVjb3JkLnByb3BzIHx8IGZhbHNlO1xyXG4gICAgaWYgKCdjb21wb25lbnQnIGluIHJlY29yZCkge1xyXG4gICAgICAgIHByb3BzT2JqZWN0LmRlZmF1bHQgPSBwcm9wcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE5PVEU6IHdlIGNvdWxkIGFsc28gYWxsb3cgYSBmdW5jdGlvbiB0byBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGNvbXBvbmVudC5cclxuICAgICAgICAvLyBXb3VsZCBuZWVkIHVzZXIgZmVlZGJhY2sgZm9yIHVzZSBjYXNlc1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWNvcmQuY29tcG9uZW50cylcclxuICAgICAgICAgICAgcHJvcHNPYmplY3RbbmFtZV0gPSB0eXBlb2YgcHJvcHMgPT09ICdib29sZWFuJyA/IHByb3BzIDogcHJvcHNbbmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHNPYmplY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHJlY29yZCBvciBhbnkgb2YgaXRzIHBhcmVudCBpcyBhbiBhbGlhc1xyXG4gKiBAcGFyYW0gcmVjb3JkXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FsaWFzUmVjb3JkKHJlY29yZCkge1xyXG4gICAgd2hpbGUgKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQucmVjb3JkLmFsaWFzT2YpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIE1lcmdlIG1ldGEgZmllbGRzIG9mIGFuIGFycmF5IG9mIHJlY29yZHNcclxuICpcclxuICogQHBhcmFtIG1hdGNoZWQgLSBhcnJheSBvZiBtYXRjaGVkIHJlY29yZHNcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlTWV0YUZpZWxkcyhtYXRjaGVkKSB7XHJcbiAgICByZXR1cm4gbWF0Y2hlZC5yZWR1Y2UoKG1ldGEsIHJlY29yZCkgPT4gYXNzaWduKG1ldGEsIHJlY29yZC5tZXRhKSwge30pO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhkZWZhdWx0cywgcGFydGlhbE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgb3B0aW9uc1trZXldID0ga2V5IGluIHBhcnRpYWxPcHRpb25zID8gcGFydGlhbE9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVQYXJhbShhLCBiKSB7XHJcbiAgICByZXR1cm4gKGEubmFtZSA9PT0gYi5uYW1lICYmXHJcbiAgICAgICAgYS5vcHRpb25hbCA9PT0gYi5vcHRpb25hbCAmJlxyXG4gICAgICAgIGEucmVwZWF0YWJsZSA9PT0gYi5yZXBlYXRhYmxlKTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBwYXRoIGFuZCBpdHMgYWxpYXMgaGF2ZSB0aGUgc2FtZSByZXF1aXJlZCBwYXJhbXNcclxuICpcclxuICogQHBhcmFtIGEgLSBvcmlnaW5hbCByZWNvcmRcclxuICogQHBhcmFtIGIgLSBhbGlhcyByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrU2FtZVBhcmFtcyhhLCBiKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMpIHtcclxuICAgICAgICBpZiAoIWtleS5vcHRpb25hbCAmJiAhYi5rZXlzLmZpbmQoaXNTYW1lUGFyYW0uYmluZChudWxsLCBrZXkpKSlcclxuICAgICAgICAgICAgcmV0dXJuIHdhcm4oYEFsaWFzIFwiJHtiLnJlY29yZC5wYXRofVwiIGFuZCB0aGUgb3JpZ2luYWwgcmVjb3JkOiBcIiR7YS5yZWNvcmQucGF0aH1cIiBtdXN0IGhhdmUgdGhlIGV4YWN0IHNhbWUgcGFyYW0gbmFtZWQgXCIke2tleS5uYW1lfVwiYCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiLmtleXMpIHtcclxuICAgICAgICBpZiAoIWtleS5vcHRpb25hbCAmJiAhYS5rZXlzLmZpbmQoaXNTYW1lUGFyYW0uYmluZChudWxsLCBrZXkpKSlcclxuICAgICAgICAgICAgcmV0dXJuIHdhcm4oYEFsaWFzIFwiJHtiLnJlY29yZC5wYXRofVwiIGFuZCB0aGUgb3JpZ2luYWwgcmVjb3JkOiBcIiR7YS5yZWNvcmQucGF0aH1cIiBtdXN0IGhhdmUgdGhlIGV4YWN0IHNhbWUgcGFyYW0gbmFtZWQgXCIke2tleS5uYW1lfVwiYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgcm91dGUgd2l0aCBhIG5hbWUgYW5kIGEgY2hpbGQgd2l0aCBhbiBlbXB0eSBwYXRoIHdpdGhvdXQgYSBuYW1lIHNob3VsZCB3YXJuIHdoZW4gYWRkaW5nIHRoZSByb3V0ZVxyXG4gKlxyXG4gKiBAcGFyYW0gbWFpbk5vcm1hbGl6ZWRSZWNvcmQgLSBSb3V0ZVJlY29yZE5vcm1hbGl6ZWRcclxuICogQHBhcmFtIHBhcmVudCAtIFJvdXRlUmVjb3JkTWF0Y2hlclxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tDaGlsZE1pc3NpbmdOYW1lV2l0aEVtcHR5UGF0aChtYWluTm9ybWFsaXplZFJlY29yZCwgcGFyZW50KSB7XHJcbiAgICBpZiAocGFyZW50ICYmXHJcbiAgICAgICAgcGFyZW50LnJlY29yZC5uYW1lICYmXHJcbiAgICAgICAgIW1haW5Ob3JtYWxpemVkUmVjb3JkLm5hbWUgJiZcclxuICAgICAgICAhbWFpbk5vcm1hbGl6ZWRSZWNvcmQucGF0aCkge1xyXG4gICAgICAgIHdhcm4oYFRoZSByb3V0ZSBuYW1lZCBcIiR7U3RyaW5nKHBhcmVudC5yZWNvcmQubmFtZSl9XCIgaGFzIGEgY2hpbGQgd2l0aG91dCBhIG5hbWUgYW5kIGFuIGVtcHR5IHBhdGguIFVzaW5nIHRoYXQgbmFtZSB3b24ndCByZW5kZXIgdGhlIGVtcHR5IHBhdGggY2hpbGQgc28geW91IHByb2JhYmx5IHdhbnQgdG8gbW92ZSB0aGUgbmFtZSB0byB0aGUgY2hpbGQgaW5zdGVhZC4gSWYgdGhpcyBpcyBpbnRlbnRpb25hbCwgYWRkIGEgbmFtZSB0byB0aGUgY2hpbGQgcm91dGUgdG8gcmVtb3ZlIHRoZSB3YXJuaW5nLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrTWlzc2luZ1BhcmFtc0luQWJzb2x1dGVQYXRoKHJlY29yZCwgcGFyZW50KSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJlbnQua2V5cykge1xyXG4gICAgICAgIGlmICghcmVjb3JkLmtleXMuZmluZChpc1NhbWVQYXJhbS5iaW5kKG51bGwsIGtleSkpKVxyXG4gICAgICAgICAgICByZXR1cm4gd2FybihgQWJzb2x1dGUgcGF0aCBcIiR7cmVjb3JkLnJlY29yZC5wYXRofVwiIG11c3QgaGF2ZSB0aGUgZXhhY3Qgc2FtZSBwYXJhbSBuYW1lZCBcIiR7a2V5Lm5hbWV9XCIgYXMgaXRzIHBhcmVudCBcIiR7cGFyZW50LnJlY29yZC5wYXRofVwiLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUmVjb3JkQ2hpbGRPZihyZWNvcmQsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGNoaWxkID09PSByZWNvcmQgfHwgaXNSZWNvcmRDaGlsZE9mKHJlY29yZCwgY2hpbGQpKTtcclxufVxuXG4vKipcclxuICogRW5jb2RpbmcgUnVsZXMg4pCjID0gU3BhY2UgUGF0aDog4pCjIFwiIDwgPiAjID8geyB9IFF1ZXJ5OiDikKMgXCIgPCA+ICMgJiA9IEhhc2g6IOKQoyBcIlxyXG4gKiA8ID4gYFxyXG4gKlxyXG4gKiBPbiB0b3Agb2YgdGhhdCwgdGhlIFJGQzM5ODYgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4yKVxyXG4gKiBkZWZpbmVzIHNvbWUgZXh0cmEgY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkLiBNb3N0IGJyb3dzZXJzIGRvIG5vdCBlbmNvZGUgdGhlbVxyXG4gKiBpbiBlbmNvZGVVUkkgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy91cmwvaXNzdWVzLzM2OSwgc28gaXQgbWF5IGJlIHNhZmVyIHRvXHJcbiAqIGFsc28gZW5jb2RlIGAhJygpKmAuIExlYXZpbmcgdW4tZW5jb2RlZCBvbmx5IEFTQ0lJIGFscGhhbnVtZXJpYyhgYS16QS1aMC05YClcclxuICogcGx1cyBgLS5ffmAuIFRoaXMgZXh0cmEgc2FmZXR5IHNob3VsZCBiZSBhcHBsaWVkIHRvIHF1ZXJ5IGJ5IHBhdGNoaW5nIHRoZVxyXG4gKiBzdHJpbmcgcmV0dXJuZWQgYnkgZW5jb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBhbHNvIGVuY29kZXMgYFtcXF1eYC4gYFxcYFxyXG4gKiBzaG91bGQgYmUgZW5jb2RlZCB0byBhdm9pZCBhbWJpZ3VpdHkuIEJyb3dzZXJzIChJRSwgRkYsIEMpIHRyYW5zZm9ybSBhIGBcXGBcclxuICogaW50byBhIGAvYCBpZiBkaXJlY3RseSB0eXBlZCBpbi4gVGhlIF9iYWNrdGlja18gKGBgYGBgKSBzaG91bGQgYWxzbyBiZVxyXG4gKiBlbmNvZGVkIGV2ZXJ5d2hlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGxpa2UgRkYgZW5jb2RlIGl0IHdoZW4gZGlyZWN0bHlcclxuICogd3JpdHRlbiB3aGlsZSBvdGhlcnMgZG9uJ3QuIFNhZmFyaSBhbmQgSUUgZG9uJ3QgZW5jb2RlIGBgXCI8Pnt9YGBgIGluIGhhc2guXHJcbiAqL1xyXG4vLyBjb25zdCBFWFRSQV9SRVNFUlZFRF9SRSA9IC9bIScoKSpdL2dcclxuLy8gY29uc3QgZW5jb2RlUmVzZXJ2ZWRSZXBsYWNlciA9IChjOiBzdHJpbmcpID0+ICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNilcclxuY29uc3QgSEFTSF9SRSA9IC8jL2c7IC8vICUyM1xyXG5jb25zdCBBTVBFUlNBTkRfUkUgPSAvJi9nOyAvLyAlMjZcclxuY29uc3QgU0xBU0hfUkUgPSAvXFwvL2c7IC8vICUyRlxyXG5jb25zdCBFUVVBTF9SRSA9IC89L2c7IC8vICUzRFxyXG5jb25zdCBJTV9SRSA9IC9cXD8vZzsgLy8gJTNGXHJcbmNvbnN0IFBMVVNfUkUgPSAvXFwrL2c7IC8vICUyQlxyXG4vKipcclxuICogTk9URTogSXQncyBub3QgY2xlYXIgdG8gbWUgaWYgd2Ugc2hvdWxkIGVuY29kZSB0aGUgKyBzeW1ib2wgaW4gcXVlcmllcywgaXRcclxuICogc2VlbXMgdG8gYmUgbGVzcyBmbGV4aWJsZSB0aGFuIG5vdCBkb2luZyBzbyBhbmQgSSBjYW4ndCBmaW5kIG91dCB0aGUgbGVnYWN5XHJcbiAqIHN5c3RlbXMgcmVxdWlyaW5nIHRoaXMgZm9yIHJlZ3VsYXIgcmVxdWVzdHMgbGlrZSB0ZXh0L2h0bWwuIEluIHRoZSBzdGFuZGFyZCxcclxuICogdGhlIGVuY29kaW5nIG9mIHRoZSBwbHVzIGNoYXJhY3RlciBpcyBvbmx5IG1lbnRpb25lZCBmb3JcclxuICogYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXHJcbiAqIChodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybGVuY29kZWQtcGFyc2luZykgYW5kIG1vc3QgYnJvd3NlcnMgc2VlbXMgbG9cclxuICogbGVhdmUgdGhlIHBsdXMgY2hhcmFjdGVyIGFzIGlzIGluIHF1ZXJpZXMuIFRvIGJlIG1vcmUgZmxleGlibGUsIHdlIGFsbG93IHRoZVxyXG4gKiBwbHVzIGNoYXJhY3RlciBvbiB0aGUgcXVlcnksIGJ1dCBpdCBjYW4gYWxzbyBiZSBtYW51YWxseSBlbmNvZGVkIGJ5IHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBSZXNvdXJjZXM6XHJcbiAqIC0gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxlbmNvZGVkLXBhcnNpbmdcclxuICogLSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjM0MjcxL3VybC1lbmNvZGluZy10aGUtc3BhY2UtY2hhcmFjdGVyLW9yLTIwXHJcbiAqL1xyXG5jb25zdCBFTkNfQlJBQ0tFVF9PUEVOX1JFID0gLyU1Qi9nOyAvLyBbXHJcbmNvbnN0IEVOQ19CUkFDS0VUX0NMT1NFX1JFID0gLyU1RC9nOyAvLyBdXHJcbmNvbnN0IEVOQ19DQVJFVF9SRSA9IC8lNUUvZzsgLy8gXlxyXG5jb25zdCBFTkNfQkFDS1RJQ0tfUkUgPSAvJTYwL2c7IC8vIGBcclxuY29uc3QgRU5DX0NVUkxZX09QRU5fUkUgPSAvJTdCL2c7IC8vIHtcclxuY29uc3QgRU5DX1BJUEVfUkUgPSAvJTdDL2c7IC8vIHxcclxuY29uc3QgRU5DX0NVUkxZX0NMT1NFX1JFID0gLyU3RC9nOyAvLyB9XHJcbmNvbnN0IEVOQ19TUEFDRV9SRSA9IC8lMjAvZzsgLy8gfVxyXG4vKipcclxuICogRW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQgb24gdGhlIHBhdGgsIHNlYXJjaCBhbmQgaGFzaFxyXG4gKiBzZWN0aW9ucyBvZiB0aGUgVVJMLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21tb25FbmNvZGUodGV4dCkge1xyXG4gICAgcmV0dXJuIGVuY29kZVVSSSgnJyArIHRleHQpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX1BJUEVfUkUsICd8JylcclxuICAgICAgICAucmVwbGFjZShFTkNfQlJBQ0tFVF9PUEVOX1JFLCAnWycpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0JSQUNLRVRfQ0xPU0VfUkUsICddJyk7XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBoYXNoIHNlY3Rpb24gb2YgdGhlIFVSTC5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVIYXNoKHRleHQpIHtcclxuICAgIHJldHVybiBjb21tb25FbmNvZGUodGV4dClcclxuICAgICAgICAucmVwbGFjZShFTkNfQ1VSTFlfT1BFTl9SRSwgJ3snKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DVVJMWV9DTE9TRV9SRSwgJ30nKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DQVJFVF9SRSwgJ14nKTtcclxufVxyXG4vKipcclxuICogRW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQgcXVlcnkgdmFsdWVzIG9uIHRoZSBxdWVyeVxyXG4gKiBzZWN0aW9uIG9mIHRoZSBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxyXG4gKiBAcmV0dXJucyBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlUXVlcnlWYWx1ZSh0ZXh0KSB7XHJcbiAgICByZXR1cm4gKGNvbW1vbkVuY29kZSh0ZXh0KVxyXG4gICAgICAgIC8vIEVuY29kZSB0aGUgc3BhY2UgYXMgKywgZW5jb2RlIHRoZSArIHRvIGRpZmZlcmVudGlhdGUgaXQgZnJvbSB0aGUgc3BhY2VcclxuICAgICAgICAucmVwbGFjZShQTFVTX1JFLCAnJTJCJylcclxuICAgICAgICAucmVwbGFjZShFTkNfU1BBQ0VfUkUsICcrJylcclxuICAgICAgICAucmVwbGFjZShIQVNIX1JFLCAnJTIzJylcclxuICAgICAgICAucmVwbGFjZShBTVBFUlNBTkRfUkUsICclMjYnKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19CQUNLVElDS19SRSwgJ2AnKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DVVJMWV9PUEVOX1JFLCAneycpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX0NMT1NFX1JFLCAnfScpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NBUkVUX1JFLCAnXicpKTtcclxufVxyXG4vKipcclxuICogTGlrZSBgZW5jb2RlUXVlcnlWYWx1ZWAgYnV0IGFsc28gZW5jb2RlcyB0aGUgYD1gIGNoYXJhY3Rlci5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVRdWVyeUtleSh0ZXh0KSB7XHJcbiAgICByZXR1cm4gZW5jb2RlUXVlcnlWYWx1ZSh0ZXh0KS5yZXBsYWNlKEVRVUFMX1JFLCAnJTNEJyk7XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBwYXRoIHNlY3Rpb24gb2YgdGhlIFVSTC5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVQYXRoKHRleHQpIHtcclxuICAgIHJldHVybiBjb21tb25FbmNvZGUodGV4dCkucmVwbGFjZShIQVNIX1JFLCAnJTIzJykucmVwbGFjZShJTV9SRSwgJyUzRicpO1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZW5jb2RlZCBvbiB0aGUgcGF0aCBzZWN0aW9uIG9mIHRoZSBVUkwgYXMgYVxyXG4gKiBwYXJhbS4gVGhpcyBmdW5jdGlvbiBlbmNvZGVzIGV2ZXJ5dGhpbmcge0BsaW5rIGVuY29kZVBhdGh9IGRvZXMgcGx1cyB0aGVcclxuICogc2xhc2ggKGAvYCkgY2hhcmFjdGVyLiBJZiBgdGV4dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCByZXR1cm5zIGFuIGVtcHR5XHJcbiAqIHN0cmluZyBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcclxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZVBhcmFtKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyAnJyA6IGVuY29kZVBhdGgodGV4dCkucmVwbGFjZShTTEFTSF9SRSwgJyUyRicpO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGUgdGV4dCB1c2luZyBgZGVjb2RlVVJJQ29tcG9uZW50YC4gUmV0dXJucyB0aGUgb3JpZ2luYWwgdGV4dCBpZiBpdFxyXG4gKiBmYWlscy5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZGVjb2RlXHJcbiAqIEByZXR1cm5zIGRlY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGUodGV4dCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KCcnICsgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYEVycm9yIGRlY29kaW5nIFwiJHt0ZXh0fVwiLiBVc2luZyBvcmlnaW5hbCB2YWx1ZWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnICsgdGV4dDtcclxufVxuXG4vKipcclxuICogVHJhbnNmb3JtcyBhIHF1ZXJ5U3RyaW5nIGludG8gYSB7QGxpbmsgTG9jYXRpb25RdWVyeX0gb2JqZWN0LiBBY2NlcHQgYm90aCwgYVxyXG4gKiB2ZXJzaW9uIHdpdGggdGhlIGxlYWRpbmcgYD9gIGFuZCB3aXRob3V0IFNob3VsZCB3b3JrIGFzIFVSTFNlYXJjaFBhcmFtc1xyXG5cbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBAcGFyYW0gc2VhcmNoIC0gc2VhcmNoIHN0cmluZyB0byBwYXJzZVxyXG4gKiBAcmV0dXJucyBhIHF1ZXJ5IG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VRdWVyeShzZWFyY2gpIHtcclxuICAgIGNvbnN0IHF1ZXJ5ID0ge307XHJcbiAgICAvLyBhdm9pZCBjcmVhdGluZyBhbiBvYmplY3Qgd2l0aCBhbiBlbXB0eSBrZXkgYW5kIGVtcHR5IHZhbHVlXHJcbiAgICAvLyBiZWNhdXNlIG9mIHNwbGl0KCcmJylcclxuICAgIGlmIChzZWFyY2ggPT09ICcnIHx8IHNlYXJjaCA9PT0gJz8nKVxyXG4gICAgICAgIHJldHVybiBxdWVyeTtcclxuICAgIGNvbnN0IGhhc0xlYWRpbmdJTSA9IHNlYXJjaFswXSA9PT0gJz8nO1xyXG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gKGhhc0xlYWRpbmdJTSA/IHNlYXJjaC5zbGljZSgxKSA6IHNlYXJjaCkuc3BsaXQoJyYnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoUGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgLy8gcHJlIGRlY29kZSB0aGUgKyBpbnRvIHNwYWNlXHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW0gPSBzZWFyY2hQYXJhbXNbaV0ucmVwbGFjZShQTFVTX1JFLCAnICcpO1xyXG4gICAgICAgIC8vIGFsbG93IHRoZSA9IGNoYXJhY3RlclxyXG4gICAgICAgIGNvbnN0IGVxUG9zID0gc2VhcmNoUGFyYW0uaW5kZXhPZignPScpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGRlY29kZShlcVBvcyA8IDAgPyBzZWFyY2hQYXJhbSA6IHNlYXJjaFBhcmFtLnNsaWNlKDAsIGVxUG9zKSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlcVBvcyA8IDAgPyBudWxsIDogZGVjb2RlKHNlYXJjaFBhcmFtLnNsaWNlKGVxUG9zICsgMSkpO1xyXG4gICAgICAgIGlmIChrZXkgaW4gcXVlcnkpIHtcclxuICAgICAgICAgICAgLy8gYW4gZXh0cmEgdmFyaWFibGUgZm9yIHRzIHR5cGVzXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBxdWVyeVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcXVlcnlba2V5XSA9IFtjdXJyZW50VmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnk7XHJcbn1cclxuLyoqXHJcbiAqIFN0cmluZ2lmaWVzIGEge0BsaW5rIExvY2F0aW9uUXVlcnlSYXd9IG9iamVjdC4gTGlrZSBgVVJMU2VhcmNoUGFyYW1zYCwgaXRcclxuICogZG9lc24ndCBwcmVwZW5kIGEgYD9gXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBxdWVyeSBvYmplY3QgdG8gc3RyaW5naWZ5XHJcbiAqIEByZXR1cm5zIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBxdWVyeSB3aXRob3V0IHRoZSBsZWFkaW5nIGA/YFxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcclxuICAgIGxldCBzZWFyY2ggPSAnJztcclxuICAgIGZvciAobGV0IGtleSBpbiBxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcclxuICAgICAgICBrZXkgPSBlbmNvZGVRdWVyeUtleShrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgbnVsbCBhZGRzIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoICs9IChzZWFyY2gubGVuZ3RoID8gJyYnIDogJycpICsga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBrZWVwIG51bGwgdmFsdWVzXHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXNBcnJheSh2YWx1ZSlcclxuICAgICAgICAgICAgPyB2YWx1ZS5tYXAodiA9PiB2ICYmIGVuY29kZVF1ZXJ5VmFsdWUodikpXHJcbiAgICAgICAgICAgIDogW3ZhbHVlICYmIGVuY29kZVF1ZXJ5VmFsdWUodmFsdWUpXTtcclxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHNraXAgdW5kZWZpbmVkIHZhbHVlcyBpbiBhcnJheXMgYXMgaWYgdGhleSB3ZXJlIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICAgIC8vIHNtYWxsZXIgY29kZSB0aGFuIHVzaW5nIGZpbHRlclxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgJiB3aXRoIG5vbi1lbXB0eSBzZWFyY2hcclxuICAgICAgICAgICAgICAgIHNlYXJjaCArPSAoc2VhcmNoLmxlbmd0aCA/ICcmJyA6ICcnKSArIGtleTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaCArPSAnPScgKyB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlYXJjaDtcclxufVxyXG4vKipcclxuICogVHJhbnNmb3JtcyBhIHtAbGluayBMb2NhdGlvblF1ZXJ5UmF3fSBpbnRvIGEge0BsaW5rIExvY2F0aW9uUXVlcnl9IGJ5IGNhc3RpbmdcclxuICogbnVtYmVycyBpbnRvIHN0cmluZ3MsIHJlbW92aW5nIGtleXMgd2l0aCBhbiB1bmRlZmluZWQgdmFsdWUgYW5kIHJlcGxhY2luZ1xyXG4gKiB1bmRlZmluZWQgd2l0aCBudWxsIGluIGFycmF5c1xyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBxdWVyeSBvYmplY3QgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIGEgbm9ybWFsaXplZCBxdWVyeSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkUXVlcnkgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRRdWVyeVtrZXldID0gaXNBcnJheSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgID8gdmFsdWUubWFwKHYgPT4gKHYgPT0gbnVsbCA/IG51bGwgOiAnJyArIHYpKVxyXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA9PSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFF1ZXJ5O1xyXG59XG5cbi8qKlxyXG4gKiBSb3V0ZVJlY29yZCBiZWluZyByZW5kZXJlZCBieSB0aGUgY2xvc2VzdCBhbmNlc3RvciBSb3V0ZXIgVmlldy4gVXNlZCBmb3JcclxuICogYG9uQmVmb3JlUm91dGVVcGRhdGVgIGFuZCBgb25CZWZvcmVSb3V0ZUxlYXZlYC4gcnZsbSBzdGFuZHMgZm9yIFJvdXRlciBWaWV3XHJcbiAqIExvY2F0aW9uIE1hdGNoZWRcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBtYXRjaGVkUm91dGVLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGxvY2F0aW9uIG1hdGNoZWQnIDogJycpO1xyXG4vKipcclxuICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIHJvdXRlciB2aWV3IGRlcHRoIHRvIGNvbnRyb2wgd2hpY2ggY29tcG9uZW50IGluXHJcbiAqIGBtYXRjaGVkYCBpcyByZW5kZXJlZC4gcnZkIHN0YW5kcyBmb3IgUm91dGVyIFZpZXcgRGVwdGhcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2aWV3RGVwdGhLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGRlcHRoJyA6ICcnKTtcclxuLyoqXHJcbiAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSByb3V0ZXIgaW5zdGFuY2UgcmV0dXJuZWQgYnkgYHVzZVJvdXRlcmAgaW4gdGVzdHMuIHJcclxuICogc3RhbmRzIGZvciByb3V0ZXJcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCByb3V0ZXJLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlcicgOiAnJyk7XHJcbi8qKlxyXG4gKiBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgY3VycmVudCByb3V0ZSByZXR1cm5lZCBieSBgdXNlUm91dGVgIGluIHRlc3RzLiBybFxyXG4gKiBzdGFuZHMgZm9yIHJvdXRlIGxvY2F0aW9uXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3Qgcm91dGVMb2NhdGlvbktleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAncm91dGUgbG9jYXRpb24nIDogJycpO1xyXG4vKipcclxuICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGN1cnJlbnQgcm91dGUgdXNlZCBieSByb3V0ZXItdmlldy4gSW50ZXJuYWxseSB0aGlzIGlzXHJcbiAqIHVzZWQgd2hlbiB0aGUgYHJvdXRlYCBwcm9wIGlzIHBhc3NlZC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCByb3V0ZXJWaWV3TG9jYXRpb25LZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGxvY2F0aW9uJyA6ICcnKTtcblxuLyoqXHJcbiAqIENyZWF0ZSBhIGxpc3Qgb2YgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIHJlc2V0LiBVc2VkIHRvIGNyZWF0ZSBiZWZvcmUgYW5kIGFmdGVyIG5hdmlnYXRpb24gZ3VhcmRzIGxpc3RcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNhbGxiYWNrcygpIHtcclxuICAgIGxldCBoYW5kbGVycyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gYWRkKGhhbmRsZXIpIHtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSBoYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBpZiAoaSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgICAgICBoYW5kbGVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgbGlzdDogKCkgPT4gaGFuZGxlcnMsXHJcbiAgICAgICAgcmVzZXQsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR3VhcmQocmVjb3JkLCBuYW1lLCBndWFyZCkge1xyXG4gICAgY29uc3QgcmVtb3ZlRnJvbUxpc3QgPSAoKSA9PiB7XHJcbiAgICAgICAgcmVjb3JkW25hbWVdLmRlbGV0ZShndWFyZCk7XHJcbiAgICB9O1xyXG4gICAgb25Vbm1vdW50ZWQocmVtb3ZlRnJvbUxpc3QpO1xyXG4gICAgb25EZWFjdGl2YXRlZChyZW1vdmVGcm9tTGlzdCk7XHJcbiAgICBvbkFjdGl2YXRlZCgoKSA9PiB7XHJcbiAgICAgICAgcmVjb3JkW25hbWVdLmFkZChndWFyZCk7XHJcbiAgICB9KTtcclxuICAgIHJlY29yZFtuYW1lXS5hZGQoZ3VhcmQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYSBuYXZpZ2F0aW9uIGd1YXJkIHRoYXQgdHJpZ2dlcnMgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBmb3IgdGhlIGN1cnJlbnRcclxuICogbG9jYXRpb24gaXMgYWJvdXQgdG8gYmUgbGVmdC4gU2ltaWxhciB0byB7QGxpbmsgYmVmb3JlUm91dGVMZWF2ZX0gYnV0IGNhbiBiZVxyXG4gKiB1c2VkIGluIGFueSBjb21wb25lbnQuIFRoZSBndWFyZCBpcyByZW1vdmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBsZWF2ZUd1YXJkIC0ge0BsaW5rIE5hdmlnYXRpb25HdWFyZH1cclxuICovXHJcbmZ1bmN0aW9uIG9uQmVmb3JlUm91dGVMZWF2ZShsZWF2ZUd1YXJkKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFnZXRDdXJyZW50SW5zdGFuY2UoKSkge1xyXG4gICAgICAgIHdhcm4oJ2dldEN1cnJlbnRJbnN0YW5jZSgpIHJldHVybmVkIG51bGwuIG9uQmVmb3JlUm91dGVMZWF2ZSgpIG11c3QgYmUgY2FsbGVkIGF0IHRoZSB0b3Agb2YgYSBzZXR1cCBmdW5jdGlvbicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGFjdGl2ZVJlY29yZCA9IGluamVjdChtYXRjaGVkUm91dGVLZXksIFxyXG4gICAgLy8gdG8gYXZvaWQgd2FybmluZ1xyXG4gICAge30pLnZhbHVlO1xyXG4gICAgaWYgKCFhY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybignTm8gYWN0aXZlIHJvdXRlIHJlY29yZCB3YXMgZm91bmQgd2hlbiBjYWxsaW5nIGBvbkJlZm9yZVJvdXRlTGVhdmUoKWAuIE1ha2Ugc3VyZSB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIGluc2lkZSBhIGNvbXBvbmVudCBjaGlsZCBvZiA8cm91dGVyLXZpZXc+LiBNYXliZSB5b3UgY2FsbGVkIGl0IGluc2lkZSBvZiBBcHAudnVlPycpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyR3VhcmQoYWN0aXZlUmVjb3JkLCAnbGVhdmVHdWFyZHMnLCBsZWF2ZUd1YXJkKTtcclxufVxyXG4vKipcclxuICogQWRkIGEgbmF2aWdhdGlvbiBndWFyZCB0aGF0IHRyaWdnZXJzIHdoZW5ldmVyIHRoZSBjdXJyZW50IGxvY2F0aW9uIGlzIGFib3V0XHJcbiAqIHRvIGJlIHVwZGF0ZWQuIFNpbWlsYXIgdG8ge0BsaW5rIGJlZm9yZVJvdXRlVXBkYXRlfSBidXQgY2FuIGJlIHVzZWQgaW4gYW55XHJcbiAqIGNvbXBvbmVudC4gVGhlIGd1YXJkIGlzIHJlbW92ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cclxuICpcclxuICogQHBhcmFtIHVwZGF0ZUd1YXJkIC0ge0BsaW5rIE5hdmlnYXRpb25HdWFyZH1cclxuICovXHJcbmZ1bmN0aW9uIG9uQmVmb3JlUm91dGVVcGRhdGUodXBkYXRlR3VhcmQpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWdldEN1cnJlbnRJbnN0YW5jZSgpKSB7XHJcbiAgICAgICAgd2FybignZ2V0Q3VycmVudEluc3RhbmNlKCkgcmV0dXJuZWQgbnVsbC4gb25CZWZvcmVSb3V0ZVVwZGF0ZSgpIG11c3QgYmUgY2FsbGVkIGF0IHRoZSB0b3Agb2YgYSBzZXR1cCBmdW5jdGlvbicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGFjdGl2ZVJlY29yZCA9IGluamVjdChtYXRjaGVkUm91dGVLZXksIFxyXG4gICAgLy8gdG8gYXZvaWQgd2FybmluZ1xyXG4gICAge30pLnZhbHVlO1xyXG4gICAgaWYgKCFhY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybignTm8gYWN0aXZlIHJvdXRlIHJlY29yZCB3YXMgZm91bmQgd2hlbiBjYWxsaW5nIGBvbkJlZm9yZVJvdXRlVXBkYXRlKClgLiBNYWtlIHN1cmUgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBpbnNpZGUgYSBjb21wb25lbnQgY2hpbGQgb2YgPHJvdXRlci12aWV3Pi4gTWF5YmUgeW91IGNhbGxlZCBpdCBpbnNpZGUgb2YgQXBwLnZ1ZT8nKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZWdpc3Rlckd1YXJkKGFjdGl2ZVJlY29yZCwgJ3VwZGF0ZUd1YXJkcycsIHVwZGF0ZUd1YXJkKTtcclxufVxyXG5mdW5jdGlvbiBndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSwgcmVjb3JkLCBuYW1lKSB7XHJcbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBlbnRlckNhbGxiYWNrQXJyYXkgdG8gcHJldmVudCBwdXNoaW5nIGNhbGxiYWNrcyBpZiBhIG5ldyBuYXZpZ2F0aW9uIHRvb2sgcGxhY2VcclxuICAgIGNvbnN0IGVudGVyQ2FsbGJhY2tBcnJheSA9IHJlY29yZCAmJlxyXG4gICAgICAgIC8vIG5hbWUgaXMgZGVmaW5lZCBpZiByZWNvcmQgaXMgYmVjYXVzZSBvZiB0aGUgZnVuY3Rpb24gb3ZlcmxvYWRcclxuICAgICAgICAocmVjb3JkLmVudGVyQ2FsbGJhY2tzW25hbWVdID0gcmVjb3JkLmVudGVyQ2FsbGJhY2tzW25hbWVdIHx8IFtdKTtcclxuICAgIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9ICh2YWxpZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlUm91dGVyRXJyb3IoNCAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fQUJPUlRFRCAqLywge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsaWQgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHZhbGlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JvdXRlTG9jYXRpb24odmFsaWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlUm91dGVyRXJyb3IoMiAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fR1VBUkRfUkVESVJFQ1QgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0byxcclxuICAgICAgICAgICAgICAgICAgICB0bzogdmFsaWQsXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJDYWxsYmFja0FycmF5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgZW50ZXJDYWxsYmFja0FycmF5IGlzIHRydXRoeSwgYm90aCByZWNvcmQgYW5kIG5hbWUgYWxzbyBhcmVcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gPT09IGVudGVyQ2FsbGJhY2tBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWxpZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGVyQ2FsbGJhY2tBcnJheS5wdXNoKHZhbGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gd3JhcHBpbmcgd2l0aCBQcm9taXNlLnJlc29sdmUgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBib3RoIGFzeW5jIGFuZCBzeW5jIGd1YXJkc1xyXG4gICAgICAgIGNvbnN0IGd1YXJkUmV0dXJuID0gZ3VhcmQuY2FsbChyZWNvcmQgJiYgcmVjb3JkLmluc3RhbmNlc1tuYW1lXSwgdG8sIGZyb20sIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNhbk9ubHlCZUNhbGxlZE9uY2UobmV4dCwgdG8sIGZyb20pIDogbmV4dCk7XHJcbiAgICAgICAgbGV0IGd1YXJkQ2FsbCA9IFByb21pc2UucmVzb2x2ZShndWFyZFJldHVybik7XHJcbiAgICAgICAgaWYgKGd1YXJkLmxlbmd0aCA8IDMpXHJcbiAgICAgICAgICAgIGd1YXJkQ2FsbCA9IGd1YXJkQ2FsbC50aGVuKG5leHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ3VhcmQubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBcIm5leHRcIiBjYWxsYmFjayB3YXMgbmV2ZXIgY2FsbGVkIGluc2lkZSBvZiAke2d1YXJkLm5hbWUgPyAnXCInICsgZ3VhcmQubmFtZSArICdcIicgOiAnJ306XFxuJHtndWFyZC50b1N0cmluZygpfVxcbi4gSWYgeW91IGFyZSByZXR1cm5pbmcgYSB2YWx1ZSBpbnN0ZWFkIG9mIGNhbGxpbmcgXCJuZXh0XCIsIG1ha2Ugc3VyZSB0byByZW1vdmUgdGhlIFwibmV4dFwiIHBhcmFtZXRlciBmcm9tIHlvdXIgZnVuY3Rpb24uYDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBndWFyZFJldHVybiA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGd1YXJkUmV0dXJuKSB7XHJcbiAgICAgICAgICAgICAgICBndWFyZENhbGwgPSBndWFyZENhbGwudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBfY2FsbGVkIGlzIGFkZGVkIGF0IGNhbk9ubHlCZUNhbGxlZE9uY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQuX2NhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIG5hdmlnYXRpb24gZ3VhcmQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ3VhcmRSZXR1cm4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogX2NhbGxlZCBpcyBhZGRlZCBhdCBjYW5Pbmx5QmVDYWxsZWRPbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQuX2NhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBuYXZpZ2F0aW9uIGd1YXJkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBndWFyZENhbGwuY2F0Y2goZXJyID0+IHJlamVjdChlcnIpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNhbk9ubHlCZUNhbGxlZE9uY2UobmV4dCwgdG8sIGZyb20pIHtcclxuICAgIGxldCBjYWxsZWQgPSAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoY2FsbGVkKysgPT09IDEpXHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSBcIm5leHRcIiBjYWxsYmFjayB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIGluIG9uZSBuYXZpZ2F0aW9uIGd1YXJkIHdoZW4gZ29pbmcgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG8uZnVsbFBhdGh9XCIuIEl0IHNob3VsZCBiZSBjYWxsZWQgZXhhY3RseSBvbmUgdGltZSBpbiBlYWNoIG5hdmlnYXRpb24gZ3VhcmQuIFRoaXMgd2lsbCBmYWlsIGluIHByb2R1Y3Rpb24uYCk7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UgcHV0IGl0IGluIHRoZSBvcmlnaW5hbCBvbmUgYmVjYXVzZSBpdCdzIGVhc2llciB0byBjaGVja1xyXG4gICAgICAgIG5leHQuX2NhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGNhbGxlZCA9PT0gMSlcclxuICAgICAgICAgICAgbmV4dC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9uZW50c0d1YXJkcyhtYXRjaGVkLCBndWFyZFR5cGUsIHRvLCBmcm9tKSB7XHJcbiAgICBjb25zdCBndWFyZHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIG1hdGNoZWQpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFyZWNvcmQuY29tcG9uZW50cyAmJiAhcmVjb3JkLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB3YXJuKGBSZWNvcmQgd2l0aCBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIiBpcyBlaXRoZXIgbWlzc2luZyBhIFwiY29tcG9uZW50KHMpXCJgICtcclxuICAgICAgICAgICAgICAgIGAgb3IgXCJjaGlsZHJlblwiIHByb3BlcnR5LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVjb3JkLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgbGV0IHJhd0NvbXBvbmVudCA9IHJlY29yZC5jb21wb25lbnRzW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd0NvbXBvbmVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmF3Q29tcG9uZW50ICE9PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmF3Q29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBpbiByZWNvcmQgd2l0aCBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIiBpcyBub3RgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCBhIHZhbGlkIGNvbXBvbmVudC4gUmVjZWl2ZWQgXCIke1N0cmluZyhyYXdDb21wb25lbnQpfVwiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93IHRvIGVuc3VyZSB3ZSBzdG9wIGhlcmUgYnV0IHdhcm4gdG8gZW5zdXJlIHRoZSBtZXNzYWdlIGlzbid0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlzc2VkIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvdXRlIGNvbXBvbmVudCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ3RoZW4nIGluIHJhd0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gaWYgdXNlciB3cm90ZSBpbXBvcnQoJy9jb21wb25lbnQudnVlJykgaW5zdGVhZCBvZiAoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCgnLi9jb21wb25lbnQudnVlJylcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaW4gcmVjb3JkIHdpdGggcGF0aCBcIiR7cmVjb3JkLnBhdGh9XCIgaXMgYSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFByb21pc2UgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UuIERpZCB5b3UgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3cml0ZSBcImltcG9ydCgnLi9NeVBhZ2UudnVlJylcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgXCIoKSA9PiBpbXBvcnQoJy4vTXlQYWdlLnZ1ZScpXCIgPyBUaGlzIHdpbGwgYnJlYWsgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBwcm9kdWN0aW9uIGlmIG5vdCBmaXhlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gcmF3Q29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd0NvbXBvbmVudCA9ICgpID0+IHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdDb21wb25lbnQuX19hc3luY0xvYWRlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gb25seSBvbmNlIHBlciBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAhcmF3Q29tcG9uZW50Ll9fd2FybmVkRGVmaW5lQXN5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdDb21wb25lbnQuX193YXJuZWREZWZpbmVBc3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGluIHJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIGRlZmluZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB1c2luZyBcImRlZmluZUFzeW5jQ29tcG9uZW50KClcIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBXcml0ZSBcIigpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJylcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgXCJkZWZpbmVBc3luY0NvbXBvbmVudCgoKSA9PiBpbXBvcnQoJy4vTXlQYWdlLnZ1ZScpKVwiLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdXBkYXRlIGFuZCBsZWF2ZSBndWFyZHMgaWYgdGhlIHJvdXRlIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZFxyXG4gICAgICAgICAgICBpZiAoZ3VhcmRUeXBlICE9PSAnYmVmb3JlUm91dGVFbnRlcicgJiYgIXJlY29yZC5pbnN0YW5jZXNbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGlzUm91dGVDb21wb25lbnQocmF3Q29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gX192Y2NPcHRzIGlzIGFkZGVkIGJ5IHZ1ZS1jbGFzcy1jb21wb25lbnQgYW5kIGNvbnRhaW4gdGhlIHJlZ3VsYXIgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHJhd0NvbXBvbmVudC5fX3ZjY09wdHMgfHwgcmF3Q29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBvcHRpb25zW2d1YXJkVHlwZV07XHJcbiAgICAgICAgICAgICAgICBndWFyZCAmJiBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSwgcmVjb3JkLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydCByZXF1ZXN0aW5nIHRoZSBjaHVuayBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50UHJvbWlzZSA9IHJhd0NvbXBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhKCdjYXRjaCcgaW4gY29tcG9uZW50UHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaW4gcmVjb3JkIHdpdGggcGF0aCBcIiR7cmVjb3JkLnBhdGh9XCIgaXMgYSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IHJldHVybiBhIFByb21pc2UuIElmIHlvdSB3ZXJlIHBhc3NpbmcgYSBmdW5jdGlvbmFsIGNvbXBvbmVudCwgbWFrZSBzdXJlIHRvIGFkZCBhIFwiZGlzcGxheU5hbWVcIiB0byB0aGUgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgaW4gcHJvZHVjdGlvbiBpZiBub3QgZml4ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb21wb25lbnRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKCgpID0+IGNvbXBvbmVudFByb21pc2UudGhlbihyZXNvbHZlZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ291bGRuJ3QgcmVzb2x2ZSBjb21wb25lbnQgXCIke25hbWV9XCIgYXQgXCIke3JlY29yZC5wYXRofVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29tcG9uZW50ID0gaXNFU01vZHVsZShyZXNvbHZlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNvbHZlZC5kZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgcmVzb2x2ZWQgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGJlY2F1c2Ugd2Ugd2VudCBpbnRvIHRoZSBmb3IgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5jb21wb25lbnRzW25hbWVdID0gcmVzb2x2ZWRDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gX192Y2NPcHRzIGlzIGFkZGVkIGJ5IHZ1ZS1jbGFzcy1jb21wb25lbnQgYW5kIGNvbnRhaW4gdGhlIHJlZ3VsYXIgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlZENvbXBvbmVudC5fX3ZjY09wdHMgfHwgcmVzb2x2ZWRDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBvcHRpb25zW2d1YXJkVHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1YXJkICYmIGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tLCByZWNvcmQsIG5hbWUpKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3VhcmRzO1xyXG59XHJcbi8qKlxyXG4gKiBBbGxvd3MgZGlmZmVyZW50aWF0aW5nIGxhenkgY29tcG9uZW50cyBmcm9tIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbmQgdnVlLWNsYXNzLWNvbXBvbmVudFxyXG4gKiBAaW50ZXJuYWxcclxuICpcclxuICogQHBhcmFtIGNvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNSb3V0ZUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgfHxcclxuICAgICAgICAnZGlzcGxheU5hbWUnIGluIGNvbXBvbmVudCB8fFxyXG4gICAgICAgICdwcm9wcycgaW4gY29tcG9uZW50IHx8XHJcbiAgICAgICAgJ19fdmNjT3B0cycgaW4gY29tcG9uZW50KTtcclxufVxyXG4vKipcclxuICogRW5zdXJlcyBhIHJvdXRlIGlzIGxvYWRlZCwgc28gaXQgY2FuIGJlIHBhc3NlZCBhcyBvIHByb3AgdG8gYDxSb3V0ZXJWaWV3PmAuXHJcbiAqXHJcbiAqIEBwYXJhbSByb3V0ZSAtIHJlc29sdmVkIHJvdXRlIHRvIGxvYWRcclxuICovXHJcbmZ1bmN0aW9uIGxvYWRSb3V0ZUxvY2F0aW9uKHJvdXRlKSB7XHJcbiAgICByZXR1cm4gcm91dGUubWF0Y2hlZC5ldmVyeShyZWNvcmQgPT4gcmVjb3JkLnJlZGlyZWN0KVxyXG4gICAgICAgID8gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3QgbG9hZCBhIHJvdXRlIHRoYXQgcmVkaXJlY3RzLicpKVxyXG4gICAgICAgIDogUHJvbWlzZS5hbGwocm91dGUubWF0Y2hlZC5tYXAocmVjb3JkID0+IHJlY29yZC5jb21wb25lbnRzICYmXHJcbiAgICAgICAgICAgIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHJlY29yZC5jb21wb25lbnRzKS5yZWR1Y2UoKHByb21pc2VzLCBuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYXdDb21wb25lbnQgPSByZWNvcmQuY29tcG9uZW50c1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgISgnZGlzcGxheU5hbWUnIGluIHJhd0NvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHJhd0NvbXBvbmVudCgpLnRoZW4ocmVzb2x2ZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ291bGRuJ3QgcmVzb2x2ZSBjb21wb25lbnQgXCIke25hbWV9XCIgYXQgXCIke3JlY29yZC5wYXRofVwiLiBFbnN1cmUgeW91IHBhc3NlZCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZENvbXBvbmVudCA9IGlzRVNNb2R1bGUocmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmVkLmRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHJlc29sdmVkIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgYmVjYXVzZSB3ZSB3ZW50IGludG8gdGhlIGZvciBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5jb21wb25lbnRzW25hbWVdID0gcmVzb2x2ZWRDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XHJcbiAgICAgICAgICAgIH0sIFtdKSkpKS50aGVuKCgpID0+IHJvdXRlKTtcclxufVxuXG4vLyBUT0RPOiB3ZSBjb3VsZCBhbGxvdyBjdXJyZW50Um91dGUgYXMgYSBwcm9wIHRvIGV4cG9zZSBgaXNBY3RpdmVgIGFuZFxyXG4vLyBgaXNFeGFjdEFjdGl2ZWAgYmVoYXZpb3Igc2hvdWxkIGdvIHRocm91Z2ggYW4gUkZDXHJcbmZ1bmN0aW9uIHVzZUxpbmsocHJvcHMpIHtcclxuICAgIGNvbnN0IHJvdXRlciA9IGluamVjdChyb3V0ZXJLZXkpO1xyXG4gICAgY29uc3QgY3VycmVudFJvdXRlID0gaW5qZWN0KHJvdXRlTG9jYXRpb25LZXkpO1xyXG4gICAgY29uc3Qgcm91dGUgPSBjb21wdXRlZCgoKSA9PiByb3V0ZXIucmVzb2x2ZSh1bnJlZihwcm9wcy50bykpKTtcclxuICAgIGNvbnN0IGFjdGl2ZVJlY29yZEluZGV4ID0gY29tcHV0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgbWF0Y2hlZCB9ID0gcm91dGUudmFsdWU7XHJcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IG1hdGNoZWQ7XHJcbiAgICAgICAgY29uc3Qgcm91dGVNYXRjaGVkID0gbWF0Y2hlZFtsZW5ndGggLSAxXTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWF0Y2hlZCA9IGN1cnJlbnRSb3V0ZS5tYXRjaGVkO1xyXG4gICAgICAgIGlmICghcm91dGVNYXRjaGVkIHx8ICFjdXJyZW50TWF0Y2hlZC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRNYXRjaGVkLmZpbmRJbmRleChpc1NhbWVSb3V0ZVJlY29yZC5iaW5kKG51bGwsIHJvdXRlTWF0Y2hlZCkpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgLy8gcG9zc2libGUgcGFyZW50IHJlY29yZFxyXG4gICAgICAgIGNvbnN0IHBhcmVudFJlY29yZFBhdGggPSBnZXRPcmlnaW5hbFBhdGgobWF0Y2hlZFtsZW5ndGggLSAyXSk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAvLyB3ZSBhcmUgZGVhbGluZyB3aXRoIG5lc3RlZCByb3V0ZXNcclxuICAgICAgICBsZW5ndGggPiAxICYmXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgYW5kIG1hdGNoZWQgcm91dGUgaGF2ZSB0aGUgc2FtZSBwYXRoLCB0aGlzIGxpbmsgaXNcclxuICAgICAgICAgICAgLy8gcmVmZXJyaW5nIHRvIHRoZSBlbXB0eSBjaGlsZC4gT3Igd2UgY3VycmVudGx5IGFyZSBvbiBhIGRpZmZlcmVudFxyXG4gICAgICAgICAgICAvLyBjaGlsZCBvZiB0aGUgc2FtZSBwYXJlbnRcclxuICAgICAgICAgICAgZ2V0T3JpZ2luYWxQYXRoKHJvdXRlTWF0Y2hlZCkgPT09IHBhcmVudFJlY29yZFBhdGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgY29tcGFyaW5nIHRoZSBjaGlsZCB3aXRoIGl0cyBwYXJlbnRcclxuICAgICAgICAgICAgY3VycmVudE1hdGNoZWRbY3VycmVudE1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aCAhPT0gcGFyZW50UmVjb3JkUGF0aFxyXG4gICAgICAgICAgICA/IGN1cnJlbnRNYXRjaGVkLmZpbmRJbmRleChpc1NhbWVSb3V0ZVJlY29yZC5iaW5kKG51bGwsIG1hdGNoZWRbbGVuZ3RoIC0gMl0pKVxyXG4gICAgICAgICAgICA6IGluZGV4KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaXNBY3RpdmUgPSBjb21wdXRlZCgoKSA9PiBhY3RpdmVSZWNvcmRJbmRleC52YWx1ZSA+IC0xICYmXHJcbiAgICAgICAgaW5jbHVkZXNQYXJhbXMoY3VycmVudFJvdXRlLnBhcmFtcywgcm91dGUudmFsdWUucGFyYW1zKSk7XHJcbiAgICBjb25zdCBpc0V4YWN0QWN0aXZlID0gY29tcHV0ZWQoKCkgPT4gYWN0aXZlUmVjb3JkSW5kZXgudmFsdWUgPiAtMSAmJlxyXG4gICAgICAgIGFjdGl2ZVJlY29yZEluZGV4LnZhbHVlID09PSBjdXJyZW50Um91dGUubWF0Y2hlZC5sZW5ndGggLSAxICYmXHJcbiAgICAgICAgaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtcyhjdXJyZW50Um91dGUucGFyYW1zLCByb3V0ZS52YWx1ZS5wYXJhbXMpKTtcclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKGUgPSB7fSkge1xyXG4gICAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXJbdW5yZWYocHJvcHMucmVwbGFjZSkgPyAncmVwbGFjZScgOiAncHVzaCddKHVucmVmKHByb3BzLnRvKVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB1bmNhdWdodCBlcnJvcnMgYXJlIHRoZXkgYXJlIGxvZ2dlZCBhbnl3YXlcclxuICAgICAgICAgICAgKS5jYXRjaChub29wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gZGV2dG9vbHMgb25seVxyXG4gICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiBpc0Jyb3dzZXIpIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rQ29udGV4dERldnRvb2xzID0ge1xyXG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGlzQWN0aXZlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaXNFeGFjdEFjdGl2ZTogaXNFeGFjdEFjdGl2ZS52YWx1ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhpcyBpcyBpbnRlcm5hbFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3ZybF9kZXZ0b29scyA9IGluc3RhbmNlLl9fdnJsX2RldnRvb2xzIHx8IFtdO1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0aGlzIGlzIGludGVybmFsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdnJsX2RldnRvb2xzLnB1c2gobGlua0NvbnRleHREZXZ0b29scyk7XHJcbiAgICAgICAgICAgIHdhdGNoRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMucm91dGUgPSByb3V0ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMuaXNBY3RpdmUgPSBpc0FjdGl2ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMuaXNFeGFjdEFjdGl2ZSA9IGlzRXhhY3RBY3RpdmUudmFsdWU7XHJcbiAgICAgICAgICAgIH0sIHsgZmx1c2g6ICdwb3N0JyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5PVEU6IHVwZGF0ZSB7QGxpbmsgX1JvdXRlckxpbmtJfSdzIGAkc2xvdHNgIHR5cGUgd2hlbiB1cGRhdGluZyB0aGlzXHJcbiAgICAgKi9cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcm91dGUsXHJcbiAgICAgICAgaHJlZjogY29tcHV0ZWQoKCkgPT4gcm91dGUudmFsdWUuaHJlZiksXHJcbiAgICAgICAgaXNBY3RpdmUsXHJcbiAgICAgICAgaXNFeGFjdEFjdGl2ZSxcclxuICAgICAgICBuYXZpZ2F0ZSxcclxuICAgIH07XHJcbn1cclxuY29uc3QgUm91dGVyTGlua0ltcGwgPSAvKiNfX1BVUkVfXyovIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICBuYW1lOiAnUm91dGVyTGluaycsXHJcbiAgICBjb21wYXRDb25maWc6IHsgTU9ERTogMyB9LFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2U6IEJvb2xlYW4sXHJcbiAgICAgICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgICAgICAvLyBpbmFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgICAgIGN1c3RvbTogQm9vbGVhbixcclxuICAgICAgICBhcmlhQ3VycmVudFZhbHVlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogJ3BhZ2UnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgdXNlTGluayxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBsaW5rID0gcmVhY3RpdmUodXNlTGluayhwcm9wcykpO1xyXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5qZWN0KHJvdXRlcktleSk7XHJcbiAgICAgICAgY29uc3QgZWxDbGFzcyA9IGNvbXB1dGVkKCgpID0+ICh7XHJcbiAgICAgICAgICAgIFtnZXRMaW5rQ2xhc3MocHJvcHMuYWN0aXZlQ2xhc3MsIG9wdGlvbnMubGlua0FjdGl2ZUNsYXNzLCAncm91dGVyLWxpbmstYWN0aXZlJyldOiBsaW5rLmlzQWN0aXZlLFxyXG4gICAgICAgICAgICAvLyBbZ2V0TGlua0NsYXNzKFxyXG4gICAgICAgICAgICAvLyAgIHByb3BzLmluYWN0aXZlQ2xhc3MsXHJcbiAgICAgICAgICAgIC8vICAgb3B0aW9ucy5saW5rSW5hY3RpdmVDbGFzcyxcclxuICAgICAgICAgICAgLy8gICAncm91dGVyLWxpbmstaW5hY3RpdmUnXHJcbiAgICAgICAgICAgIC8vICldOiAhbGluay5pc0V4YWN0QWN0aXZlLFxyXG4gICAgICAgICAgICBbZ2V0TGlua0NsYXNzKHByb3BzLmV4YWN0QWN0aXZlQ2xhc3MsIG9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3MsICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnKV06IGxpbmsuaXNFeGFjdEFjdGl2ZSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQobGluayk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5jdXN0b21cclxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIDogaCgnYScsIHtcclxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1jdXJyZW50JzogbGluay5pc0V4YWN0QWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcHMuYXJpYUN1cnJlbnRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgb3ZlcnJpZGUgdXNlciBhZGRlZCBhdHRycyBidXQgVnVlIHdpbGwgc3RpbGwgYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxpc3RlbmVyLCBzbyB3ZSBlbmQgdXAgdHJpZ2dlcmluZyBib3RoXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogbGluay5uYXZpZ2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjbGFzczogZWxDbGFzcy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuKTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG4vKipcclxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIGxpbmsgdGhhdCB0cmlnZ2VycyBhIG5hdmlnYXRpb24gb24gY2xpY2suXHJcbiAqL1xyXG5jb25zdCBSb3V0ZXJMaW5rID0gUm91dGVyTGlua0ltcGw7XHJcbmZ1bmN0aW9uIGd1YXJkRXZlbnQoZSkge1xyXG4gICAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcclxuICAgIGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcclxuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcclxuICAgIGlmIChlLmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9uICE9PSAwKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZ2V0QXR0cmlidXRlIGRvZXMgZXhpc3RcclxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZ2V0QXR0cmlidXRlIGV4aXN0c1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xyXG4gICAgICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXHJcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpbmNsdWRlc1BhcmFtcyhvdXRlciwgaW5uZXIpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGlubmVyKSB7XHJcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGlubmVyW2tleV07XHJcbiAgICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IG91dGVyW2tleV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gb3V0ZXJWYWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheShvdXRlclZhbHVlKSB8fFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJWYWx1ZS5sZW5ndGggIT09IGlubmVyVmFsdWUubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgICAgICBpbm5lclZhbHVlLnNvbWUoKHZhbHVlLCBpKSA9PiB2YWx1ZSAhPT0gb3V0ZXJWYWx1ZVtpXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgb3JpZ2luYWwgcGF0aCB2YWx1ZSBvZiBhIHJlY29yZCBieSBmb2xsb3dpbmcgaXRzIGFsaWFzT2ZcclxuICogQHBhcmFtIHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxQYXRoKHJlY29yZCkge1xyXG4gICAgcmV0dXJuIHJlY29yZCA/IChyZWNvcmQuYWxpYXNPZiA/IHJlY29yZC5hbGlhc09mLnBhdGggOiByZWNvcmQucGF0aCkgOiAnJztcclxufVxyXG4vKipcclxuICogVXRpbGl0eSBjbGFzcyB0byBnZXQgdGhlIGFjdGl2ZSBjbGFzcyBiYXNlZCBvbiBkZWZhdWx0cy5cclxuICogQHBhcmFtIHByb3BDbGFzc1xyXG4gKiBAcGFyYW0gZ2xvYmFsQ2xhc3NcclxuICogQHBhcmFtIGRlZmF1bHRDbGFzc1xyXG4gKi9cclxuY29uc3QgZ2V0TGlua0NsYXNzID0gKHByb3BDbGFzcywgZ2xvYmFsQ2xhc3MsIGRlZmF1bHRDbGFzcykgPT4gcHJvcENsYXNzICE9IG51bGxcclxuICAgID8gcHJvcENsYXNzXHJcbiAgICA6IGdsb2JhbENsYXNzICE9IG51bGxcclxuICAgICAgICA/IGdsb2JhbENsYXNzXHJcbiAgICAgICAgOiBkZWZhdWx0Q2xhc3M7XG5cbmNvbnN0IFJvdXRlclZpZXdJbXBsID0gLyojX19QVVJFX18qLyBkZWZpbmVDb21wb25lbnQoe1xyXG4gICAgbmFtZTogJ1JvdXRlclZpZXcnLFxyXG4gICAgLy8gIzY3NCB3ZSBtYW51YWxseSBpbmhlcml0IHRoZW1cclxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIG5hbWU6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3V0ZTogT2JqZWN0LFxyXG4gICAgfSxcclxuICAgIC8vIEJldHRlciBjb21wYXQgZm9yIEB2dWUvY29tcGF0IHVzZXJzXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvcm91dGVyL2lzc3Vlcy8xMzE1XHJcbiAgICBjb21wYXRDb25maWc6IHsgTU9ERTogMyB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgYXR0cnMsIHNsb3RzIH0pIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkRlcHJlY2F0ZWRVc2FnZSgpO1xyXG4gICAgICAgIGNvbnN0IGluamVjdGVkUm91dGUgPSBpbmplY3Qocm91dGVyVmlld0xvY2F0aW9uS2V5KTtcclxuICAgICAgICBjb25zdCByb3V0ZVRvRGlzcGxheSA9IGNvbXB1dGVkKCgpID0+IHByb3BzLnJvdXRlIHx8IGluamVjdGVkUm91dGUudmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGluamVjdGVkRGVwdGggPSBpbmplY3Qodmlld0RlcHRoS2V5LCAwKTtcclxuICAgICAgICAvLyBUaGUgZGVwdGggY2hhbmdlcyBiYXNlZCBvbiBlbXB0eSBjb21wb25lbnRzIG9wdGlvbiwgd2hpY2ggYWxsb3dzIHBhc3N0aHJvdWdoIHJvdXRlcyBlLmcuIHJvdXRlcyB3aXRoIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gdGhhdCBhcmUgdXNlZCB0byByZXVzZSB0aGUgYHBhdGhgIHByb3BlcnR5XHJcbiAgICAgICAgY29uc3QgZGVwdGggPSBjb21wdXRlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbml0aWFsRGVwdGggPSB1bnJlZihpbmplY3RlZERlcHRoKTtcclxuICAgICAgICAgICAgY29uc3QgeyBtYXRjaGVkIH0gPSByb3V0ZVRvRGlzcGxheS52YWx1ZTtcclxuICAgICAgICAgICAgbGV0IG1hdGNoZWRSb3V0ZTtcclxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaGVkUm91dGUgPSBtYXRjaGVkW2luaXRpYWxEZXB0aF0pICYmXHJcbiAgICAgICAgICAgICAgICAhbWF0Y2hlZFJvdXRlLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxEZXB0aCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsRGVwdGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlZFJvdXRlUmVmID0gY29tcHV0ZWQoKCkgPT4gcm91dGVUb0Rpc3BsYXkudmFsdWUubWF0Y2hlZFtkZXB0aC52YWx1ZV0pO1xyXG4gICAgICAgIHByb3ZpZGUodmlld0RlcHRoS2V5LCBjb21wdXRlZCgoKSA9PiBkZXB0aC52YWx1ZSArIDEpKTtcclxuICAgICAgICBwcm92aWRlKG1hdGNoZWRSb3V0ZUtleSwgbWF0Y2hlZFJvdXRlUmVmKTtcclxuICAgICAgICBwcm92aWRlKHJvdXRlclZpZXdMb2NhdGlvbktleSwgcm91dGVUb0Rpc3BsYXkpO1xyXG4gICAgICAgIGNvbnN0IHZpZXdSZWYgPSByZWYoKTtcclxuICAgICAgICAvLyB3YXRjaCBhdCB0aGUgc2FtZSB0aW1lIHRoZSBjb21wb25lbnQgaW5zdGFuY2UsIHRoZSByb3V0ZSByZWNvcmQgd2UgYXJlXHJcbiAgICAgICAgLy8gcmVuZGVyaW5nLCBhbmQgdGhlIG5hbWVcclxuICAgICAgICB3YXRjaCgoKSA9PiBbdmlld1JlZi52YWx1ZSwgbWF0Y2hlZFJvdXRlUmVmLnZhbHVlLCBwcm9wcy5uYW1lXSwgKFtpbnN0YW5jZSwgdG8sIG5hbWVdLCBbb2xkSW5zdGFuY2UsIGZyb20sIG9sZE5hbWVdKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNvcHkgcmV1c2VkIGluc3RhbmNlc1xyXG4gICAgICAgICAgICBpZiAodG8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCB1cGRhdGUgdGhlIGluc3RhbmNlIGZvciBuZXcgaW5zdGFuY2VzIGFzIHdlbGwgYXMgcmV1c2VkXHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZXMgd2hlbiBuYXZpZ2F0aW5nIHRvIGEgbmV3IHJvdXRlXHJcbiAgICAgICAgICAgICAgICB0by5pbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGZvciBhIGRpZmZlcmVudCByb3V0ZSBvciBuYW1lLCBzb1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgY29weSBhbnkgc2F2ZWQgdXBkYXRlIG9yIGxlYXZlIGd1YXJkcy4gV2l0aCBhc3luYyBzZXR1cCwgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGluZyBjb21wb25lbnQgd2lsbCBtb3VudCBiZWZvcmUgdGhlIG1hdGNoZWRSb3V0ZSBjaGFuZ2VzLFxyXG4gICAgICAgICAgICAgICAgLy8gbWFraW5nIGluc3RhbmNlID09PSBvbGRJbnN0YW5jZSwgc28gd2UgY2hlY2sgaWYgZ3VhcmRzIGhhdmUgYmVlblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkZWQgYmVmb3JlLiBUaGlzIHdvcmtzIGJlY2F1c2Ugd2UgcmVtb3ZlIGd1YXJkcyB3aGVuXHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50aW5nL2RlYWN0aXZhdGluZyBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAmJiBmcm9tICE9PSB0byAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZSA9PT0gb2xkSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLmxlYXZlR3VhcmRzLnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG8ubGVhdmVHdWFyZHMgPSBmcm9tLmxlYXZlR3VhcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLnVwZGF0ZUd1YXJkcy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLnVwZGF0ZUd1YXJkcyA9IGZyb20udXBkYXRlR3VhcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGJlZm9yZVJvdXRlRW50ZXIgbmV4dCBjYWxsYmFja3NcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICB0byAmJlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYnV0IHRvIGFuZCBmcm9tIGFyZSB0aGUgc2FtZSB0aGlzIG1pZ2h0IGJlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdmlzaXRcclxuICAgICAgICAgICAgICAgICghZnJvbSB8fCAhaXNTYW1lUm91dGVSZWNvcmQodG8sIGZyb20pIHx8ICFvbGRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICh0by5lbnRlckNhbGxiYWNrc1tuYW1lXSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgeyBmbHVzaDogJ3Bvc3QnIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm91dGVUb0Rpc3BsYXkudmFsdWU7XHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIHZhbHVlIGF0IHRoZSB0aW1lIHdlIHJlbmRlciBiZWNhdXNlIHdoZW4gd2UgdW5tb3VudCwgd2VcclxuICAgICAgICAgICAgLy8gbmF2aWdhdGVkIHRvIGEgZGlmZmVyZW50IGxvY2F0aW9uIHNvIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnRcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5hbWUgPSBwcm9wcy5uYW1lO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkUm91dGUgPSBtYXRjaGVkUm91dGVSZWYudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IFZpZXdDb21wb25lbnQgPSBtYXRjaGVkUm91dGUgJiYgbWF0Y2hlZFJvdXRlLmNvbXBvbmVudHNbY3VycmVudE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoIVZpZXdDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVTbG90KHNsb3RzLmRlZmF1bHQsIHsgQ29tcG9uZW50OiBWaWV3Q29tcG9uZW50LCByb3V0ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wcyBmcm9tIHJvdXRlIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAgICAgY29uc3Qgcm91dGVQcm9wc09wdGlvbiA9IG1hdGNoZWRSb3V0ZS5wcm9wc1tjdXJyZW50TmFtZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSByb3V0ZVByb3BzT3B0aW9uXHJcbiAgICAgICAgICAgICAgICA/IHJvdXRlUHJvcHNPcHRpb24gPT09IHRydWVcclxuICAgICAgICAgICAgICAgICAgICA/IHJvdXRlLnBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHJvdXRlUHJvcHNPcHRpb24gPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyByb3V0ZVByb3BzT3B0aW9uKHJvdXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJvdXRlUHJvcHNPcHRpb25cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgY29uc3Qgb25Wbm9kZVVubW91bnRlZCA9IHZub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgaW5zdGFuY2UgcmVmZXJlbmNlIHRvIHByZXZlbnQgbGVha1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRSb3V0ZS5pbnN0YW5jZXNbY3VycmVudE5hbWVdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gaChWaWV3Q29tcG9uZW50LCBhc3NpZ24oe30sIHJvdXRlUHJvcHMsIGF0dHJzLCB7XHJcbiAgICAgICAgICAgICAgICBvblZub2RlVW5tb3VudGVkLFxyXG4gICAgICAgICAgICAgICAgcmVmOiB2aWV3UmVmLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiZcclxuICAgICAgICAgICAgICAgIGlzQnJvd3NlciAmJlxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnJlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2FuIGRpc3BsYXkgaWYgaXQncyBhbiBhbGlhcywgaXRzIHByb3BzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaGVkUm91dGUubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBtYXRjaGVkUm91dGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBtYXRjaGVkUm91dGUubWV0YSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlcyA9IGlzQXJyYXkoY29tcG9uZW50LnJlZilcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBvbmVudC5yZWYubWFwKHIgPT4gci5pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogW2NvbXBvbmVudC5yZWYuaV07XHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX192cnZfZGV2dG9vbHMgPSBpbmZvO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgLy8gcGFzcyB0aGUgdm5vZGUgdG8gdGhlIHNsb3QgYXMgYSBwcm9wLlxyXG4gICAgICAgICAgICAvLyBoIGFuZCA8Y29tcG9uZW50IDppcz1cIi4uLlwiPiBib3RoIGFjY2VwdCB2bm9kZXNcclxuICAgICAgICAgICAgbm9ybWFsaXplU2xvdChzbG90cy5kZWZhdWx0LCB7IENvbXBvbmVudDogY29tcG9uZW50LCByb3V0ZSB9KSB8fFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNsb3Qoc2xvdCwgZGF0YSkge1xyXG4gICAgaWYgKCFzbG90KVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgY29uc3Qgc2xvdENvbnRlbnQgPSBzbG90KGRhdGEpO1xyXG4gICAgcmV0dXJuIHNsb3RDb250ZW50Lmxlbmd0aCA9PT0gMSA/IHNsb3RDb250ZW50WzBdIDogc2xvdENvbnRlbnQ7XHJcbn1cclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdG8gZGlzcGxheSB0aGUgY3VycmVudCByb3V0ZSB0aGUgdXNlciBpcyBhdC5cclxuICovXHJcbmNvbnN0IFJvdXRlclZpZXcgPSBSb3V0ZXJWaWV3SW1wbDtcclxuLy8gd2FybiBhZ2FpbnN0IGRlcHJlY2F0ZWQgdXNhZ2Ugd2l0aCA8dHJhbnNpdGlvbj4gJiA8a2VlcC1hbGl2ZT5cclxuLy8gZHVlIHRvIGZ1bmN0aW9uYWwgY29tcG9uZW50IGJlaW5nIG5vIGxvbmdlciBlYWdlciBpbiBWdWUgM1xyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRlZFVzYWdlKCkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGNvbnN0IHBhcmVudE5hbWUgPSBpbnN0YW5jZS5wYXJlbnQgJiYgaW5zdGFuY2UucGFyZW50LnR5cGUubmFtZTtcclxuICAgIGlmIChwYXJlbnROYW1lICYmXHJcbiAgICAgICAgKHBhcmVudE5hbWUgPT09ICdLZWVwQWxpdmUnIHx8IHBhcmVudE5hbWUuaW5jbHVkZXMoJ1RyYW5zaXRpb24nKSkpIHtcclxuICAgICAgICBjb25zdCBjb21wID0gcGFyZW50TmFtZSA9PT0gJ0tlZXBBbGl2ZScgPyAna2VlcC1hbGl2ZScgOiAndHJhbnNpdGlvbic7XHJcbiAgICAgICAgd2FybihgPHJvdXRlci12aWV3PiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgZGlyZWN0bHkgaW5zaWRlIDx0cmFuc2l0aW9uPiBvciA8a2VlcC1hbGl2ZT4uXFxuYCArXHJcbiAgICAgICAgICAgIGBVc2Ugc2xvdCBwcm9wcyBpbnN0ZWFkOlxcblxcbmAgK1xyXG4gICAgICAgICAgICBgPHJvdXRlci12aWV3IHYtc2xvdD1cInsgQ29tcG9uZW50IH1cIj5cXG5gICtcclxuICAgICAgICAgICAgYCAgPCR7Y29tcH0+XFxuYCArXHJcbiAgICAgICAgICAgIGAgICAgPGNvbXBvbmVudCA6aXM9XCJDb21wb25lbnRcIiAvPlxcbmAgK1xyXG4gICAgICAgICAgICBgICA8LyR7Y29tcH0+XFxuYCArXHJcbiAgICAgICAgICAgIGA8L3JvdXRlci12aWV3PmApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBDb3BpZXMgYSByb3V0ZSBsb2NhdGlvbiBhbmQgcmVtb3ZlcyBhbnkgcHJvYmxlbWF0aWMgcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBzaG93biBpbiBkZXZ0b29scyAoZS5nLiBWdWUgaW5zdGFuY2VzKS5cclxuICpcclxuICogQHBhcmFtIHJvdXRlTG9jYXRpb24gLSByb3V0ZUxvY2F0aW9uIHRvIGZvcm1hdFxyXG4gKiBAcGFyYW0gdG9vbHRpcCAtIG9wdGlvbmFsIHRvb2x0aXBcclxuICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSByb3V0ZUxvY2F0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRSb3V0ZUxvY2F0aW9uKHJvdXRlTG9jYXRpb24sIHRvb2x0aXApIHtcclxuICAgIGNvbnN0IGNvcHkgPSBhc3NpZ24oe30sIHJvdXRlTG9jYXRpb24sIHtcclxuICAgICAgICAvLyByZW1vdmUgdmFyaWFibGVzIHRoYXQgY2FuIGNvbnRhaW4gdnVlIGluc3RhbmNlc1xyXG4gICAgICAgIG1hdGNoZWQ6IHJvdXRlTG9jYXRpb24ubWF0Y2hlZC5tYXAobWF0Y2hlZCA9PiBvbWl0KG1hdGNoZWQsIFsnaW5zdGFuY2VzJywgJ2NoaWxkcmVuJywgJ2FsaWFzT2YnXSkpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIF9jdXN0b206IHtcclxuICAgICAgICAgICAgdHlwZTogbnVsbCxcclxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHJvdXRlTG9jYXRpb24uZnVsbFBhdGgsXHJcbiAgICAgICAgICAgIHRvb2x0aXAsXHJcbiAgICAgICAgICAgIHZhbHVlOiBjb3B5LFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdERpc3BsYXkoZGlzcGxheSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfY3VzdG9tOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXksXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuLy8gdG8gc3VwcG9ydCBtdWx0aXBsZSByb3V0ZXIgaW5zdGFuY2VzXHJcbmxldCByb3V0ZXJJZCA9IDA7XHJcbmZ1bmN0aW9uIGFkZERldnRvb2xzKGFwcCwgcm91dGVyLCBtYXRjaGVyKSB7XHJcbiAgICAvLyBUYWtlIG92ZXIgcm91dGVyLmJlZm9yZUVhY2ggYW5kIGFmdGVyRWFjaFxyXG4gICAgLy8gbWFrZSBzdXJlIHdlIGFyZSBub3QgcmVnaXN0ZXJpbmcgdGhlIGRldnRvb2wgdHdpY2VcclxuICAgIGlmIChyb3V0ZXIuX19oYXNEZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICByb3V0ZXIuX19oYXNEZXZ0b29scyA9IHRydWU7XHJcbiAgICAvLyBpbmNyZW1lbnQgdG8gc3VwcG9ydCBtdWx0aXBsZSByb3V0ZXIgaW5zdGFuY2VzXHJcbiAgICBjb25zdCBpZCA9IHJvdXRlcklkKys7XHJcbiAgICBzZXR1cERldnRvb2xzUGx1Z2luKHtcclxuICAgICAgICBpZDogJ29yZy52dWVqcy5yb3V0ZXInICsgKGlkID8gJy4nICsgaWQgOiAnJyksXHJcbiAgICAgICAgbGFiZWw6ICdWdWUgUm91dGVyJyxcclxuICAgICAgICBwYWNrYWdlTmFtZTogJ3Z1ZS1yb3V0ZXInLFxyXG4gICAgICAgIGhvbWVwYWdlOiAnaHR0cHM6Ly9yb3V0ZXIudnVlanMub3JnJyxcclxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9yb3V0ZXIudnVlanMub3JnL2xvZ28ucG5nJyxcclxuICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzOiBbJ1JvdXRpbmcnXSxcclxuICAgICAgICBhcHAsXHJcbiAgICB9LCBhcGkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXBpLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tWdWUgUm91dGVyXTogWW91IHNlZW0gdG8gYmUgdXNpbmcgYW4gb3V0ZGF0ZWQgdmVyc2lvbiBvZiBWdWUgRGV2dG9vbHMuIEFyZSB5b3Ugc3RpbGwgdXNpbmcgdGhlIEJldGEgcmVsZWFzZSBpbnN0ZWFkIG9mIHRoZSBzdGFibGUgb25lPyBZb3UgY2FuIGZpbmQgdGhlIGxpbmtzIGF0IGh0dHBzOi8vZGV2dG9vbHMudnVlanMub3JnL2d1aWRlL2luc3RhbGxhdGlvbi5odG1sLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaXNwbGF5IHN0YXRlIGFkZGVkIGJ5IHRoZSByb3V0ZXJcclxuICAgICAgICBhcGkub24uaW5zcGVjdENvbXBvbmVudCgocGF5bG9hZCwgY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmluc3RhbmNlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JvdXRpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleTogJyRyb3V0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKHJvdXRlci5jdXJyZW50Um91dGUudmFsdWUsICdDdXJyZW50IFJvdXRlJyksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIG1hcmsgcm91dGVyLWxpbmsgYXMgYWN0aXZlIGFuZCBkaXNwbGF5IHRhZ3Mgb24gcm91dGVyIHZpZXdzXHJcbiAgICAgICAgYXBpLm9uLnZpc2l0Q29tcG9uZW50VHJlZSgoeyB0cmVlTm9kZTogbm9kZSwgY29tcG9uZW50SW5zdGFuY2UgfSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50SW5zdGFuY2UuX192cnZfZGV2dG9vbHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBjb21wb25lbnRJbnN0YW5jZS5fX3Zydl9kZXZ0b29scztcclxuICAgICAgICAgICAgICAgIG5vZGUudGFncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogKGluZm8ubmFtZSA/IGAke2luZm8ubmFtZS50b1N0cmluZygpfTogYCA6ICcnKSArIGluZm8ucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1RoaXMgY29tcG9uZW50IGlzIHJlbmRlcmVkIGJ5ICZsdDtyb3V0ZXItdmlldyZndDsnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogUElOS181MDAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBtdWx0aXBsZSB1c2VMaW5rIGFyZSB1c2VkXHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGNvbXBvbmVudEluc3RhbmNlLl9fdnJsX2RldnRvb2xzKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX19kZXZ0b29sc0FwaSA9IGFwaTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9fdnJsX2RldnRvb2xzLmZvckVhY2goZGV2dG9vbHNEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmFja2dyb3VuZENvbG9yID0gT1JBTkdFXzQwMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZ0b29sc0RhdGEuaXNFeGFjdEFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBMSU1FXzUwMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA9ICdUaGlzIGlzIGV4YWN0bHkgYWN0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGV2dG9vbHNEYXRhLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IEJMVUVfNjAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwID0gJ1RoaXMgbGluayBpcyBhY3RpdmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkZXZ0b29sc0RhdGEucm91dGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdhdGNoKHJvdXRlci5jdXJyZW50Um91dGUsICgpID0+IHtcclxuICAgICAgICAgICAgLy8gcmVmcmVzaCBhY3RpdmUgc3RhdGVcclxuICAgICAgICAgICAgcmVmcmVzaFJvdXRlc1ZpZXcoKTtcclxuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUocm91dGVySW5zcGVjdG9ySWQpO1xyXG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKHJvdXRlckluc3BlY3RvcklkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uc0xheWVySWQgPSAncm91dGVyOm5hdmlnYXRpb25zOicgKyBpZDtcclxuICAgICAgICBhcGkuYWRkVGltZWxpbmVMYXllcih7XHJcbiAgICAgICAgICAgIGlkOiBuYXZpZ2F0aW9uc0xheWVySWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBgUm91dGVyJHtpZCA/ICcgJyArIGlkIDogJyd9IE5hdmlnYXRpb25zYCxcclxuICAgICAgICAgICAgY29sb3I6IDB4NDBhOGM0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNvbnN0IGVycm9yc0xheWVySWQgPSAncm91dGVyOmVycm9ycydcclxuICAgICAgICAvLyBhcGkuYWRkVGltZWxpbmVMYXllcih7XHJcbiAgICAgICAgLy8gICBpZDogZXJyb3JzTGF5ZXJJZCxcclxuICAgICAgICAvLyAgIGxhYmVsOiAnUm91dGVyIEVycm9ycycsXHJcbiAgICAgICAgLy8gICBjb2xvcjogMHhlYTU0NTUsXHJcbiAgICAgICAgLy8gfSlcclxuICAgICAgICByb3V0ZXIub25FcnJvcigoZXJyb3IsIHRvKSA9PiB7XHJcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIGxheWVySWQ6IG5hdmlnYXRpb25zTGF5ZXJJZCxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBkdXJpbmcgTmF2aWdhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IHRvLmZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ1R5cGU6ICdlcnJvcicsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogYXBpLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgZXJyb3IgfSxcclxuICAgICAgICAgICAgICAgICAgICBncm91cElkOiB0by5tZXRhLl9fbmF2aWdhdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYXR0YWNoZWQgdG8gYG1ldGFgIGFuZCB1c2VkIHRvIGdyb3VwIGV2ZW50c1xyXG4gICAgICAgIGxldCBuYXZpZ2F0aW9uSWQgPSAwO1xyXG4gICAgICAgIHJvdXRlci5iZWZvcmVFYWNoKCh0bywgZnJvbSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgZ3VhcmQ6IGZvcm1hdERpc3BsYXkoJ2JlZm9yZUVhY2gnKSxcclxuICAgICAgICAgICAgICAgIGZyb206IGZvcm1hdFJvdXRlTG9jYXRpb24oZnJvbSwgJ0N1cnJlbnQgTG9jYXRpb24gZHVyaW5nIHRoaXMgbmF2aWdhdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgdG86IGZvcm1hdFJvdXRlTG9jYXRpb24odG8sICdUYXJnZXQgbG9jYXRpb24nKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gVXNlZCB0byBncm91cCBuYXZpZ2F0aW9ucyB0b2dldGhlciwgaGlkZSBmcm9tIGRldnRvb2xzXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0by5tZXRhLCAnX19uYXZpZ2F0aW9uSWQnLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmF2aWdhdGlvbklkKyssXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XHJcbiAgICAgICAgICAgICAgICBsYXllcklkOiBuYXZpZ2F0aW9uc0xheWVySWQsXHJcbiAgICAgICAgICAgICAgICBldmVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGFwaS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1N0YXJ0IG9mIG5hdmlnYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiB0by5mdWxsUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHRvLm1ldGEuX19uYXZpZ2F0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByb3V0ZXIuYWZ0ZXJFYWNoKCh0bywgZnJvbSwgZmFpbHVyZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgZ3VhcmQ6IGZvcm1hdERpc3BsYXkoJ2FmdGVyRWFjaCcpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5mYWlsdXJlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jdXN0b206IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWlsdXJlID8gZmFpbHVyZS5tZXNzYWdlIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdOYXZpZ2F0aW9uIEZhaWx1cmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFpbHVyZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gZm9ybWF0RGlzcGxheSgn4p2MJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IGZvcm1hdERpc3BsYXkoJ+KchScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIHNldCBoZXJlIHRvIGhhdmUgdGhlIHJpZ2h0IG9yZGVyXHJcbiAgICAgICAgICAgIGRhdGEuZnJvbSA9IGZvcm1hdFJvdXRlTG9jYXRpb24oZnJvbSwgJ0N1cnJlbnQgTG9jYXRpb24gZHVyaW5nIHRoaXMgbmF2aWdhdGlvbicpO1xyXG4gICAgICAgICAgICBkYXRhLnRvID0gZm9ybWF0Um91dGVMb2NhdGlvbih0bywgJ1RhcmdldCBsb2NhdGlvbicpO1xyXG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XHJcbiAgICAgICAgICAgICAgICBsYXllcklkOiBuYXZpZ2F0aW9uc0xheWVySWQsXHJcbiAgICAgICAgICAgICAgICBldmVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRW5kIG9mIG5hdmlnYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiB0by5mdWxsUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBhcGkubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBsb2dUeXBlOiBmYWlsdXJlID8gJ3dhcm5pbmcnIDogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHRvLm1ldGEuX19uYXZpZ2F0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNwZWN0b3Igb2YgRXhpc3Rpbmcgcm91dGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3Qgcm91dGVySW5zcGVjdG9ySWQgPSAncm91dGVyLWluc3BlY3RvcjonICsgaWQ7XHJcbiAgICAgICAgYXBpLmFkZEluc3BlY3Rvcih7XHJcbiAgICAgICAgICAgIGlkOiByb3V0ZXJJbnNwZWN0b3JJZCxcclxuICAgICAgICAgICAgbGFiZWw6ICdSb3V0ZXMnICsgKGlkID8gJyAnICsgaWQgOiAnJyksXHJcbiAgICAgICAgICAgIGljb246ICdib29rJyxcclxuICAgICAgICAgICAgdHJlZUZpbHRlclBsYWNlaG9sZGVyOiAnU2VhcmNoIHJvdXRlcycsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFJvdXRlc1ZpZXcoKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSByb3V0ZXMgdmlldyBpc24ndCBhY3RpdmVcclxuICAgICAgICAgICAgaWYgKCFhY3RpdmVSb3V0ZXNQYXlsb2FkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYWN0aXZlUm91dGVzUGF5bG9hZDtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gcm91dGVzIHdpbGwgYXBwZWFyIGFzIG5lc3RlZFxyXG4gICAgICAgICAgICBsZXQgcm91dGVzID0gbWF0Y2hlci5nZXRSb3V0ZXMoKS5maWx0ZXIocm91dGUgPT4gIXJvdXRlLnBhcmVudCk7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IG1hdGNoIHN0YXRlIHRvIGZhbHNlXHJcbiAgICAgICAgICAgIHJvdXRlcy5mb3JFYWNoKHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQpO1xyXG4gICAgICAgICAgICAvLyBhcHBseSBhIG1hdGNoIHN0YXRlIGlmIHRoZXJlIGlzIGEgcGF5bG9hZFxyXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJvdXRlcyA9IHJvdXRlcy5maWx0ZXIocm91dGUgPT4gXHJcbiAgICAgICAgICAgICAgICAvLyBzYXZlIG1hdGNoZXMgc3RhdGUgYmFzZWQgb24gdGhlIHBheWxvYWRcclxuICAgICAgICAgICAgICAgIGlzUm91dGVNYXRjaGluZyhyb3V0ZSwgcGF5bG9hZC5maWx0ZXIudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1hcmsgYWN0aXZlIHJvdXRlc1xyXG4gICAgICAgICAgICByb3V0ZXMuZm9yRWFjaChyb3V0ZSA9PiBtYXJrUm91dGVSZWNvcmRBY3RpdmUocm91dGUsIHJvdXRlci5jdXJyZW50Um91dGUudmFsdWUpKTtcclxuICAgICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSByb3V0ZXMubWFwKGZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGFjdGl2ZVJvdXRlc1BheWxvYWQ7XHJcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUocGF5bG9hZCA9PiB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVJvdXRlc1BheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSByb3V0ZXJJbnNwZWN0b3JJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFJvdXRlc1ZpZXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3BsYXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByb3V0ZSByZWNvcmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBhcGkub24uZ2V0SW5zcGVjdG9yU3RhdGUocGF5bG9hZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IHJvdXRlckluc3BlY3RvcklkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXMgPSBtYXRjaGVyLmdldFJvdXRlcygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb3V0ZXMuZmluZChyb3V0ZSA9PiByb3V0ZS5yZWNvcmQuX192ZF9pZCA9PT0gcGF5bG9hZC5ub2RlSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZm9ybWF0Um91dGVSZWNvcmRNYXRjaGVyRm9yU3RhdGVJbnNwZWN0b3Iocm91dGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUocm91dGVySW5zcGVjdG9ySWQpO1xyXG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUocm91dGVySW5zcGVjdG9ySWQpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbW9kaWZpZXJGb3JLZXkoa2V5KSB7XHJcbiAgICBpZiAoa2V5Lm9wdGlvbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleS5yZXBlYXRhYmxlID8gJyonIDogJz8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGtleS5yZXBlYXRhYmxlID8gJysnIDogJyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0Um91dGVSZWNvcmRNYXRjaGVyRm9yU3RhdGVJbnNwZWN0b3Iocm91dGUpIHtcclxuICAgIGNvbnN0IHsgcmVjb3JkIH0gPSByb3V0ZTtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICB7IGVkaXRhYmxlOiBmYWxzZSwga2V5OiAncGF0aCcsIHZhbHVlOiByZWNvcmQucGF0aCB9LFxyXG4gICAgXTtcclxuICAgIGlmIChyZWNvcmQubmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ25hbWUnLFxyXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLm5hbWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmaWVsZHMucHVzaCh7IGVkaXRhYmxlOiBmYWxzZSwga2V5OiAncmVnZXhwJywgdmFsdWU6IHJvdXRlLnJlIH0pO1xyXG4gICAgaWYgKHJvdXRlLmtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ2tleXMnLFxyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgX2N1c3RvbToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogcm91dGUua2V5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBgJHtrZXkubmFtZX0ke21vZGlmaWVyRm9yS2V5KGtleSl9YClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKSxcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUGFyYW0ga2V5cycsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJvdXRlLmtleXMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY29yZC5yZWRpcmVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ3JlZGlyZWN0JyxcclxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5yZWRpcmVjdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyb3V0ZS5hbGlhcy5sZW5ndGgpIHtcclxuICAgICAgICBmaWVsZHMucHVzaCh7XHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAga2V5OiAnYWxpYXNlcycsXHJcbiAgICAgICAgICAgIHZhbHVlOiByb3V0ZS5hbGlhcy5tYXAoYWxpYXMgPT4gYWxpYXMucmVjb3JkLnBhdGgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHJvdXRlLnJlY29yZC5tZXRhKS5sZW5ndGgpIHtcclxuICAgICAgICBmaWVsZHMucHVzaCh7XHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAga2V5OiAnbWV0YScsXHJcbiAgICAgICAgICAgIHZhbHVlOiByb3V0ZS5yZWNvcmQubWV0YSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZpZWxkcy5wdXNoKHtcclxuICAgICAgICBrZXk6ICdzY29yZScsXHJcbiAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgIF9jdXN0b206IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHJvdXRlLnNjb3JlLm1hcChzY29yZSA9PiBzY29yZS5qb2luKCcsICcpKS5qb2luKCcgfCAnKSxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTY29yZSB1c2VkIHRvIHNvcnQgcm91dGVzJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiByb3V0ZS5zY29yZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmllbGRzO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0ZWQgZnJvbSB0YWlsd2luZCBwYWxldHRlXHJcbiAqL1xyXG5jb25zdCBQSU5LXzUwMCA9IDB4ZWM0ODk5O1xyXG5jb25zdCBCTFVFXzYwMCA9IDB4MjU2M2ViO1xyXG5jb25zdCBMSU1FXzUwMCA9IDB4ODRjYzE2O1xyXG5jb25zdCBDWUFOXzQwMCA9IDB4MjJkM2VlO1xyXG5jb25zdCBPUkFOR0VfNDAwID0gMHhmYjkyM2M7XHJcbi8vIGNvbnN0IEdSQVlfMTAwID0gMHhmNGY0ZjVcclxuY29uc3QgREFSSyA9IDB4NjY2NjY2O1xyXG5mdW5jdGlvbiBmb3JtYXRSb3V0ZVJlY29yZEZvckluc3BlY3Rvcihyb3V0ZSkge1xyXG4gICAgY29uc3QgdGFncyA9IFtdO1xyXG4gICAgY29uc3QgeyByZWNvcmQgfSA9IHJvdXRlO1xyXG4gICAgaWYgKHJlY29yZC5uYW1lICE9IG51bGwpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogU3RyaW5nKHJlY29yZC5uYW1lKSxcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENZQU5fNDAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY29yZC5hbGlhc09mKSB7XHJcbiAgICAgICAgdGFncy5wdXNoKHtcclxuICAgICAgICAgICAgbGFiZWw6ICdhbGlhcycsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBPUkFOR0VfNDAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJvdXRlLl9fdmRfbWF0Y2gpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogJ21hdGNoZXMnLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogUElOS181MDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm91dGUuX192ZF9leGFjdEFjdGl2ZSkge1xyXG4gICAgICAgIHRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnZXhhY3QnLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogTElNRV81MDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm91dGUuX192ZF9hY3RpdmUpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogJ2FjdGl2ZScsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBCTFVFXzYwMCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyZWNvcmQucmVkaXJlY3QpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogdHlwZW9mIHJlY29yZC5yZWRpcmVjdCA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gYHJlZGlyZWN0OiAke3JlY29yZC5yZWRpcmVjdH1gXHJcbiAgICAgICAgICAgICAgICA6ICdyZWRpcmVjdHMnLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IERBUkssXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgYW4gaWQgdG8gYmUgYWJsZSB0byBzZWxlY3QgaXQuIFVzaW5nIHRoZSBgcGF0aGAgaXMgbm90IHBvc3NpYmxlIGJlY2F1c2VcclxuICAgIC8vIGVtcHR5IHBhdGggY2hpbGRyZW4gd291bGQgY29sbGlkZSB3aXRoIHRoZWlyIHBhcmVudHNcclxuICAgIGxldCBpZCA9IHJlY29yZC5fX3ZkX2lkO1xyXG4gICAgaWYgKGlkID09IG51bGwpIHtcclxuICAgICAgICBpZCA9IFN0cmluZyhyb3V0ZVJlY29yZElkKyspO1xyXG4gICAgICAgIHJlY29yZC5fX3ZkX2lkID0gaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGxhYmVsOiByZWNvcmQucGF0aCxcclxuICAgICAgICB0YWdzLFxyXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlbi5tYXAoZm9ybWF0Um91dGVSZWNvcmRGb3JJbnNwZWN0b3IpLFxyXG4gICAgfTtcclxufVxyXG4vLyAgaW5jcmVtZW50YWwgaWQgZm9yIHJvdXRlIHJlY29yZHMgYW5kIGluc3BlY3RvciBzdGF0ZVxyXG5sZXQgcm91dGVSZWNvcmRJZCA9IDA7XHJcbmNvbnN0IEVYVFJBQ1RfUkVHRVhQX1JFID0gL15cXC8oLiopXFwvKFthLXpdKikkLztcclxuZnVuY3Rpb24gbWFya1JvdXRlUmVjb3JkQWN0aXZlKHJvdXRlLCBjdXJyZW50Um91dGUpIHtcclxuICAgIC8vIG5vIHJvdXRlIHdpbGwgYmUgYWN0aXZlIGlmIG1hdGNoZWQgaXMgZW1wdHlcclxuICAgIC8vIHJlc2V0IHRoZSBtYXRjaGluZyBzdGF0ZVxyXG4gICAgY29uc3QgaXNFeGFjdEFjdGl2ZSA9IGN1cnJlbnRSb3V0ZS5tYXRjaGVkLmxlbmd0aCAmJlxyXG4gICAgICAgIGlzU2FtZVJvdXRlUmVjb3JkKGN1cnJlbnRSb3V0ZS5tYXRjaGVkW2N1cnJlbnRSb3V0ZS5tYXRjaGVkLmxlbmd0aCAtIDFdLCByb3V0ZS5yZWNvcmQpO1xyXG4gICAgcm91dGUuX192ZF9leGFjdEFjdGl2ZSA9IHJvdXRlLl9fdmRfYWN0aXZlID0gaXNFeGFjdEFjdGl2ZTtcclxuICAgIGlmICghaXNFeGFjdEFjdGl2ZSkge1xyXG4gICAgICAgIHJvdXRlLl9fdmRfYWN0aXZlID0gY3VycmVudFJvdXRlLm1hdGNoZWQuc29tZShtYXRjaCA9PiBpc1NhbWVSb3V0ZVJlY29yZChtYXRjaCwgcm91dGUucmVjb3JkKSk7XHJcbiAgICB9XHJcbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkUm91dGUgPT4gbWFya1JvdXRlUmVjb3JkQWN0aXZlKGNoaWxkUm91dGUsIGN1cnJlbnRSb3V0ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQocm91dGUpIHtcclxuICAgIHJvdXRlLl9fdmRfbWF0Y2ggPSBmYWxzZTtcclxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2gocmVzZXRNYXRjaFN0YXRlT25Sb3V0ZVJlY29yZCk7XHJcbn1cclxuZnVuY3Rpb24gaXNSb3V0ZU1hdGNoaW5nKHJvdXRlLCBmaWx0ZXIpIHtcclxuICAgIGNvbnN0IGZvdW5kID0gU3RyaW5nKHJvdXRlLnJlKS5tYXRjaChFWFRSQUNUX1JFR0VYUF9SRSk7XHJcbiAgICByb3V0ZS5fX3ZkX21hdGNoID0gZmFsc2U7XHJcbiAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyB1c2UgYSByZWdleHAgd2l0aG91dCAkIGF0IHRoZSBlbmQgdG8gbWF0Y2ggbmVzdGVkIHJvdXRlcyBiZXR0ZXJcclxuICAgIGNvbnN0IG5vbkVuZGluZ1JFID0gbmV3IFJlZ0V4cChmb3VuZFsxXS5yZXBsYWNlKC9cXCQkLywgJycpLCBmb3VuZFsyXSk7XHJcbiAgICBpZiAobm9uRW5kaW5nUkUudGVzdChmaWx0ZXIpKSB7XHJcbiAgICAgICAgLy8gbWFyayBjaGlsZHJlbiBhcyBtYXRjaGVzXHJcbiAgICAgICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBpc1JvdXRlTWF0Y2hpbmcoY2hpbGQsIGZpbHRlcikpO1xyXG4gICAgICAgIC8vIGV4Y2VwdGlvbiBjYXNlOiBgL2BcclxuICAgICAgICBpZiAocm91dGUucmVjb3JkLnBhdGggIT09ICcvJyB8fCBmaWx0ZXIgPT09ICcvJykge1xyXG4gICAgICAgICAgICByb3V0ZS5fX3ZkX21hdGNoID0gcm91dGUucmUudGVzdChmaWx0ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGlkZSB0aGUgLyByb3V0ZVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhdGggPSByb3V0ZS5yZWNvcmQucGF0aC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgZGVjb2RlZFBhdGggPSBkZWNvZGUocGF0aCk7XHJcbiAgICAvLyBhbHNvIGFsbG93IHBhcnRpYWwgbWF0Y2hpbmcgb24gdGhlIHBhdGhcclxuICAgIGlmICghZmlsdGVyLnN0YXJ0c1dpdGgoJy8nKSAmJlxyXG4gICAgICAgIChkZWNvZGVkUGF0aC5pbmNsdWRlcyhmaWx0ZXIpIHx8IHBhdGguaW5jbHVkZXMoZmlsdGVyKSkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoZGVjb2RlZFBhdGguc3RhcnRzV2l0aChmaWx0ZXIpIHx8IHBhdGguc3RhcnRzV2l0aChmaWx0ZXIpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKHJvdXRlLnJlY29yZC5uYW1lICYmIFN0cmluZyhyb3V0ZS5yZWNvcmQubmFtZSkuaW5jbHVkZXMoZmlsdGVyKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiByb3V0ZS5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGlzUm91dGVNYXRjaGluZyhjaGlsZCwgZmlsdGVyKSk7XHJcbn1cclxuZnVuY3Rpb24gb21pdChvYmosIGtleXMpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBSb3V0ZXIgaW5zdGFuY2UgdGhhdCBjYW4gYmUgdXNlZCBieSBhIFZ1ZSBhcHAuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIFJvdXRlck9wdGlvbnN9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIob3B0aW9ucykge1xyXG4gICAgY29uc3QgbWF0Y2hlciA9IGNyZWF0ZVJvdXRlck1hdGNoZXIob3B0aW9ucy5yb3V0ZXMsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgcGFyc2VRdWVyeSQxID0gb3B0aW9ucy5wYXJzZVF1ZXJ5IHx8IHBhcnNlUXVlcnk7XHJcbiAgICBjb25zdCBzdHJpbmdpZnlRdWVyeSQxID0gb3B0aW9ucy5zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcclxuICAgIGNvbnN0IHJvdXRlckhpc3RvcnkgPSBvcHRpb25zLmhpc3Rvcnk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFyb3V0ZXJIaXN0b3J5KVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZSB0aGUgXCJoaXN0b3J5XCIgb3B0aW9uIHdoZW4gY2FsbGluZyBcImNyZWF0ZVJvdXRlcigpXCI6JyArXHJcbiAgICAgICAgICAgICcgaHR0cHM6Ly9uZXh0LnJvdXRlci52dWVqcy5vcmcvYXBpLyNoaXN0b3J5LicpO1xyXG4gICAgY29uc3QgYmVmb3JlR3VhcmRzID0gdXNlQ2FsbGJhY2tzKCk7XHJcbiAgICBjb25zdCBiZWZvcmVSZXNvbHZlR3VhcmRzID0gdXNlQ2FsbGJhY2tzKCk7XHJcbiAgICBjb25zdCBhZnRlckd1YXJkcyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgY29uc3QgY3VycmVudFJvdXRlID0gc2hhbGxvd1JlZihTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEKTtcclxuICAgIGxldCBwZW5kaW5nTG9jYXRpb24gPSBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEO1xyXG4gICAgLy8gbGVhdmUgdGhlIHNjcm9sbFJlc3RvcmF0aW9uIGlmIG5vIHNjcm9sbEJlaGF2aW9yIGlzIHByb3ZpZGVkXHJcbiAgICBpZiAoaXNCcm93c2VyICYmIG9wdGlvbnMuc2Nyb2xsQmVoYXZpb3IgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiBoaXN0b3J5KSB7XHJcbiAgICAgICAgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplUGFyYW1zID0gYXBwbHlUb1BhcmFtcy5iaW5kKG51bGwsIHBhcmFtVmFsdWUgPT4gJycgKyBwYXJhbVZhbHVlKTtcclxuICAgIGNvbnN0IGVuY29kZVBhcmFtcyA9IGFwcGx5VG9QYXJhbXMuYmluZChudWxsLCBlbmNvZGVQYXJhbSk7XHJcbiAgICBjb25zdCBkZWNvZGVQYXJhbXMgPSBcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsbHkgYXZvaWQgdGhlIHR5cGUgY2hlY2tcclxuICAgIGFwcGx5VG9QYXJhbXMuYmluZChudWxsLCBkZWNvZGUpO1xyXG4gICAgZnVuY3Rpb24gYWRkUm91dGUocGFyZW50T3JSb3V0ZSwgcm91dGUpIHtcclxuICAgICAgICBsZXQgcGFyZW50O1xyXG4gICAgICAgIGxldCByZWNvcmQ7XHJcbiAgICAgICAgaWYgKGlzUm91dGVOYW1lKHBhcmVudE9yUm91dGUpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IG1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihwYXJlbnRPclJvdXRlKTtcclxuICAgICAgICAgICAgcmVjb3JkID0gcm91dGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWNvcmQgPSBwYXJlbnRPclJvdXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlci5hZGRSb3V0ZShyZWNvcmQsIHBhcmVudCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVSb3V0ZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkTWF0Y2hlciA9IG1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKTtcclxuICAgICAgICBpZiAocmVjb3JkTWF0Y2hlcikge1xyXG4gICAgICAgICAgICBtYXRjaGVyLnJlbW92ZVJvdXRlKHJlY29yZE1hdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgQ2Fubm90IHJlbW92ZSBub24tZXhpc3RlbnQgcm91dGUgXCIke1N0cmluZyhuYW1lKX1cImApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJvdXRlcygpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlci5nZXRSb3V0ZXMoKS5tYXAocm91dGVNYXRjaGVyID0+IHJvdXRlTWF0Y2hlci5yZWNvcmQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzUm91dGUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiAhIW1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUocmF3TG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbikge1xyXG4gICAgICAgIC8vIGNvbnN0IG9iamVjdExvY2F0aW9uID0gcm91dGVyTG9jYXRpb25Bc09iamVjdChyYXdMb2NhdGlvbilcclxuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBjb3B5IHRvIG1vZGlmeSBpdCBsYXRlclxyXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbiA9IGFzc2lnbih7fSwgY3VycmVudExvY2F0aW9uIHx8IGN1cnJlbnRSb3V0ZS52YWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXdMb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25Ob3JtYWxpemVkID0gcGFyc2VVUkwocGFyc2VRdWVyeSQxLCByYXdMb2NhdGlvbiwgY3VycmVudExvY2F0aW9uLnBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkUm91dGUgPSBtYXRjaGVyLnJlc29sdmUoeyBwYXRoOiBsb2NhdGlvbk5vcm1hbGl6ZWQucGF0aCB9LCBjdXJyZW50TG9jYXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBocmVmID0gcm91dGVySGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uTm9ybWFsaXplZC5mdWxsUGF0aCk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChocmVmLnN0YXJ0c1dpdGgoJy8vJykpXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgTG9jYXRpb24gXCIke3Jhd0xvY2F0aW9ufVwiIHJlc29sdmVkIHRvIFwiJHtocmVmfVwiLiBBIHJlc29sdmVkIGxvY2F0aW9uIGNhbm5vdCBzdGFydCB3aXRoIG11bHRpcGxlIHNsYXNoZXMuYCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbWF0Y2hlZFJvdXRlLm1hdGNoZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgTm8gbWF0Y2ggZm91bmQgZm9yIGxvY2F0aW9uIHdpdGggcGF0aCBcIiR7cmF3TG9jYXRpb259XCJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBsb2NhdGlvbk5vcm1hbGl6ZWQgaXMgYWx3YXlzIGEgbmV3IG9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKGxvY2F0aW9uTm9ybWFsaXplZCwgbWF0Y2hlZFJvdXRlLCB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGRlY29kZVBhcmFtcyhtYXRjaGVkUm91dGUucGFyYW1zKSxcclxuICAgICAgICAgICAgICAgIGhhc2g6IGRlY29kZShsb2NhdGlvbk5vcm1hbGl6ZWQuaGFzaCksXHJcbiAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgaHJlZixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXRjaGVyTG9jYXRpb247XHJcbiAgICAgICAgLy8gcGF0aCBjb3VsZCBiZSByZWxhdGl2ZSBpbiBvYmplY3QgYXMgd2VsbFxyXG4gICAgICAgIGlmICgncGF0aCcgaW4gcmF3TG9jYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgJ3BhcmFtcycgaW4gcmF3TG9jYXRpb24gJiZcclxuICAgICAgICAgICAgICAgICEoJ25hbWUnIGluIHJhd0xvY2F0aW9uKSAmJlxyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhlIHR5cGUgaXMgbmV2ZXJcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhd0xvY2F0aW9uLnBhcmFtcykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQYXRoIFwiJHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSB0eXBlIGlzIG5ldmVyXHJcbiAgICAgICAgICAgICAgICByYXdMb2NhdGlvbi5wYXRofVwiIHdhcyBwYXNzZWQgd2l0aCBwYXJhbXMgYnV0IHRoZXkgd2lsbCBiZSBpZ25vcmVkLiBVc2UgYSBuYW1lZCByb3V0ZSBhbG9uZ3NpZGUgcGFyYW1zIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0Y2hlckxvY2F0aW9uID0gYXNzaWduKHt9LCByYXdMb2NhdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogcGFyc2VVUkwocGFyc2VRdWVyeSQxLCByYXdMb2NhdGlvbi5wYXRoLCBjdXJyZW50TG9jYXRpb24ucGF0aCkucGF0aCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgYW55IG51bGxpc2ggcGFyYW1cclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGFyYW1zID0gYXNzaWduKHt9LCByYXdMb2NhdGlvbi5wYXJhbXMpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXRQYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQYXJhbXNba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFBhcmFtc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHBhc3MgZW5jb2RlZCB2YWx1ZXMgdG8gdGhlIG1hdGNoZXIsIHNvIGl0IGNhbiBwcm9kdWNlIGVuY29kZWQgcGF0aCBhbmQgZnVsbFBhdGhcclxuICAgICAgICAgICAgbWF0Y2hlckxvY2F0aW9uID0gYXNzaWduKHt9LCByYXdMb2NhdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBlbmNvZGVQYXJhbXMocmF3TG9jYXRpb24ucGFyYW1zKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgbG9jYXRpb24gcGFyYW1zIGFyZSBkZWNvZGVkLCB3ZSBuZWVkIHRvIGVuY29kZSB0aGVtIGluIGNhc2UgdGhlXHJcbiAgICAgICAgICAgIC8vIG1hdGNoZXIgbWVyZ2VzIHRoZSBwYXJhbXNcclxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLnBhcmFtcyA9IGVuY29kZVBhcmFtcyhjdXJyZW50TG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlZFJvdXRlID0gbWF0Y2hlci5yZXNvbHZlKG1hdGNoZXJMb2NhdGlvbiwgY3VycmVudExvY2F0aW9uKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gcmF3TG9jYXRpb24uaGFzaCB8fCAnJztcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhhc2ggJiYgIWhhc2guc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEEgXFxgaGFzaFxcYCBzaG91bGQgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIGNoYXJhY3RlciBcIiNcIi4gUmVwbGFjZSBcIiR7aGFzaH1cIiB3aXRoIFwiIyR7aGFzaH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlIG1hdGNoZXIgbWlnaHQgaGF2ZSBtZXJnZWQgY3VycmVudCBsb2NhdGlvbiBwYXJhbXMsIHNvXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBydW4gdGhlIGRlY29kaW5nIGFnYWluXHJcbiAgICAgICAgbWF0Y2hlZFJvdXRlLnBhcmFtcyA9IG5vcm1hbGl6ZVBhcmFtcyhkZWNvZGVQYXJhbXMobWF0Y2hlZFJvdXRlLnBhcmFtcykpO1xyXG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gc3RyaW5naWZ5VVJMKHN0cmluZ2lmeVF1ZXJ5JDEsIGFzc2lnbih7fSwgcmF3TG9jYXRpb24sIHtcclxuICAgICAgICAgICAgaGFzaDogZW5jb2RlSGFzaChoYXNoKSxcclxuICAgICAgICAgICAgcGF0aDogbWF0Y2hlZFJvdXRlLnBhdGgsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGNvbnN0IGhyZWYgPSByb3V0ZXJIaXN0b3J5LmNyZWF0ZUhyZWYoZnVsbFBhdGgpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aCgnLy8nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTG9jYXRpb24gXCIke3Jhd0xvY2F0aW9ufVwiIHJlc29sdmVkIHRvIFwiJHtocmVmfVwiLiBBIHJlc29sdmVkIGxvY2F0aW9uIGNhbm5vdCBzdGFydCB3aXRoIG11bHRpcGxlIHNsYXNoZXMuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW1hdGNoZWRSb3V0ZS5tYXRjaGVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTm8gbWF0Y2ggZm91bmQgZm9yIGxvY2F0aW9uIHdpdGggcGF0aCBcIiR7J3BhdGgnIGluIHJhd0xvY2F0aW9uID8gcmF3TG9jYXRpb24ucGF0aCA6IHJhd0xvY2F0aW9ufVwiYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzc2lnbih7XHJcbiAgICAgICAgICAgIGZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBoYXNoIGVuY29kZWQgc28gZnVsbFBhdGggaXMgZWZmZWN0aXZlbHkgcGF0aCArIGVuY29kZWRRdWVyeSArXHJcbiAgICAgICAgICAgIC8vIGhhc2hcclxuICAgICAgICAgICAgaGFzaCxcclxuICAgICAgICAgICAgcXVlcnk6IFxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBpcyB1c2luZyBhIGN1c3RvbSBxdWVyeSBsaWIgbGlrZSBxcywgd2UgbWlnaHQgaGF2ZVxyXG4gICAgICAgICAgICAvLyBuZXN0ZWQgb2JqZWN0cywgc28gd2Uga2VlcCB0aGUgcXVlcnkgYXMgaXMsIG1lYW5pbmcgaXQgY2FuIGNvbnRhaW5cclxuICAgICAgICAgICAgLy8gbnVtYmVycyBhdCBgJHJvdXRlLnF1ZXJ5YCwgYnV0IGF0IHRoZSBwb2ludCwgdGhlIHVzZXIgd2lsbCBoYXZlIHRvXHJcbiAgICAgICAgICAgIC8vIHVzZSB0aGVpciBvd24gdHlwZSBhbnl3YXkuXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzMyOCNpc3N1ZWNvbW1lbnQtNjQ5NDgxNTY3XHJcbiAgICAgICAgICAgIHN0cmluZ2lmeVF1ZXJ5JDEgPT09IHN0cmluZ2lmeVF1ZXJ5XHJcbiAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZVF1ZXJ5KHJhd0xvY2F0aW9uLnF1ZXJ5KVxyXG4gICAgICAgICAgICAgICAgOiAocmF3TG9jYXRpb24ucXVlcnkgfHwge30pLFxyXG4gICAgICAgIH0sIG1hdGNoZWRSb3V0ZSwge1xyXG4gICAgICAgICAgICByZWRpcmVjdGVkRnJvbTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBocmVmLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbG9jYXRpb25Bc09iamVjdCh0bykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgID8gcGFyc2VVUkwocGFyc2VRdWVyeSQxLCB0bywgY3VycmVudFJvdXRlLnZhbHVlLnBhdGgpXHJcbiAgICAgICAgICAgIDogYXNzaWduKHt9LCB0byk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbih0bywgZnJvbSkge1xyXG4gICAgICAgIGlmIChwZW5kaW5nTG9jYXRpb24gIT09IHRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSb3V0ZXJFcnJvcig4IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9DQU5DRUxMRUQgKi8sIHtcclxuICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaCh0bykge1xyXG4gICAgICAgIHJldHVybiBwdXNoV2l0aFJlZGlyZWN0KHRvKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2UodG8pIHtcclxuICAgICAgICByZXR1cm4gcHVzaChhc3NpZ24obG9jYXRpb25Bc09iamVjdCh0byksIHsgcmVwbGFjZTogdHJ1ZSB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZWRpcmVjdFJlY29yZCh0bykge1xyXG4gICAgICAgIGNvbnN0IGxhc3RNYXRjaGVkID0gdG8ubWF0Y2hlZFt0by5tYXRjaGVkLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChsYXN0TWF0Y2hlZCAmJiBsYXN0TWF0Y2hlZC5yZWRpcmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHJlZGlyZWN0IH0gPSBsYXN0TWF0Y2hlZDtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldExvY2F0aW9uID0gdHlwZW9mIHJlZGlyZWN0ID09PSAnZnVuY3Rpb24nID8gcmVkaXJlY3QodG8pIDogcmVkaXJlY3Q7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGFyZ2V0TG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFyZ2V0TG9jYXRpb24uaW5jbHVkZXMoJz8nKSB8fCBuZXdUYXJnZXRMb2NhdGlvbi5pbmNsdWRlcygnIycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKG5ld1RhcmdldExvY2F0aW9uID0gbG9jYXRpb25Bc09iamVjdChuZXdUYXJnZXRMb2NhdGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gZm9yY2UgZW1wdHkgcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHBhdGg6IG5ld1RhcmdldExvY2F0aW9uIH07XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBmb3JjZSBlbXB0eSBwYXJhbXMgd2hlbiBhIHN0cmluZyBpcyBwYXNzZWQgdG8gbGV0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcm91dGVyIHBhcnNlIHRoZW0gYWdhaW5cclxuICAgICAgICAgICAgICAgIG5ld1RhcmdldExvY2F0aW9uLnBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICEoJ3BhdGgnIGluIG5ld1RhcmdldExvY2F0aW9uKSAmJlxyXG4gICAgICAgICAgICAgICAgISgnbmFtZScgaW4gbmV3VGFyZ2V0TG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHJlZGlyZWN0IGZvdW5kOlxcbiR7SlNPTi5zdHJpbmdpZnkobmV3VGFyZ2V0TG9jYXRpb24sIG51bGwsIDIpfVxcbiB3aGVuIG5hdmlnYXRpbmcgdG8gXCIke3RvLmZ1bGxQYXRofVwiLiBBIHJlZGlyZWN0IG11c3QgY29udGFpbiBhIG5hbWUgb3IgcGF0aC4gVGhpcyB3aWxsIGJyZWFrIGluIHByb2R1Y3Rpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVkaXJlY3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB0by5xdWVyeSxcclxuICAgICAgICAgICAgICAgIGhhc2g6IHRvLmhhc2gsXHJcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB0cmFuc2ZlcnJpbmcgcGFyYW1zIGlmIHRoZSByZWRpcmVjdCBoYXMgYSBwYXRoXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6ICdwYXRoJyBpbiBuZXdUYXJnZXRMb2NhdGlvbiA/IHt9IDogdG8ucGFyYW1zLFxyXG4gICAgICAgICAgICB9LCBuZXdUYXJnZXRMb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaFdpdGhSZWRpcmVjdCh0bywgcmVkaXJlY3RlZEZyb20pIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRMb2NhdGlvbiA9IChwZW5kaW5nTG9jYXRpb24gPSByZXNvbHZlKHRvKSk7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IGN1cnJlbnRSb3V0ZS52YWx1ZTtcclxuICAgICAgICBjb25zdCBkYXRhID0gdG8uc3RhdGU7XHJcbiAgICAgICAgY29uc3QgZm9yY2UgPSB0by5mb3JjZTtcclxuICAgICAgICAvLyB0byBjb3VsZCBiZSBhIHN0cmluZyB3aGVyZSBgcmVwbGFjZWAgaXMgYSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHJlcGxhY2UgPSB0by5yZXBsYWNlID09PSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHNob3VsZFJlZGlyZWN0ID0gaGFuZGxlUmVkaXJlY3RSZWNvcmQodGFyZ2V0TG9jYXRpb24pO1xyXG4gICAgICAgIGlmIChzaG91bGRSZWRpcmVjdClcclxuICAgICAgICAgICAgcmV0dXJuIHB1c2hXaXRoUmVkaXJlY3QoYXNzaWduKGxvY2F0aW9uQXNPYmplY3Qoc2hvdWxkUmVkaXJlY3QpLCB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogdHlwZW9mIHNob3VsZFJlZGlyZWN0ID09PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICAgID8gYXNzaWduKHt9LCBkYXRhLCBzaG91bGRSZWRpcmVjdC5zdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICA6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBmb3JjZSxcclxuICAgICAgICAgICAgICAgIHJlcGxhY2UsXHJcbiAgICAgICAgICAgIH0pLCBcclxuICAgICAgICAgICAgLy8ga2VlcCBvcmlnaW5hbCByZWRpcmVjdGVkRnJvbSBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20gfHwgdGFyZ2V0TG9jYXRpb24pO1xyXG4gICAgICAgIC8vIGlmIGl0IHdhcyBhIHJlZGlyZWN0IHdlIGFscmVhZHkgY2FsbGVkIGBwdXNoV2l0aFJlZGlyZWN0YCBhYm92ZVxyXG4gICAgICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0YXJnZXRMb2NhdGlvbjtcclxuICAgICAgICB0b0xvY2F0aW9uLnJlZGlyZWN0ZWRGcm9tID0gcmVkaXJlY3RlZEZyb207XHJcbiAgICAgICAgbGV0IGZhaWx1cmU7XHJcbiAgICAgICAgaWYgKCFmb3JjZSAmJiBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5JDEsIGZyb20sIHRhcmdldExvY2F0aW9uKSkge1xyXG4gICAgICAgICAgICBmYWlsdXJlID0gY3JlYXRlUm91dGVyRXJyb3IoMTYgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0RVUExJQ0FURUQgKi8sIHsgdG86IHRvTG9jYXRpb24sIGZyb20gfSk7XHJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgc2Nyb2xsIHRvIGFsbG93IHNjcm9sbGluZyB0byB0aGUgc2FtZSBhbmNob3JcclxuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsKGZyb20sIGZyb20sIFxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcHVzaCwgdGhlIG9ubHkgd2F5IGZvciBpdCB0byBiZSB0cmlnZ2VyZWQgZnJvbSBhXHJcbiAgICAgICAgICAgIC8vIGhpc3RvcnkubGlzdGVuIGlzIHdpdGggYSByZWRpcmVjdCwgd2hpY2ggbWFrZXMgaXQgYmVjb21lIGEgcHVzaFxyXG4gICAgICAgICAgICB0cnVlLCBcclxuICAgICAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgdGhlIGZpcnN0IG5hdmlnYXRpb24gYmVjYXVzZSB0aGUgaW5pdGlhbCBsb2NhdGlvblxyXG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgbWFudWFsbHkgbmF2aWdhdGVkIHRvXHJcbiAgICAgICAgICAgIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChmYWlsdXJlID8gUHJvbWlzZS5yZXNvbHZlKGZhaWx1cmUpIDogbmF2aWdhdGUodG9Mb2NhdGlvbiwgZnJvbSkpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IpXHJcbiAgICAgICAgICAgID8gLy8gbmF2aWdhdGlvbiByZWRpcmVjdHMgc3RpbGwgbWFyayB0aGUgcm91dGVyIGFzIHJlYWR5XHJcbiAgICAgICAgICAgICAgICBpc05hdmlnYXRpb25GYWlsdXJlKGVycm9yLCAyIC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9HVUFSRF9SRURJUkVDVCAqLylcclxuICAgICAgICAgICAgICAgICAgICA/IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBtYXJrQXNSZWFkeShlcnJvcikgLy8gYWxzbyByZXR1cm5zIHRoZSBlcnJvclxyXG4gICAgICAgICAgICA6IC8vIHJlamVjdCBhbnkgdW5rbm93biBlcnJvclxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVycm9yKGVycm9yLCB0b0xvY2F0aW9uLCBmcm9tKSlcclxuICAgICAgICAgICAgLnRoZW4oKGZhaWx1cmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hdmlnYXRpb25GYWlsdXJlKGZhaWx1cmUsIDIgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHJlZGlyZWN0aW5nIHRvIHRoZSBzYW1lIGxvY2F0aW9uIHdlIHdlcmUgYWxyZWFkeSBhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5JDEsIHJlc29sdmUoZmFpbHVyZS50byksIHRvTG9jYXRpb24pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBoYXZlIGRvbmUgaXQgYSBjb3VwbGUgb2YgdGltZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYWRkZWQgb25seSBpbiBkZXZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlZGlyZWN0ZWRGcm9tLl9jb3VudCA9IHJlZGlyZWN0ZWRGcm9tLl9jb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20uX2NvdW50ICsgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxKSA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYERldGVjdGVkIGFuIGluZmluaXRlIHJlZGlyZWN0aW9uIGluIGEgbmF2aWdhdGlvbiBndWFyZCB3aGVuIGdvaW5nIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3RvTG9jYXRpb24uZnVsbFBhdGh9XCIuIEFib3J0aW5nIHRvIGF2b2lkIGEgU3RhY2sgT3ZlcmZsb3cuIFRoaXMgd2lsbCBicmVhayBpbiBwcm9kdWN0aW9uIGlmIG5vdCBmaXhlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW5maW5pdGUgcmVkaXJlY3QgaW4gbmF2aWdhdGlvbiBndWFyZCcpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1c2hXaXRoUmVkaXJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgYW4gZXhpc3RpbmcgcmVwbGFjZW1lbnQgYnV0IGFsbG93IHRoZSByZWRpcmVjdCB0byBvdmVycmlkZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGxvY2F0aW9uQXNPYmplY3QoZmFpbHVyZS50byksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHR5cGVvZiBmYWlsdXJlLnRvID09PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc3NpZ24oe30sIGRhdGEsIGZhaWx1cmUudG8uc3RhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgcmVkaXJlY3RlZEZyb20gaWYgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20gfHwgdG9Mb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmYWlsIHdlIGRvbid0IGZpbmFsaXplIHRoZSBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlID0gZmluYWxpemVOYXZpZ2F0aW9uKHRvTG9jYXRpb24sIGZyb20sIHRydWUsIHJlcGxhY2UsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyaWdnZXJBZnRlckVhY2godG9Mb2NhdGlvbiwgZnJvbSwgZmFpbHVyZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gcmVqZWN0IGFuZCBza2lwIGFsbCBuYXZpZ2F0aW9uIGd1YXJkcyBpZiBhIG5ldyBuYXZpZ2F0aW9uIGhhcHBlbmVkXHJcbiAgICAgKiBAcGFyYW0gdG9cclxuICAgICAqIEBwYXJhbSBmcm9tXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uQW5kUmVqZWN0KHRvLCBmcm9tKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbih0bywgZnJvbSk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yID8gUHJvbWlzZS5yZWplY3QoZXJyb3IpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiByZWZhY3RvciB0aGUgd2hvbGUgYmVmb3JlIGd1YXJkcyBieSBpbnRlcm5hbGx5IHVzaW5nIHJvdXRlci5iZWZvcmVFYWNoXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgZnJvbSkge1xyXG4gICAgICAgIGxldCBndWFyZHM7XHJcbiAgICAgICAgY29uc3QgW2xlYXZpbmdSZWNvcmRzLCB1cGRhdGluZ1JlY29yZHMsIGVudGVyaW5nUmVjb3Jkc10gPSBleHRyYWN0Q2hhbmdpbmdSZWNvcmRzKHRvLCBmcm9tKTtcclxuICAgICAgICAvLyBhbGwgY29tcG9uZW50cyBoZXJlIGhhdmUgYmVlbiByZXNvbHZlZCBvbmNlIGJlY2F1c2Ugd2UgYXJlIGxlYXZpbmdcclxuICAgICAgICBndWFyZHMgPSBleHRyYWN0Q29tcG9uZW50c0d1YXJkcyhsZWF2aW5nUmVjb3Jkcy5yZXZlcnNlKCksICdiZWZvcmVSb3V0ZUxlYXZlJywgdG8sIGZyb20pO1xyXG4gICAgICAgIC8vIGxlYXZpbmdSZWNvcmRzIGlzIGFscmVhZHkgcmV2ZXJzZWRcclxuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBsZWF2aW5nUmVjb3Jkcykge1xyXG4gICAgICAgICAgICByZWNvcmQubGVhdmVHdWFyZHMuZm9yRWFjaChndWFyZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2sgPSBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbkFuZFJlamVjdC5iaW5kKG51bGwsIHRvLCBmcm9tKTtcclxuICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XHJcbiAgICAgICAgLy8gcnVuIHRoZSBxdWV1ZSBvZiBwZXIgcm91dGUgYmVmb3JlUm91dGVMZWF2ZSBndWFyZHNcclxuICAgICAgICByZXR1cm4gKHJ1bkd1YXJkUXVldWUoZ3VhcmRzKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGdsb2JhbCBndWFyZHMgYmVmb3JlRWFjaFxyXG4gICAgICAgICAgICBndWFyZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBndWFyZCBvZiBiZWZvcmVHdWFyZHMubGlzdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGluIGNvbXBvbmVudHMgYmVmb3JlUm91dGVVcGRhdGVcclxuICAgICAgICAgICAgZ3VhcmRzID0gZXh0cmFjdENvbXBvbmVudHNHdWFyZHModXBkYXRpbmdSZWNvcmRzLCAnYmVmb3JlUm91dGVVcGRhdGUnLCB0bywgZnJvbSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHVwZGF0aW5nUmVjb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkLnVwZGF0ZUd1YXJkcy5mb3JFYWNoKGd1YXJkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3VhcmRzLnB1c2goY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2spO1xyXG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSByb3V0ZSBiZWZvcmVFbnRlclxyXG4gICAgICAgICAgICBndWFyZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgdG8ubWF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHRyaWdnZXIgYmVmb3JlRW50ZXIgb24gcmV1c2VkIHZpZXdzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmJlZm9yZUVudGVyICYmICFmcm9tLm1hdGNoZWQuaW5jbHVkZXMocmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHJlY29yZC5iZWZvcmVFbnRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVFbnRlciBvZiByZWNvcmQuYmVmb3JlRW50ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGJlZm9yZUVudGVyLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihyZWNvcmQuYmVmb3JlRW50ZXIsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcclxuICAgICAgICAgICAgLy8gcnVuIHRoZSBxdWV1ZSBvZiBwZXIgcm91dGUgYmVmb3JlRW50ZXIgZ3VhcmRzXHJcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IHRvLm1hdGNoZWQgaXMgbm9ybWFsaXplZCBhbmQgZG9lcyBub3QgY29udGFpbiBhbnkgKCkgPT4gUHJvbWlzZTxDb21wb25lbnQ+XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIGVudGVyQ2FsbGJhY2tzLCB0aGVzZSBhcmUgYWRkZWQgYnkgZXh0cmFjdENvbXBvbmVudHNHdWFyZHNcclxuICAgICAgICAgICAgdG8ubWF0Y2hlZC5mb3JFYWNoKHJlY29yZCA9PiAocmVjb3JkLmVudGVyQ2FsbGJhY2tzID0ge30pKTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaW4tY29tcG9uZW50IGJlZm9yZVJvdXRlRW50ZXJcclxuICAgICAgICAgICAgZ3VhcmRzID0gZXh0cmFjdENvbXBvbmVudHNHdWFyZHMoZW50ZXJpbmdSZWNvcmRzLCAnYmVmb3JlUm91dGVFbnRlcicsIHRvLCBmcm9tKTtcclxuICAgICAgICAgICAgZ3VhcmRzLnB1c2goY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2spO1xyXG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGdsb2JhbCBndWFyZHMgYmVmb3JlUmVzb2x2ZVxyXG4gICAgICAgICAgICBndWFyZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBndWFyZCBvZiBiZWZvcmVSZXNvbHZlR3VhcmRzLmxpc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihndWFyZCwgdG8sIGZyb20pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XHJcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gY2F0Y2ggYW55IG5hdmlnYXRpb24gY2FuY2VsZWRcclxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBpc05hdmlnYXRpb25GYWlsdXJlKGVyciwgOCAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fQ0FOQ0VMTEVEICovKVxyXG4gICAgICAgICAgICA/IGVyclxyXG4gICAgICAgICAgICA6IFByb21pc2UucmVqZWN0KGVycikpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJBZnRlckVhY2godG8sIGZyb20sIGZhaWx1cmUpIHtcclxuICAgICAgICAvLyBuYXZpZ2F0aW9uIGlzIGNvbmZpcm1lZCwgY2FsbCBhZnRlckd1YXJkc1xyXG4gICAgICAgIC8vIFRPRE86IHdyYXAgd2l0aCBlcnJvciBoYW5kbGVyc1xyXG4gICAgICAgIGZvciAoY29uc3QgZ3VhcmQgb2YgYWZ0ZXJHdWFyZHMubGlzdCgpKVxyXG4gICAgICAgICAgICBndWFyZCh0bywgZnJvbSwgZmFpbHVyZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIC0gQ2xlYW5zIHVwIGFueSBuYXZpZ2F0aW9uIGd1YXJkc1xyXG4gICAgICogLSBDaGFuZ2VzIHRoZSB1cmwgaWYgbmVjZXNzYXJ5XHJcbiAgICAgKiAtIENhbGxzIHRoZSBzY3JvbGxCZWhhdmlvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZU5hdmlnYXRpb24odG9Mb2NhdGlvbiwgZnJvbSwgaXNQdXNoLCByZXBsYWNlLCBkYXRhKSB7XHJcbiAgICAgICAgLy8gYSBtb3JlIHJlY2VudCBuYXZpZ2F0aW9uIHRvb2sgcGxhY2VcclxuICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uKHRvTG9jYXRpb24sIGZyb20pO1xyXG4gICAgICAgIGlmIChlcnJvcilcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIC8vIG9ubHkgY29uc2lkZXIgYXMgcHVzaCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgbmF2aWdhdGlvblxyXG4gICAgICAgIGNvbnN0IGlzRmlyc3ROYXZpZ2F0aW9uID0gZnJvbSA9PT0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9ICFpc0Jyb3dzZXIgPyB7fSA6IGhpc3Rvcnkuc3RhdGU7XHJcbiAgICAgICAgLy8gY2hhbmdlIFVSTCBvbmx5IGlmIHRoZSB1c2VyIGRpZCBhIHB1c2gvcmVwbGFjZSBhbmQgaWYgaXQncyBub3QgdGhlIGluaXRpYWwgbmF2aWdhdGlvbiBiZWNhdXNlXHJcbiAgICAgICAgLy8gaXQncyBqdXN0IHJlZmxlY3RpbmcgdGhlIHVybFxyXG4gICAgICAgIGlmIChpc1B1c2gpIHtcclxuICAgICAgICAgICAgLy8gb24gdGhlIGluaXRpYWwgbmF2aWdhdGlvbiwgd2Ugd2FudCB0byByZXVzZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIGZyb21cclxuICAgICAgICAgICAgLy8gaGlzdG9yeSBzdGF0ZSBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgaWYgKHJlcGxhY2UgfHwgaXNGaXJzdE5hdmlnYXRpb24pXHJcbiAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LnJlcGxhY2UodG9Mb2NhdGlvbi5mdWxsUGF0aCwgYXNzaWduKHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IGlzRmlyc3ROYXZpZ2F0aW9uICYmIHN0YXRlICYmIHN0YXRlLnNjcm9sbCxcclxuICAgICAgICAgICAgICAgIH0sIGRhdGEpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5wdXNoKHRvTG9jYXRpb24uZnVsbFBhdGgsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhY2NlcHQgY3VycmVudCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgY3VycmVudFJvdXRlLnZhbHVlID0gdG9Mb2NhdGlvbjtcclxuICAgICAgICBoYW5kbGVTY3JvbGwodG9Mb2NhdGlvbiwgZnJvbSwgaXNQdXNoLCBpc0ZpcnN0TmF2aWdhdGlvbik7XHJcbiAgICAgICAgbWFya0FzUmVhZHkoKTtcclxuICAgIH1cclxuICAgIGxldCByZW1vdmVIaXN0b3J5TGlzdGVuZXI7XHJcbiAgICAvLyBhdHRhY2ggbGlzdGVuZXIgdG8gaGlzdG9yeSB0byB0cmlnZ2VyIG5hdmlnYXRpb25zXHJcbiAgICBmdW5jdGlvbiBzZXR1cExpc3RlbmVycygpIHtcclxuICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIHVwIGxpc3RlbmVycyB0d2ljZSBkdWUgdG8gYW4gaW52YWxpZCBmaXJzdCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgaWYgKHJlbW92ZUhpc3RvcnlMaXN0ZW5lcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHJlbW92ZUhpc3RvcnlMaXN0ZW5lciA9IHJvdXRlckhpc3RvcnkubGlzdGVuKCh0bywgX2Zyb20sIGluZm8pID0+IHtcclxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIubGlzdGVuaW5nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgYSByZWRpcmVjdCByb3V0ZSBiZWNhdXNlIGl0IHdhcyBpbiBoaXN0b3J5XHJcbiAgICAgICAgICAgIGNvbnN0IHRvTG9jYXRpb24gPSByZXNvbHZlKHRvKTtcclxuICAgICAgICAgICAgLy8gZHVlIHRvIGR5bmFtaWMgcm91dGluZywgYW5kIHRvIGhhc2ggaGlzdG9yeSB3aXRoIG1hbnVhbCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgIC8vIChtYW51YWxseSBjaGFuZ2luZyB0aGUgdXJsIG9yIGNhbGxpbmcgaGlzdG9yeS5oYXNoID0gJyMvc29tZXdoZXJlJyksXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGNvdWxkIGJlIGEgcmVkaXJlY3QgcmVjb3JkIGluIGhpc3RvcnlcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVkaXJlY3QgPSBoYW5kbGVSZWRpcmVjdFJlY29yZCh0b0xvY2F0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoV2l0aFJlZGlyZWN0KGFzc2lnbihzaG91bGRSZWRpcmVjdCwgeyByZXBsYWNlOiB0cnVlIH0pLCB0b0xvY2F0aW9uKS5jYXRjaChub29wKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwZW5kaW5nTG9jYXRpb24gPSB0b0xvY2F0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gY3VycmVudFJvdXRlLnZhbHVlO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUgbW92ZWQgdG8gd2ViIGhpc3Rvcnk/XHJcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgICAgIHNhdmVTY3JvbGxQb3NpdGlvbihnZXRTY3JvbGxLZXkoZnJvbS5mdWxsUGF0aCwgaW5mby5kZWx0YSksIGNvbXB1dGVTY3JvbGxQb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuYXZpZ2F0ZSh0b0xvY2F0aW9uLCBmcm9tKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIDQgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0FCT1JURUQgKi8gfCA4IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9DQU5DRUxMRUQgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIDIgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgY291bGQgY2FsbCBpZiAoaW5mby5kZWx0YSkgcm91dGVySGlzdG9yeS5nbygtaW5mby5kZWx0YSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZSkgYnV0IHRoaXMgaXMgYnVnIHByb25lIGFzIHdlIGhhdmUgbm8gd2F5IHRvIHdhaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvbiB0byBiZSBmaW5pc2hlZCBiZWZvcmUgY2FsbGluZyBwdXNoV2l0aFJlZGlyZWN0LiBVc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc2V0VGltZW91dCBvZiAxNm1zIHNlZW1zIHRvIHdvcmsgYnV0IHRoZXJlIGlzIG5vIGd1YXJhbnRlZSBmb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB0byB3b3JrIG9uIGV2ZXJ5IGJyb3dzZXIuIFNvIGluc3RlYWQgd2UgZG8gbm90IHJlc3RvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBhbmQgdHJpZ2dlciBhIG5ldyBuYXZpZ2F0aW9uIGFzIHJlcXVlc3RlZCBieSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYXZpZ2F0aW9uIGd1YXJkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBlcnJvciBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgcm91dGVyLnB1c2ggd2UganVzdCB3YW50IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2luZyB0aGUgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2l0aFJlZGlyZWN0KGVycm9yLnRvLCB0b0xvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgYW4gdW5jYXVnaHQgcmVqZWN0aW9uLCBsZXQgcHVzaCBjYWxsIHRyaWdnZXJFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZmFpbHVyZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbnVhbCBjaGFuZ2UgaW4gaGFzaCBoaXN0b3J5ICM5MTYgZW5kaW5nIHVwIGluIHRoZSBVUkwgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5naW5nLCBidXQgaXQgd2FzIGNoYW5nZWQgYnkgdGhlIG1hbnVhbCB1cmwgY2hhbmdlLCBzbyB3ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIG1hbnVhbGx5IGNoYW5nZSBpdCBvdXJzZWx2ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZmFpbHVyZSwgNCAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fQUJPUlRFRCAqLyB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNiAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fRFVQTElDQVRFRCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpbmZvLmRlbHRhICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnR5cGUgPT09IE5hdmlnYXRpb25UeXBlLnBvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5nbygtMSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIHRoZSB0aGVuIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHJlc3RvcmUgaGlzdG9yeSBvbiB1bmtub3duIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC1pbmZvLmRlbHRhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1bnJlY29nbml6ZWQgZXJyb3IsIHRyYW5zZmVyIHRvIHRoZSBnbG9iYWwgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJFcnJvcihlcnJvciwgdG9Mb2NhdGlvbiwgZnJvbSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoZmFpbHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZU5hdmlnYXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIG5hdmlnYXRpb24sIGFsbCBtYXRjaGVkIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvTG9jYXRpb24sIGZyb20sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHJldmVydCB0aGUgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5kZWx0YSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG5ldyBuYXZpZ2F0aW9uIGhhcyBiZWVuIHRyaWdnZXJlZCwgc28gd2UgZG8gbm90IHdhbnQgdG8gcmV2ZXJ0LCB0aGF0IHdpbGwgY2hhbmdlIHRoZSBjdXJyZW50IGhpc3RvcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW50cnkgd2hpbGUgYSBkaWZmZXJlbnQgcm91dGUgaXMgZGlzcGxheWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc05hdmlnYXRpb25GYWlsdXJlKGZhaWx1cmUsIDggLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0NBTkNFTExFRCAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5nbygtaW5mby5kZWx0YSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmZvLnR5cGUgPT09IE5hdmlnYXRpb25UeXBlLnBvcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05hdmlnYXRpb25GYWlsdXJlKGZhaWx1cmUsIDQgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0FCT1JURUQgKi8gfCAxNiAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fRFVQTElDQVRFRCAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsIGNoYW5nZSBpbiBoYXNoIGhpc3RvcnkgIzkxNlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGxpa2UgYSBwdXNoIGJ1dCBsYWNrcyB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC0xLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckFmdGVyRWFjaCh0b0xvY2F0aW9uLCBmcm9tLCBmYWlsdXJlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChub29wKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCBFcnJvcnNcclxuICAgIGxldCByZWFkeUhhbmRsZXJzID0gdXNlQ2FsbGJhY2tzKCk7XHJcbiAgICBsZXQgZXJyb3JIYW5kbGVycyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgbGV0IHJlYWR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGVycm9ySGFuZGxlcnMgYWRkZWQgdmlhIG9uRXJyb3IgYW5kIHRocm93cyB0aGUgZXJyb3IgYXMgd2VsbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlcnJvciAtIGVycm9yIHRvIHRocm93XHJcbiAgICAgKiBAcGFyYW0gdG8gLSBsb2NhdGlvbiB3ZSB3ZXJlIG5hdmlnYXRpbmcgdG8gd2hlbiB0aGUgZXJyb3IgaGFwcGVuZWRcclxuICAgICAqIEBwYXJhbSBmcm9tIC0gbG9jYXRpb24gd2Ugd2VyZSBuYXZpZ2F0aW5nIGZyb20gd2hlbiB0aGUgZXJyb3IgaGFwcGVuZWRcclxuICAgICAqIEByZXR1cm5zIHRoZSBlcnJvciBhcyBhIHJlamVjdGVkIHByb21pc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJpZ2dlckVycm9yKGVycm9yLCB0bywgZnJvbSkge1xyXG4gICAgICAgIG1hcmtBc1JlYWR5KGVycm9yKTtcclxuICAgICAgICBjb25zdCBsaXN0ID0gZXJyb3JIYW5kbGVycy5saXN0KCk7XHJcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZXJyb3IsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzUmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHJlYWR5ICYmIGN1cnJlbnRSb3V0ZS52YWx1ZSAhPT0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRClcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlYWR5SGFuZGxlcnMuYWRkKFtyZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcmtBc1JlYWR5KGVycikge1xyXG4gICAgICAgIGlmICghcmVhZHkpIHtcclxuICAgICAgICAgICAgLy8gc3RpbGwgbm90IHJlYWR5IGlmIGFuIGVycm9yIGhhcHBlbmVkXHJcbiAgICAgICAgICAgIHJlYWR5ID0gIWVycjtcclxuICAgICAgICAgICAgc2V0dXBMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgcmVhZHlIYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgLmxpc3QoKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKFtyZXNvbHZlLCByZWplY3RdKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpKTtcclxuICAgICAgICAgICAgcmVhZHlIYW5kbGVycy5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgfVxyXG4gICAgLy8gU2Nyb2xsIGJlaGF2aW9yXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwodG8sIGZyb20sIGlzUHVzaCwgaXNGaXJzdE5hdmlnYXRpb24pIHtcclxuICAgICAgICBjb25zdCB7IHNjcm9sbEJlaGF2aW9yIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8ICFzY3JvbGxCZWhhdmlvcilcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gKCFpc1B1c2ggJiYgZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihnZXRTY3JvbGxLZXkodG8uZnVsbFBhdGgsIDApKSkgfHxcclxuICAgICAgICAgICAgKChpc0ZpcnN0TmF2aWdhdGlvbiB8fCAhaXNQdXNoKSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZS5zY3JvbGwpIHx8XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gc2Nyb2xsQmVoYXZpb3IodG8sIGZyb20sIHNjcm9sbFBvc2l0aW9uKSlcclxuICAgICAgICAgICAgLnRoZW4ocG9zaXRpb24gPT4gcG9zaXRpb24gJiYgc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbikpXHJcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdHJpZ2dlckVycm9yKGVyciwgdG8sIGZyb20pKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGdvID0gKGRlbHRhKSA9PiByb3V0ZXJIaXN0b3J5LmdvKGRlbHRhKTtcclxuICAgIGxldCBzdGFydGVkO1xyXG4gICAgY29uc3QgaW5zdGFsbGVkQXBwcyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJvdXRlciA9IHtcclxuICAgICAgICBjdXJyZW50Um91dGUsXHJcbiAgICAgICAgbGlzdGVuaW5nOiB0cnVlLFxyXG4gICAgICAgIGFkZFJvdXRlLFxyXG4gICAgICAgIHJlbW92ZVJvdXRlLFxyXG4gICAgICAgIGhhc1JvdXRlLFxyXG4gICAgICAgIGdldFJvdXRlcyxcclxuICAgICAgICByZXNvbHZlLFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgcHVzaCxcclxuICAgICAgICByZXBsYWNlLFxyXG4gICAgICAgIGdvLFxyXG4gICAgICAgIGJhY2s6ICgpID0+IGdvKC0xKSxcclxuICAgICAgICBmb3J3YXJkOiAoKSA9PiBnbygxKSxcclxuICAgICAgICBiZWZvcmVFYWNoOiBiZWZvcmVHdWFyZHMuYWRkLFxyXG4gICAgICAgIGJlZm9yZVJlc29sdmU6IGJlZm9yZVJlc29sdmVHdWFyZHMuYWRkLFxyXG4gICAgICAgIGFmdGVyRWFjaDogYWZ0ZXJHdWFyZHMuYWRkLFxyXG4gICAgICAgIG9uRXJyb3I6IGVycm9ySGFuZGxlcnMuYWRkLFxyXG4gICAgICAgIGlzUmVhZHksXHJcbiAgICAgICAgaW5zdGFsbChhcHApIHtcclxuICAgICAgICAgICAgY29uc3Qgcm91dGVyID0gdGhpcztcclxuICAgICAgICAgICAgYXBwLmNvbXBvbmVudCgnUm91dGVyTGluaycsIFJvdXRlckxpbmspO1xyXG4gICAgICAgICAgICBhcHAuY29tcG9uZW50KCdSb3V0ZXJWaWV3JywgUm91dGVyVmlldyk7XHJcbiAgICAgICAgICAgIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy4kcm91dGVyID0gcm91dGVyO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCAnJHJvdXRlJywge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdW5yZWYoY3VycmVudFJvdXRlKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaW5pdGlhbCBuYXZpZ2F0aW9uIGlzIG9ubHkgbmVjZXNzYXJ5IG9uIGNsaWVudCwgb24gc2VydmVyIGl0IGRvZXNuJ3RcclxuICAgICAgICAgICAgLy8gbWFrZSBzZW5zZSBiZWNhdXNlIGl0IHdpbGwgY3JlYXRlIGFuIGV4dHJhIHVubmVjZXNzYXJ5IG5hdmlnYXRpb24gYW5kIGNvdWxkXHJcbiAgICAgICAgICAgIC8vIGxlYWQgdG8gcHJvYmxlbXNcclxuICAgICAgICAgICAgaWYgKGlzQnJvd3NlciAmJlxyXG4gICAgICAgICAgICAgICAgLy8gdXNlZCBmb3IgdGhlIGluaXRpYWwgbmF2aWdhdGlvbiBjbGllbnQgc2lkZSB0byBhdm9pZCBwdXNoaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSB0aW1lcyB3aGVuIHRoZSByb3V0ZXIgaXMgdXNlZCBpbiBtdWx0aXBsZSBhcHBzXHJcbiAgICAgICAgICAgICAgICAhc3RhcnRlZCAmJlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvdXRlLnZhbHVlID09PSBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzZWUgYWJvdmVcclxuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHVzaChyb3V0ZXJIaXN0b3J5LmxvY2F0aW9uKS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ1VuZXhwZWN0ZWQgZXJyb3Igd2hlbiBzdGFydGluZyB0aGUgcm91dGVyOicsIGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWFjdGl2ZVJvdXRlID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBrZXkgbWF0Y2hlc1xyXG4gICAgICAgICAgICAgICAgcmVhY3RpdmVSb3V0ZVtrZXldID0gY29tcHV0ZWQoKCkgPT4gY3VycmVudFJvdXRlLnZhbHVlW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFwcC5wcm92aWRlKHJvdXRlcktleSwgcm91dGVyKTtcclxuICAgICAgICAgICAgYXBwLnByb3ZpZGUocm91dGVMb2NhdGlvbktleSwgcmVhY3RpdmUocmVhY3RpdmVSb3V0ZSkpO1xyXG4gICAgICAgICAgICBhcHAucHJvdmlkZShyb3V0ZXJWaWV3TG9jYXRpb25LZXksIGN1cnJlbnRSb3V0ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVubW91bnRBcHAgPSBhcHAudW5tb3VudDtcclxuICAgICAgICAgICAgaW5zdGFsbGVkQXBwcy5hZGQoYXBwKTtcclxuICAgICAgICAgICAgYXBwLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWRBcHBzLmRlbGV0ZShhcHApO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvdXRlciBpcyBub3QgYXR0YWNoZWQgdG8gYW4gYXBwIGFueW1vcmVcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRBcHBzLnNpemUgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSB0aGUgY3VycmVudCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0xvY2F0aW9uID0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVIaXN0b3J5TGlzdGVuZXIgJiYgcmVtb3ZlSGlzdG9yeUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGlzdG9yeUxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGUudmFsdWUgPSBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5tb3VudEFwcCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHByb2JhYmx5IG5lZWRzIHRvIGJlIHVwZGF0ZWQgc28gaXQgY2FuIGJlIHVzZWQgYnkgdnVlLXRlcm11aVxyXG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIGlzQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgYWRkRGV2dG9vbHMoYXBwLCByb3V0ZXIsIG1hdGNoZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gcm91dGVyO1xyXG59XHJcbmZ1bmN0aW9uIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKSB7XHJcbiAgICByZXR1cm4gZ3VhcmRzLnJlZHVjZSgocHJvbWlzZSwgZ3VhcmQpID0+IHByb21pc2UudGhlbigoKSA9PiBndWFyZCgpKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RDaGFuZ2luZ1JlY29yZHModG8sIGZyb20pIHtcclxuICAgIGNvbnN0IGxlYXZpbmdSZWNvcmRzID0gW107XHJcbiAgICBjb25zdCB1cGRhdGluZ1JlY29yZHMgPSBbXTtcclxuICAgIGNvbnN0IGVudGVyaW5nUmVjb3JkcyA9IFtdO1xyXG4gICAgY29uc3QgbGVuID0gTWF0aC5tYXgoZnJvbS5tYXRjaGVkLmxlbmd0aCwgdG8ubWF0Y2hlZC5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlY29yZEZyb20gPSBmcm9tLm1hdGNoZWRbaV07XHJcbiAgICAgICAgaWYgKHJlY29yZEZyb20pIHtcclxuICAgICAgICAgICAgaWYgKHRvLm1hdGNoZWQuZmluZChyZWNvcmQgPT4gaXNTYW1lUm91dGVSZWNvcmQocmVjb3JkLCByZWNvcmRGcm9tKSkpXHJcbiAgICAgICAgICAgICAgICB1cGRhdGluZ1JlY29yZHMucHVzaChyZWNvcmRGcm9tKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1JlY29yZHMucHVzaChyZWNvcmRGcm9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVjb3JkVG8gPSB0by5tYXRjaGVkW2ldO1xyXG4gICAgICAgIGlmIChyZWNvcmRUbykge1xyXG4gICAgICAgICAgICAvLyB0aGUgdHlwZSBkb2Vzbid0IG1hdHRlciBiZWNhdXNlIHdlIGFyZSBjb21wYXJpbmcgcGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICBpZiAoIWZyb20ubWF0Y2hlZC5maW5kKHJlY29yZCA9PiBpc1NhbWVSb3V0ZVJlY29yZChyZWNvcmQsIHJlY29yZFRvKSkpIHtcclxuICAgICAgICAgICAgICAgIGVudGVyaW5nUmVjb3Jkcy5wdXNoKHJlY29yZFRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbbGVhdmluZ1JlY29yZHMsIHVwZGF0aW5nUmVjb3JkcywgZW50ZXJpbmdSZWNvcmRzXTtcclxufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgcm91dGVyIGluc3RhbmNlLiBFcXVpdmFsZW50IHRvIHVzaW5nIGAkcm91dGVyYCBpbnNpZGVcclxuICogdGVtcGxhdGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gdXNlUm91dGVyKCkge1xyXG4gICAgcmV0dXJuIGluamVjdChyb3V0ZXJLZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvdXRlIGxvY2F0aW9uLiBFcXVpdmFsZW50IHRvIHVzaW5nIGAkcm91dGVgIGluc2lkZVxyXG4gKiB0ZW1wbGF0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VSb3V0ZSgpIHtcclxuICAgIHJldHVybiBpbmplY3Qocm91dGVMb2NhdGlvbktleSk7XHJcbn1cblxuZXhwb3J0IHsgTmF2aWdhdGlvbkZhaWx1cmVUeXBlLCBSb3V0ZXJMaW5rLCBSb3V0ZXJWaWV3LCBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEIGFzIFNUQVJUX0xPQ0FUSU9OLCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVSb3V0ZXIsIGNyZWF0ZVJvdXRlck1hdGNoZXIsIGNyZWF0ZVdlYkhhc2hIaXN0b3J5LCBjcmVhdGVXZWJIaXN0b3J5LCBpc05hdmlnYXRpb25GYWlsdXJlLCBsb2FkUm91dGVMb2NhdGlvbiwgbWF0Y2hlZFJvdXRlS2V5LCBvbkJlZm9yZVJvdXRlTGVhdmUsIG9uQmVmb3JlUm91dGVVcGRhdGUsIHBhcnNlUXVlcnksIHJvdXRlTG9jYXRpb25LZXksIHJvdXRlcktleSwgcm91dGVyVmlld0xvY2F0aW9uS2V5LCBzdHJpbmdpZnlRdWVyeSwgdXNlTGluaywgdXNlUm91dGUsIHVzZVJvdXRlciwgdmlld0RlcHRoS2V5IH07XG4iXSwibmFtZXMiOlsiZ2V0Q3VycmVudEluc3RhbmNlIiwiaW5qZWN0Iiwib25Vbm1vdW50ZWQiLCJvbkRlYWN0aXZhdGVkIiwib25BY3RpdmF0ZWQiLCJjb21wdXRlZCIsInVucmVmIiwid2F0Y2hFZmZlY3QiLCJkZWZpbmVDb21wb25lbnQiLCJyZWFjdGl2ZSIsImgiLCJwcm92aWRlIiwicmVmIiwid2F0Y2giLCJzaGFsbG93UmVmIiwibmV4dFRpY2siLCJzZXR1cERldnRvb2xzUGx1Z2luIiwiaXNCcm93c2VyIiwid2luZG93IiwiaXNFU01vZHVsZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImFzc2lnbiIsIk9iamVjdCIsImFwcGx5VG9QYXJhbXMiLCJmbiIsInBhcmFtcyIsIm5ld1BhcmFtcyIsImtleSIsInZhbHVlIiwiaXNBcnJheSIsIm1hcCIsIm5vb3AiLCJBcnJheSIsIndhcm4iLCJtc2ciLCJhcmdzIiwiZnJvbSIsImFyZ3VtZW50cyIsInNsaWNlIiwiY29uc29sZSIsImFwcGx5IiwiY29uY2F0IiwiVFJBSUxJTkdfU0xBU0hfUkUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwicGF0aCIsInJlcGxhY2UiLCJwYXJzZVVSTCIsInBhcnNlUXVlcnkiLCJsb2NhdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsInF1ZXJ5Iiwic2VhcmNoU3RyaW5nIiwiaGFzaCIsImhhc2hQb3MiLCJpbmRleE9mIiwic2VhcmNoUG9zIiwibGVuZ3RoIiwicmVzb2x2ZVJlbGF0aXZlUGF0aCIsImZ1bGxQYXRoIiwic3RyaW5naWZ5VVJMIiwic3RyaW5naWZ5UXVlcnkiLCJzdHJpcEJhc2UiLCJwYXRobmFtZSIsImJhc2UiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJpc1NhbWVSb3V0ZUxvY2F0aW9uIiwiYSIsImIiLCJhTGFzdEluZGV4IiwibWF0Y2hlZCIsImJMYXN0SW5kZXgiLCJpc1NhbWVSb3V0ZVJlY29yZCIsImlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXMiLCJhbGlhc09mIiwia2V5cyIsImlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXNWYWx1ZSIsImlzRXF1aXZhbGVudEFycmF5IiwiZXZlcnkiLCJpIiwidG8iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJmcm9tU2VnbWVudHMiLCJzcGxpdCIsInRvU2VnbWVudHMiLCJwb3NpdGlvbiIsInRvUG9zaXRpb24iLCJzZWdtZW50Iiwiam9pbiIsIk5hdmlnYXRpb25UeXBlIiwiTmF2aWdhdGlvbkRpcmVjdGlvbiIsIlNUQVJUIiwibm9ybWFsaXplQmFzZSIsImJhc2VFbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImdldEF0dHJpYnV0ZSIsIkJFRk9SRV9IQVNIX1JFIiwiY3JlYXRlSHJlZiIsImdldEVsZW1lbnRQb3NpdGlvbiIsImVsIiwib2Zmc2V0IiwiZG9jUmVjdCIsImRvY3VtZW50RWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImJlaGF2aW9yIiwibGVmdCIsInRvcCIsImNvbXB1dGVTY3JvbGxQb3NpdGlvbiIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb1Bvc2l0aW9uIiwic2Nyb2xsVG9PcHRpb25zIiwicG9zaXRpb25FbCIsImlzSWRTZWxlY3RvciIsImdldEVsZW1lbnRCeUlkIiwiZm91bmRFbCIsImVyciIsInN0eWxlIiwic2Nyb2xsVG8iLCJnZXRTY3JvbGxLZXkiLCJkZWx0YSIsImhpc3RvcnkiLCJzdGF0ZSIsInNjcm9sbFBvc2l0aW9ucyIsIk1hcCIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInNjcm9sbFBvc2l0aW9uIiwic2V0IiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsInNjcm9sbCIsImdldCIsImRlbGV0ZSIsImNyZWF0ZUJhc2VMb2NhdGlvbiIsInByb3RvY29sIiwiaG9zdCIsImNyZWF0ZUN1cnJlbnRMb2NhdGlvbiIsInNlYXJjaCIsInNsaWNlUG9zIiwiaW5jbHVkZXMiLCJwYXRoRnJvbUhhc2giLCJ1c2VIaXN0b3J5TGlzdGVuZXJzIiwiaGlzdG9yeVN0YXRlIiwibGlzdGVuZXJzIiwidGVhcmRvd25zIiwicGF1c2VTdGF0ZSIsInBvcFN0YXRlSGFuZGxlciIsImZyb21TdGF0ZSIsImZvckVhY2giLCJsaXN0ZW5lciIsInR5cGUiLCJwb3AiLCJkaXJlY3Rpb24iLCJmb3J3YXJkIiwiYmFjayIsInVua25vd24iLCJwYXVzZUxpc3RlbmVycyIsImxpc3RlbiIsImNhbGxiYWNrIiwicHVzaCIsInRlYXJkb3duIiwiaW5kZXgiLCJzcGxpY2UiLCJiZWZvcmVVbmxvYWRMaXN0ZW5lciIsInJlcGxhY2VTdGF0ZSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJ1aWxkU3RhdGUiLCJjdXJyZW50IiwicmVwbGFjZWQiLCJjb21wdXRlU2Nyb2xsIiwidXNlSGlzdG9yeVN0YXRlTmF2aWdhdGlvbiIsImNoYW5nZUxvY2F0aW9uIiwiaGFzaEluZGV4IiwidXJsIiwiZXJyb3IiLCJkYXRhIiwiY3VycmVudFN0YXRlIiwiY3JlYXRlV2ViSGlzdG9yeSIsImhpc3RvcnlOYXZpZ2F0aW9uIiwiaGlzdG9yeUxpc3RlbmVycyIsImdvIiwidHJpZ2dlckxpc3RlbmVycyIsInJvdXRlckhpc3RvcnkiLCJiaW5kIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsInF1ZXVlIiwic2V0TG9jYXRpb24iLCJpbmZvIiwic2hvdWxkVHJpZ2dlciIsIk1hdGgiLCJtYXgiLCJtaW4iLCJjcmVhdGVXZWJIYXNoSGlzdG9yeSIsImVuZHNXaXRoIiwiaXNSb3V0ZUxvY2F0aW9uIiwicm91dGUiLCJpc1JvdXRlTmFtZSIsIm5hbWUiLCJTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEIiwidW5kZWZpbmVkIiwibWV0YSIsInJlZGlyZWN0ZWRGcm9tIiwiTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2wiLCJOYXZpZ2F0aW9uRmFpbHVyZVR5cGUiLCJFcnJvclR5cGVNZXNzYWdlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdHJpbmdpZnlSb3V0ZSIsImNyZWF0ZVJvdXRlckVycm9yIiwiRXJyb3IiLCJpc05hdmlnYXRpb25GYWlsdXJlIiwicHJvcGVydGllc1RvTG9nIiwiQkFTRV9QQVJBTV9QQVRURVJOIiwiQkFTRV9QQVRIX1BBUlNFUl9PUFRJT05TIiwic2Vuc2l0aXZlIiwic3RyaWN0Iiwic3RhcnQiLCJlbmQiLCJSRUdFWF9DSEFSU19SRSIsInRva2Vuc1RvUGFyc2VyIiwic2VnbWVudHMiLCJleHRyYU9wdGlvbnMiLCJvcHRpb25zIiwic2NvcmUiLCJwYXR0ZXJuIiwic2VnbWVudFNjb3JlcyIsInRva2VuSW5kZXgiLCJ0b2tlbiIsInN1YlNlZ21lbnRTY29yZSIsInJlcGVhdGFibGUiLCJvcHRpb25hbCIsInJlZ2V4cCIsInJlIiwiUmVnRXhwIiwibWVzc2FnZSIsInN1YlBhdHRlcm4iLCJwYXJzZSIsIm1hdGNoIiwiYXZvaWREdXBsaWNhdGVkU2xhc2giLCJwYXJhbSIsInRleHQiLCJjb21wYXJlU2NvcmVBcnJheSIsImRpZmYiLCJjb21wYXJlUGF0aFBhcnNlclNjb3JlIiwiYVNjb3JlIiwiYlNjb3JlIiwiY29tcCIsImFicyIsImlzTGFzdFNjb3JlTmVnYXRpdmUiLCJsYXN0IiwiUk9PVF9UT0tFTiIsIlZBTElEX1BBUkFNX1JFIiwidG9rZW5pemVQYXRoIiwiY3Jhc2giLCJidWZmZXIiLCJwcmV2aW91c1N0YXRlIiwidG9rZW5zIiwiZmluYWxpemVTZWdtZW50IiwiY2hhciIsImN1c3RvbVJlIiwiY29uc3VtZUJ1ZmZlciIsImFkZENoYXJUb0J1ZmZlciIsInRlc3QiLCJjcmVhdGVSb3V0ZVJlY29yZE1hdGNoZXIiLCJyZWNvcmQiLCJwYXJlbnQiLCJwYXJzZXIiLCJleGlzdGluZ0tleXMiLCJTZXQiLCJoYXMiLCJhZGQiLCJtYXRjaGVyIiwiY2hpbGRyZW4iLCJhbGlhcyIsImNyZWF0ZVJvdXRlck1hdGNoZXIiLCJyb3V0ZXMiLCJnbG9iYWxPcHRpb25zIiwibWF0Y2hlcnMiLCJtYXRjaGVyTWFwIiwibWVyZ2VPcHRpb25zIiwiZ2V0UmVjb3JkTWF0Y2hlciIsImFkZFJvdXRlIiwib3JpZ2luYWxSZWNvcmQiLCJpc1Jvb3RBZGQiLCJtYWluTm9ybWFsaXplZFJlY29yZCIsIm5vcm1hbGl6ZVJvdXRlUmVjb3JkIiwiY2hlY2tDaGlsZE1pc3NpbmdOYW1lV2l0aEVtcHR5UGF0aCIsIm5vcm1hbGl6ZWRSZWNvcmRzIiwiYWxpYXNlcyIsImNvbXBvbmVudHMiLCJvcmlnaW5hbE1hdGNoZXIiLCJub3JtYWxpemVkUmVjb3JkIiwicGFyZW50UGF0aCIsImNvbm5lY3RpbmdTbGFzaCIsImNoZWNrTWlzc2luZ1BhcmFtc0luQWJzb2x1dGVQYXRoIiwiY2hlY2tTYW1lUGFyYW1zIiwiaXNBbGlhc1JlY29yZCIsInJlbW92ZVJvdXRlIiwicmVkaXJlY3QiLCJpbnNlcnRNYXRjaGVyIiwibWF0Y2hlclJlZiIsImdldFJvdXRlcyIsImlzUmVjb3JkQ2hpbGRPZiIsInJlc29sdmUiLCJpbnZhbGlkUGFyYW1zIiwiZmlsdGVyIiwicGFyYW1OYW1lIiwiZmluZCIsImsiLCJwYXJhbXNGcm9tTG9jYXRpb24iLCJtIiwicGFyZW50TWF0Y2hlciIsInVuc2hpZnQiLCJtZXJnZU1ldGFGaWVsZHMiLCJiZWZvcmVFbnRlciIsInByb3BzIiwibm9ybWFsaXplUmVjb3JkUHJvcHMiLCJpbnN0YW5jZXMiLCJsZWF2ZUd1YXJkcyIsInVwZGF0ZUd1YXJkcyIsImVudGVyQ2FsbGJhY2tzIiwiY29tcG9uZW50IiwiZGVmYXVsdCIsInByb3BzT2JqZWN0IiwicmVkdWNlIiwiZGVmYXVsdHMiLCJwYXJ0aWFsT3B0aW9ucyIsImlzU2FtZVBhcmFtIiwiU3RyaW5nIiwic29tZSIsImNoaWxkIiwiSEFTSF9SRSIsIkFNUEVSU0FORF9SRSIsIlNMQVNIX1JFIiwiRVFVQUxfUkUiLCJJTV9SRSIsIlBMVVNfUkUiLCJFTkNfQlJBQ0tFVF9PUEVOX1JFIiwiRU5DX0JSQUNLRVRfQ0xPU0VfUkUiLCJFTkNfQ0FSRVRfUkUiLCJFTkNfQkFDS1RJQ0tfUkUiLCJFTkNfQ1VSTFlfT1BFTl9SRSIsIkVOQ19QSVBFX1JFIiwiRU5DX0NVUkxZX0NMT1NFX1JFIiwiRU5DX1NQQUNFX1JFIiwiY29tbW9uRW5jb2RlIiwiZW5jb2RlVVJJIiwiZW5jb2RlSGFzaCIsImVuY29kZVF1ZXJ5VmFsdWUiLCJlbmNvZGVRdWVyeUtleSIsImVuY29kZVBhdGgiLCJlbmNvZGVQYXJhbSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImhhc0xlYWRpbmdJTSIsInNlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtIiwiZXFQb3MiLCJjdXJyZW50VmFsdWUiLCJ2YWx1ZXMiLCJ2Iiwibm9ybWFsaXplUXVlcnkiLCJub3JtYWxpemVkUXVlcnkiLCJtYXRjaGVkUm91dGVLZXkiLCJ2aWV3RGVwdGhLZXkiLCJyb3V0ZXJLZXkiLCJyb3V0ZUxvY2F0aW9uS2V5Iiwicm91dGVyVmlld0xvY2F0aW9uS2V5IiwidXNlQ2FsbGJhY2tzIiwiaGFuZGxlcnMiLCJoYW5kbGVyIiwicmVzZXQiLCJsaXN0IiwicmVnaXN0ZXJHdWFyZCIsImd1YXJkIiwicmVtb3ZlRnJvbUxpc3QiLCJvbkJlZm9yZVJvdXRlTGVhdmUiLCJsZWF2ZUd1YXJkIiwiYWN0aXZlUmVjb3JkIiwib25CZWZvcmVSb3V0ZVVwZGF0ZSIsInVwZGF0ZUd1YXJkIiwiZ3VhcmRUb1Byb21pc2VGbiIsImVudGVyQ2FsbGJhY2tBcnJheSIsIlByb21pc2UiLCJyZWplY3QiLCJuZXh0IiwidmFsaWQiLCJndWFyZFJldHVybiIsImNhbGwiLCJjYW5Pbmx5QmVDYWxsZWRPbmNlIiwiZ3VhcmRDYWxsIiwidGhlbiIsInRvU3RyaW5nIiwicmVzb2x2ZWRWYWx1ZSIsIl9jYWxsZWQiLCJjYXRjaCIsImNhbGxlZCIsImV4dHJhY3RDb21wb25lbnRzR3VhcmRzIiwiZ3VhcmRUeXBlIiwiZ3VhcmRzIiwicmF3Q29tcG9uZW50IiwicHJvbWlzZSIsIl9fYXN5bmNMb2FkZXIiLCJfX3dhcm5lZERlZmluZUFzeW5jIiwiaXNSb3V0ZUNvbXBvbmVudCIsIl9fdmNjT3B0cyIsImNvbXBvbmVudFByb21pc2UiLCJyZXNvbHZlZCIsInJlc29sdmVkQ29tcG9uZW50IiwibG9hZFJvdXRlTG9jYXRpb24iLCJhbGwiLCJwcm9taXNlcyIsInVzZUxpbmsiLCJyb3V0ZXIiLCJjdXJyZW50Um91dGUiLCJhY3RpdmVSZWNvcmRJbmRleCIsInJvdXRlTWF0Y2hlZCIsImN1cnJlbnRNYXRjaGVkIiwiZmluZEluZGV4IiwicGFyZW50UmVjb3JkUGF0aCIsImdldE9yaWdpbmFsUGF0aCIsImlzQWN0aXZlIiwiaW5jbHVkZXNQYXJhbXMiLCJpc0V4YWN0QWN0aXZlIiwibmF2aWdhdGUiLCJlIiwiZ3VhcmRFdmVudCIsIl9fVlVFX1BST0RfREVWVE9PTFNfXyIsImluc3RhbmNlIiwibGlua0NvbnRleHREZXZ0b29scyIsIl9fdnJsX2RldnRvb2xzIiwiZmx1c2giLCJocmVmIiwiUm91dGVyTGlua0ltcGwiLCJjb21wYXRDb25maWciLCJNT0RFIiwicmVxdWlyZWQiLCJCb29sZWFuIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwiY3VzdG9tIiwiYXJpYUN1cnJlbnRWYWx1ZSIsInNldHVwIiwic2xvdHMiLCJsaW5rIiwiZWxDbGFzcyIsImdldExpbmtDbGFzcyIsImxpbmtBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwib25DbGljayIsImNsYXNzIiwiUm91dGVyTGluayIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJkZWZhdWx0UHJldmVudGVkIiwiYnV0dG9uIiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsInByZXZlbnREZWZhdWx0Iiwib3V0ZXIiLCJpbm5lciIsImlubmVyVmFsdWUiLCJvdXRlclZhbHVlIiwicHJvcENsYXNzIiwiZ2xvYmFsQ2xhc3MiLCJkZWZhdWx0Q2xhc3MiLCJSb3V0ZXJWaWV3SW1wbCIsImluaGVyaXRBdHRycyIsImF0dHJzIiwid2FybkRlcHJlY2F0ZWRVc2FnZSIsImluamVjdGVkUm91dGUiLCJyb3V0ZVRvRGlzcGxheSIsImluamVjdGVkRGVwdGgiLCJkZXB0aCIsImluaXRpYWxEZXB0aCIsIm1hdGNoZWRSb3V0ZSIsIm1hdGNoZWRSb3V0ZVJlZiIsInZpZXdSZWYiLCJvbGRJbnN0YW5jZSIsIm9sZE5hbWUiLCJzaXplIiwiY3VycmVudE5hbWUiLCJWaWV3Q29tcG9uZW50Iiwibm9ybWFsaXplU2xvdCIsIkNvbXBvbmVudCIsInJvdXRlUHJvcHNPcHRpb24iLCJyb3V0ZVByb3BzIiwib25Wbm9kZVVubW91bnRlZCIsInZub2RlIiwiaXNVbm1vdW50ZWQiLCJpbnRlcm5hbEluc3RhbmNlcyIsInIiLCJfX3Zydl9kZXZ0b29scyIsInNsb3QiLCJzbG90Q29udGVudCIsIlJvdXRlclZpZXciLCJwYXJlbnROYW1lIiwiZm9ybWF0Um91dGVMb2NhdGlvbiIsInJvdXRlTG9jYXRpb24iLCJ0b29sdGlwIiwiY29weSIsIm9taXQiLCJfY3VzdG9tIiwicmVhZE9ubHkiLCJkaXNwbGF5IiwiZm9ybWF0RGlzcGxheSIsInJvdXRlcklkIiwiYWRkRGV2dG9vbHMiLCJhcHAiLCJfX2hhc0RldnRvb2xzIiwiaWQiLCJsYWJlbCIsInBhY2thZ2VOYW1lIiwiaG9tZXBhZ2UiLCJsb2dvIiwiY29tcG9uZW50U3RhdGVUeXBlcyIsImFwaSIsIm5vdyIsIm9uIiwiaW5zcGVjdENvbXBvbmVudCIsInBheWxvYWQiLCJjdHgiLCJpbnN0YW5jZURhdGEiLCJlZGl0YWJsZSIsInZpc2l0Q29tcG9uZW50VHJlZSIsInRyZWVOb2RlIiwibm9kZSIsImNvbXBvbmVudEluc3RhbmNlIiwidGFncyIsInRleHRDb2xvciIsImJhY2tncm91bmRDb2xvciIsIlBJTktfNTAwIiwiX19kZXZ0b29sc0FwaSIsImRldnRvb2xzRGF0YSIsIk9SQU5HRV80MDAiLCJMSU1FXzUwMCIsIkJMVUVfNjAwIiwicmVmcmVzaFJvdXRlc1ZpZXciLCJub3RpZnlDb21wb25lbnRVcGRhdGUiLCJzZW5kSW5zcGVjdG9yVHJlZSIsInJvdXRlckluc3BlY3RvcklkIiwic2VuZEluc3BlY3RvclN0YXRlIiwibmF2aWdhdGlvbnNMYXllcklkIiwiYWRkVGltZWxpbmVMYXllciIsImNvbG9yIiwib25FcnJvciIsImFkZFRpbWVsaW5lRXZlbnQiLCJsYXllcklkIiwiZXZlbnQiLCJ0aXRsZSIsInN1YnRpdGxlIiwibG9nVHlwZSIsInRpbWUiLCJncm91cElkIiwiX19uYXZpZ2F0aW9uSWQiLCJuYXZpZ2F0aW9uSWQiLCJiZWZvcmVFYWNoIiwiYWZ0ZXJFYWNoIiwiZmFpbHVyZSIsInN0YXR1cyIsImFkZEluc3BlY3RvciIsImljb24iLCJ0cmVlRmlsdGVyUGxhY2Vob2xkZXIiLCJhY3RpdmVSb3V0ZXNQYXlsb2FkIiwicmVzZXRNYXRjaFN0YXRlT25Sb3V0ZVJlY29yZCIsImlzUm91dGVNYXRjaGluZyIsIm1hcmtSb3V0ZVJlY29yZEFjdGl2ZSIsInJvb3ROb2RlcyIsImZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yIiwiZ2V0SW5zcGVjdG9yVHJlZSIsImluc3BlY3RvcklkIiwiZ2V0SW5zcGVjdG9yU3RhdGUiLCJfX3ZkX2lkIiwibm9kZUlkIiwiZm9ybWF0Um91dGVSZWNvcmRNYXRjaGVyRm9yU3RhdGVJbnNwZWN0b3IiLCJtb2RpZmllckZvcktleSIsImZpZWxkcyIsIkNZQU5fNDAwIiwiREFSSyIsIl9fdmRfbWF0Y2giLCJfX3ZkX2V4YWN0QWN0aXZlIiwiX192ZF9hY3RpdmUiLCJyb3V0ZVJlY29yZElkIiwiRVhUUkFDVF9SRUdFWFBfUkUiLCJjaGlsZFJvdXRlIiwiZm91bmQiLCJub25FbmRpbmdSRSIsImRlY29kZWRQYXRoIiwicmV0IiwiY3JlYXRlUm91dGVyIiwicGFyc2VRdWVyeSQxIiwic3RyaW5naWZ5UXVlcnkkMSIsImJlZm9yZUd1YXJkcyIsImJlZm9yZVJlc29sdmVHdWFyZHMiLCJhZnRlckd1YXJkcyIsInBlbmRpbmdMb2NhdGlvbiIsInNjcm9sbEJlaGF2aW9yIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJub3JtYWxpemVQYXJhbXMiLCJwYXJhbVZhbHVlIiwiZW5jb2RlUGFyYW1zIiwiZGVjb2RlUGFyYW1zIiwicGFyZW50T3JSb3V0ZSIsInJlY29yZE1hdGNoZXIiLCJyb3V0ZU1hdGNoZXIiLCJoYXNSb3V0ZSIsInJhd0xvY2F0aW9uIiwibG9jYXRpb25Ob3JtYWxpemVkIiwibWF0Y2hlckxvY2F0aW9uIiwidGFyZ2V0UGFyYW1zIiwibG9jYXRpb25Bc09iamVjdCIsImNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uIiwicHVzaFdpdGhSZWRpcmVjdCIsImhhbmRsZVJlZGlyZWN0UmVjb3JkIiwibGFzdE1hdGNoZWQiLCJuZXdUYXJnZXRMb2NhdGlvbiIsInRhcmdldExvY2F0aW9uIiwiZm9yY2UiLCJzaG91bGRSZWRpcmVjdCIsInRvTG9jYXRpb24iLCJoYW5kbGVTY3JvbGwiLCJtYXJrQXNSZWFkeSIsInRyaWdnZXJFcnJvciIsIl9jb3VudCIsImZpbmFsaXplTmF2aWdhdGlvbiIsInRyaWdnZXJBZnRlckVhY2giLCJjaGVja0NhbmNlbGVkTmF2aWdhdGlvbkFuZFJlamVjdCIsImxlYXZpbmdSZWNvcmRzIiwidXBkYXRpbmdSZWNvcmRzIiwiZW50ZXJpbmdSZWNvcmRzIiwiZXh0cmFjdENoYW5naW5nUmVjb3JkcyIsInJldmVyc2UiLCJjYW5jZWxlZE5hdmlnYXRpb25DaGVjayIsInJ1bkd1YXJkUXVldWUiLCJpc1B1c2giLCJpc0ZpcnN0TmF2aWdhdGlvbiIsInJlbW92ZUhpc3RvcnlMaXN0ZW5lciIsInNldHVwTGlzdGVuZXJzIiwiX2Zyb20iLCJsaXN0ZW5pbmciLCJyZWFkeUhhbmRsZXJzIiwiZXJyb3JIYW5kbGVycyIsInJlYWR5IiwiaXNSZWFkeSIsInN0YXJ0ZWQiLCJpbnN0YWxsZWRBcHBzIiwiYmVmb3JlUmVzb2x2ZSIsImluc3RhbGwiLCJjb25maWciLCJnbG9iYWxQcm9wZXJ0aWVzIiwiJHJvdXRlciIsInJlYWN0aXZlUm91dGUiLCJ1bm1vdW50QXBwIiwidW5tb3VudCIsImxlbiIsInJlY29yZEZyb20iLCJyZWNvcmRUbyIsInVzZVJvdXRlciIsInVzZVJvdXRlIiwiU1RBUlRfTE9DQVRJT04iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2483\n")}}]);