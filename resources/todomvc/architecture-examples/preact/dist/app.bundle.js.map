{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://library-preact/../src/util.js","webpack://library-preact/../src/options.js","webpack://library-preact/../src/create-element.js","webpack://library-preact/../src/component.js","webpack://library-preact/../src/constants.js","webpack://library-preact/../src/diff/children.js","webpack://library-preact/../src/diff/props.js","webpack://library-preact/../src/diff/index.js","webpack://library-preact/../src/render.js","webpack://library-preact/../src/clone-element.js","webpack://library-preact/../src/diff/catch-error.js","webpack://library-preact/../src/index.js","webpack://library-preact/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://library-preact/../src/PureComponent.js","webpack://library-preact/../src/memo.js","webpack://library-preact/../src/forwardRef.js","webpack://library-preact/../src/Children.js","webpack://library-preact/../src/suspense.js","webpack://library-preact/../src/suspense-list.js","webpack://library-preact/./src/todo/components/input.jsx","webpack://library-preact/./src/todo/components/header.jsx","webpack://library-preact/./src/todo/components/item.jsx","webpack://library-preact/./src/todo/components/main.jsx","webpack://library-preact/./src/todo/components/footer.jsx","webpack://library-preact/./src/todo/reducer.js","webpack://library-preact/./src/todo/app.js","webpack://library-preact/./src/index.js"],"sourcesContent":["import { EMPTY_ARR } from \"./constants\";\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-ignore We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = vnode._original + 1;\n\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (vnode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tnewDom = childVNode._dom;\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\t\tchildVNode._children === oldVNode._children\n\t\t\t) {\n\t\t\t\tchildVNode._nextDom = oldDom = reorderChildren(\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldDom,\n\t\t\t\t\tparentDom\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldVNode,\n\t\t\t\t\toldChildren,\n\t\t\t\t\tnewDom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) {\n\t\t\tif (\n\t\t\t\ttypeof newParentVNode.type == 'function' &&\n\t\t\t\toldChildren[i]._dom != null &&\n\t\t\t\toldChildren[i]._dom == newParentVNode._nextDom\n\t\t\t) {\n\t\t\t\t// If the newParentVNode.__nextDom points to a dom node that is about to\n\t\t\t\t// be unmounted, then get the next sibling of that vnode and set\n\t\t\t\t// _nextDom to it\n\t\t\t\tnewParentVNode._nextDom = getLastDom(oldParentVNode).nextSibling;\n\t\t\t}\n\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\nfunction reorderChildren(childVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\tlet c = childVNode._children;\n\tlet tmp = 0;\n\tfor (; c && tmp < c.length; tmp++) {\n\t\tlet vnode = c[tmp];\n\t\tif (vnode) {\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\n\t\t\t// (childVNode here).\n\t\t\tvnode._parent = childVNode;\n\n\t\t\tif (typeof vnode.type == 'function') {\n\t\t\t\toldDom = reorderChildren(vnode, oldDom, parentDom);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(parentDom, vnode, vnode, c, vnode._dom, oldDom);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nfunction placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\toldVNode == null ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 1\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {import('../internal').VNode} vnode\n */\nfunction getLastDom(vnode) {\n\tif (vnode.type == null || typeof vnode.type === 'string') {\n\t\treturn vnode._dom;\n\t}\n\n\tif (vnode._children) {\n\t\tfor (let i = vnode._children.length - 1; i >= 0; i--) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child) {\n\t\t\t\tlet lastDom = getLastDom(child);\n\t\t\t\tif (lastDom) {\n\t\t\t\t\treturn lastDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'width' &&\n\t\t\tname !== 'height' &&\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name.indexOf('-') != -1)) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\treturn this._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ } from '../constants';\nimport { Component, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// In cases of bailing due to strict-equality we have to reset force as well\n\t\t\t\t\tc._force = false;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-ignore See above ts-ignore on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = newVNode.type;\n\tlet i = 0;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tif (nodeType === 'svg') isSvg = true;\n\n\tif (excessDomChildren != null) {\n\t\tfor (; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild &&\n\t\t\t\t'setAttribute' in child === !!nodeType &&\n\t\t\t\t(nodeType ? child.localName === nodeType : child.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tif (isSvg) {\n\t\t\tdom = document.createElementNS(\n\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType\n\t\t\t);\n\t\t} else {\n\t\t\tdom = document.createElement(\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType,\n\t\t\t\tnewProps.is && newProps\n\t\t\t);\n\t\t}\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value ||\n\t\t\t\t\t(nodeType === 'progress' && !i) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && i !== oldProps.value))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t\tvnode._component = undefined;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type !== 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode === 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = (\n\t\t(!isHydrating && replaceNode) ||\n\t\tparentDom\n\t)._children = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n","import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { cloneElement, createElement, Component, toChildArray } from 'preact';\nimport { exec, prepareVNodeForRanking, assign, pathRankSort } from './util';\n\nlet customHistory = null;\n\nconst ROUTERS = [];\n\nconst subscribers = [];\n\nconst EMPTY = {};\n\nfunction setUrl(url, type='push') {\n\tif (customHistory && customHistory[type]) {\n\t\tcustomHistory[type](url);\n\t}\n\telse if (typeof history!=='undefined' && history[type+'State']) {\n\t\thistory[type+'State'](null, null, url);\n\t}\n}\n\n\nfunction getCurrentUrl() {\n\tlet url;\n\tif (customHistory && customHistory.location) {\n\t\turl = customHistory.location;\n\t}\n\telse if (customHistory && customHistory.getCurrentLocation) {\n\t\turl = customHistory.getCurrentLocation();\n\t}\n\telse {\n\t\turl = typeof location!=='undefined' ? location : EMPTY;\n\t}\n\treturn `${url.pathname || ''}${url.search || ''}`;\n}\n\n\n\nfunction route(url, replace=false) {\n\tif (typeof url!=='string' && url.url) {\n\t\treplace = url.replace;\n\t\turl = url.url;\n\t}\n\n\t// only push URL into history if we can handle it\n\tif (canRoute(url)) {\n\t\tsetUrl(url, replace ? 'replace' : 'push');\n\t}\n\n\treturn routeTo(url);\n}\n\n\n/** Check if the given URL can be handled by any router instances. */\nfunction canRoute(url) {\n\tfor (let i=ROUTERS.length; i--; ) {\n\t\tif (ROUTERS[i].canRoute(url)) return true;\n\t}\n\treturn false;\n}\n\n\n/** Tell all router instances to handle the given URL.  */\nfunction routeTo(url) {\n\tlet didRoute = false;\n\tfor (let i=0; i<ROUTERS.length; i++) {\n\t\tif (ROUTERS[i].routeTo(url)===true) {\n\t\t\tdidRoute = true;\n\t\t}\n\t}\n\tfor (let i=subscribers.length; i--; ) {\n\t\tsubscribers[i](url);\n\t}\n\treturn didRoute;\n}\n\n\nfunction routeFromLink(node) {\n\t// only valid elements\n\tif (!node || !node.getAttribute) return;\n\n\tlet href = node.getAttribute('href'),\n\t\ttarget = node.getAttribute('target');\n\n\t// ignore links with targets and non-path URLs\n\tif (!href || !href.match(/^\\//g) || (target && !target.match(/^_?self$/i))) return;\n\n\t// attempt to route, if no match simply cede control to browser\n\treturn route(href);\n}\n\n\nfunction handleLinkClick(e) {\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button!==0) return;\n\trouteFromLink(e.currentTarget || e.target || this);\n\treturn prevent(e);\n}\n\n\nfunction prevent(e) {\n\tif (e) {\n\t\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\t\tif (e.stopPropagation) e.stopPropagation();\n\t\te.preventDefault();\n\t}\n\treturn false;\n}\n\n\nfunction delegateLinkHandler(e) {\n\t// ignore events the browser takes care of already:\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button!==0) return;\n\n\tlet t = e.target;\n\tdo {\n\t\tif (String(t.nodeName).toUpperCase()==='A' && t.getAttribute('href')) {\n\t\t\tif (t.hasAttribute('native')) return;\n\t\t\t// if link is handled by the router, prevent browser defaults\n\t\t\tif (routeFromLink(t)) {\n\t\t\t\treturn prevent(e);\n\t\t\t}\n\t\t}\n\t} while ((t=t.parentNode));\n}\n\n\nlet eventListenersInitialized = false;\n\nfunction initEventListeners() {\n\tif (eventListenersInitialized) return;\n\n\tif (typeof addEventListener==='function') {\n\t\tif (!customHistory) {\n\t\t\taddEventListener('popstate', () => {\n\t\t\t\trouteTo(getCurrentUrl());\n\t\t\t});\n\t\t}\n\t\taddEventListener('click', delegateLinkHandler);\n\t}\n\teventListenersInitialized = true;\n}\n\n\nclass Router extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tif (props.history) {\n\t\t\tcustomHistory = props.history;\n\t\t}\n\n\t\tthis.state = {\n\t\t\turl: props.url || getCurrentUrl()\n\t\t};\n\n\t\tinitEventListeners();\n\t}\n\n\tshouldComponentUpdate(props) {\n\t\tif (props.static!==true) return true;\n\t\treturn props.url!==this.props.url || props.onChange!==this.props.onChange;\n\t}\n\n\t/** Check if the given URL can be matched against any children */\n\tcanRoute(url) {\n\t\tconst children = toChildArray(this.props.children);\n\t\treturn this.getMatchingChildren(children, url, false).length > 0;\n\t}\n\n\t/** Re-render children with a new URL to match against. */\n\trouteTo(url) {\n\t\tthis.setState({ url });\n\n\t\tconst didRoute = this.canRoute(url);\n\n\t\t// trigger a manual re-route if we're not in the middle of an update:\n\t\tif (!this.updating) this.forceUpdate();\n\n\t\treturn didRoute;\n\t}\n\n\tcomponentWillMount() {\n\t\tROUTERS.push(this);\n\t\tthis.updating = true;\n\t}\n\n\tcomponentDidMount() {\n\t\tif (customHistory) {\n\t\t\tthis.unlisten = customHistory.listen((location) => {\n\t\t\t\tthis.routeTo(`${location.pathname || ''}${location.search || ''}`);\n\t\t\t});\n\t\t}\n\t\tthis.updating = false;\n\t}\n\n\tcomponentWillUnmount() {\n\t\tif (typeof this.unlisten==='function') this.unlisten();\n\t\tROUTERS.splice(ROUTERS.indexOf(this), 1);\n\t}\n\n\tcomponentWillUpdate() {\n\t\tthis.updating = true;\n\t}\n\n\tcomponentDidUpdate() {\n\t\tthis.updating = false;\n\t}\n\n\tgetMatchingChildren(children, url, invoke) {\n\t\treturn children\n\t\t\t.filter(prepareVNodeForRanking)\n\t\t\t.sort(pathRankSort)\n\t\t\t.map( vnode => {\n\t\t\t\tlet matches = exec(url, vnode.props.path, vnode.props);\n\t\t\t\tif (matches) {\n\t\t\t\t\tif (invoke !== false) {\n\t\t\t\t\t\tlet newProps = { url, matches };\n\t\t\t\t\t\tassign(newProps, matches);\n\t\t\t\t\t\tdelete newProps.ref;\n\t\t\t\t\t\tdelete newProps.key;\n\t\t\t\t\t\treturn cloneElement(vnode, newProps);\n\t\t\t\t\t}\n\t\t\t\t\treturn vnode;\n\t\t\t\t}\n\t\t\t}).filter(Boolean);\n\t}\n\n\trender({ children, onChange }, { url }) {\n\t\tlet active = this.getMatchingChildren(toChildArray(children), url, true);\n\n\t\tlet current = active[0] || null;\n\n\t\tlet previous = this.previousUrl;\n\t\tif (url!==previous) {\n\t\t\tthis.previousUrl = url;\n\t\t\tif (typeof onChange==='function') {\n\t\t\t\tonChange({\n\t\t\t\t\trouter: this,\n\t\t\t\t\turl,\n\t\t\t\t\tprevious,\n\t\t\t\t\tactive,\n\t\t\t\t\tcurrent\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn current;\n\t}\n}\n\nconst Link = (props) => (\n\tcreateElement('a', assign({ onClick: handleLinkClick }, props))\n);\n\nconst Route = props => createElement(props.component, props);\n\nRouter.subscribers = subscribers;\nRouter.getCurrentUrl = getCurrentUrl;\nRouter.route = route;\nRouter.Router = Router;\nRouter.Route = Route;\nRouter.Link = Link;\nRouter.exec = exec;\n\nexport { subscribers, getCurrentUrl, route, Router, Route, Link, exec };\nexport default Router;\n","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\treturn fn(clone, props.ref || null);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode, errorInfo) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode, errorInfo);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function(vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._hydrating === true) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.insertBefore(vnode._dom, vnode._nextDom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tconst wasHydrating = suspendingVNode._hydrating === true;\n\tif (!c._pendingSuspensionCount++ && !wasHydrating) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._hydrating = null;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { useCallback, useRef, useEffect } from \"preact/hooks\";\n\nconst sanitize = (string) => {\n    const map = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#x27;\",\n        \"/\": \"&#x2F;\",\n    };\n    const reg = /[&<>\"'/]/gi;\n    return string.replace(reg, (match) => map[match]);\n};\n\nconst hasValidMin = (value, min) => {\n    return value.length >= min;\n};\n\nexport function Input({ onSubmit, placeholder, label, defaultValue, onBlur }) {\n    const inputRef = useRef(null);\n\n    useEffect(() => {\n        if (inputRef.current) {\n            const end = inputRef.current.value.length;\n            inputRef.current.setSelectionRange(end, end);\n            inputRef.current.focus();\n        }\n    }, [inputRef.current])\n\n    const handleBlur = useCallback(() => {\n        if (onBlur)\n            onBlur();\n    }, [onBlur]);\n\n    const handleKeyDown = useCallback(\n        (e) => {\n            if (e.keyCode === 13) {\n                const value = e.target.value.trim();\n                if (!hasValidMin(value, 2))\n                    return;\n\n                onSubmit(sanitize(value));\n                e.target.value = \"\";\n            }\n        },\n        [onSubmit]\n    );\n\n    return (\n        <div class=\"input-container\">\n            <input class=\"new-todo\" id=\"todo-input\" type=\"text\" data-testid=\"text-input\" ref={inputRef} placeholder={placeholder} defaultValue={defaultValue} onBlur={handleBlur} onKeyDown={handleKeyDown} />\n            <label class=\"visually-hidden\" htmlFor=\"todo-input\">\n                {label}\n            </label>\n        </div>\n    );\n}\n","import { useCallback } from \"preact/hooks\";\nimport { Input } from \"./input\";\n\nexport function Header({ dispatch }) {\n    const addItem = useCallback((title) => dispatch({ type: \"ADD_ITEM\", payload: { title } }), [dispatch]);\n\n    return (\n        <header class=\"header\" data-testid=\"header\">\n            <h1>todos</h1>\n            <Input onSubmit={addItem} label=\"New Todo Input\" placeholder=\"What needs to be done?\" />\n        </header>\n    );\n}\n","import { useState, useCallback } from \"preact/hooks\";\nimport { memo } from \"preact/compat\";\n\nimport { Input } from \"./input\";\n\nexport const Item = memo(function Item({ todo, dispatch }) {\n    const [isWritable, setIsWritable] = useState(false);\n    const { title, completed, id } = todo;\n\n    const toggleItem = useCallback(() => dispatch({ type: \"TOGGLE_ITEM\", payload: { id } }), [dispatch]);\n    const removeItem = useCallback(() => dispatch({ type: \"REMOVE_ITEM\", payload: { id } }), [dispatch]);\n    const updateItem = useCallback((id, title) => dispatch({ type: \"UPDATE_ITEM\", payload: { id, title } }), [dispatch]);\n\n    const handleDoubleClick = useCallback(() => {\n        setIsWritable(true);\n    });\n\n    const handleBlur = useCallback(() => {\n        setIsWritable(false);\n    });\n\n    const handleUpdate = useCallback(\n        (title) => {\n            if (title.length === 0)\n                removeItem(id);\n            else\n                updateItem(id, title);\n\n            setIsWritable(false);\n        },\n        [id, removeItem, updateItem]\n    );\n\n    return (\n        <li class={todo.completed ? \"completed\" : \"\" } data-testid=\"todo-item\">\n            <div class=\"view\">\n                {isWritable ? (\n                    <Input onSubmit={handleUpdate} label=\"Edit Todo Input\" defaultValue={title} onBlur={handleBlur} />\n                ) : (\n                    <>\n                        <input class=\"toggle\" type=\"checkbox\" data-testid=\"todo-item-toggle\" checked={completed} onChange={toggleItem} />\n                        <label data-testid=\"todo-item-label\" onDoubleClick={handleDoubleClick}>\n                            {title}\n                        </label>\n                        <button class=\"destroy\" data-testid=\"todo-item-button\" onClick={removeItem} />\n                    </>\n                )}\n            </div>\n        </li>\n    );\n});\n","import { useMemo, useCallback } from \"preact/hooks\";\nimport { getCurrentUrl } from \"preact-router\";\n\nimport { Item } from \"./item\";\n\nexport function Main({ todos, dispatch }) {\n    const route = getCurrentUrl();\n\n    const visibleTodos = useMemo(\n        () =>\n            todos.filter((todo) => {\n                if (route === \"/active\")\n                    return !todo.completed;\n\n                if (route === \"/completed\")\n                    return todo.completed;\n\n                return todo;\n            }),\n        [todos, route]\n    );\n\n    const toggleAll = useCallback((e) => dispatch({ type: \"TOGGLE_ALL\", payload: { completed: e.target.checked } }), [dispatch]);\n\n    return (\n        <main class=\"main\" data-testid=\"main\">\n            {visibleTodos.length > 0 ? (\n                <div class=\"toggle-all-container\">\n                    <input class=\"toggle-all\" type=\"checkbox\" data-testid=\"toggle-all\" checked={visibleTodos.every((todo) => todo.completed)} onChange={toggleAll} />\n                    <label class=\"toggle-all-label\" htmlFor=\"toggle-all\">\n                        Toggle All Input\n                    </label>\n                </div>\n            ) : null}\n            <ul class=\"todo-list\" data-testid=\"todo-list\">\n                {visibleTodos.map((todo) => (\n                    <Item todo={todo} key={todo.id} dispatch={dispatch} />\n                ))}\n            </ul>\n        </main>\n    );\n}\n","import { useCallback, useMemo } from \"preact/hooks\";\nimport { getCurrentUrl } from \"preact-router\";\n\nexport function Footer({ todos, dispatch }) {\n    const route = getCurrentUrl();\n\n    const activeTodos = useMemo(() => todos.filter((todo) => !todo.completed), [todos]);\n\n    const removeCompleted = useCallback(() => dispatch({ type: \"REMOVE_COMPLETED_ITEMS\" }), [dispatch]);\n\n    if (todos.length === 0)\n        return null;\n\n    return (\n        <footer class=\"footer\" data-testid=\"footer\">\n            <span class=\"todo-count\">{`${activeTodos.length} ${activeTodos.length === 1 ? \"item\" : \"items\"} left!`}</span>\n            <ul class=\"filters\" data-testid=\"footer-navigation\">\n                <li>\n                    <a class={ route === \"/\" ? \"selected\" : \"\" } href=\"#/\">\n                        All\n                    </a>\n                </li>\n                <li>\n                    <a class={ route === \"/active\" ? \"selected\" : \"\" } href=\"#/active\">\n                        Active\n                    </a>\n                </li>\n                <li>\n                    <a class={ route === \"/completed\" ? \"selected\" : \"\" } href=\"#/completed\">\n                        Completed\n                    </a>\n                </li>\n            </ul>\n            <button class=\"clear-completed\" disabled={activeTodos.length === todos.length} onClick={removeCompleted}>\n                Clear completed\n            </button>\n        </footer>\n    );\n}\n","const uuid = () => crypto.randomUUID();\n\nexport const todoReducer = (state, action) => {\n    switch (action.type) {\n        case \"ADD_ITEM\":\n            return [{ id: uuid(), title: action.payload.title, completed: false }, ...state];\n        case \"UPDATE_ITEM\":\n            return state.map((todo) => (todo.id === action.payload.id ? { ...todo, title: action.payload.title } : todo));\n        case \"REMOVE_ITEM\":\n            return state.filter((todo) => todo.id !== action.payload.id);\n        case \"TOGGLE_ITEM\":\n            return state.map((todo) => (todo.id === action.payload.id ? { ...todo, completed: !todo.completed } : todo));\n        case \"REMOVE_ALL_ITEMS\":\n            return [];\n        case \"TOGGLE_ALL\":\n            return state.map((todo) => (todo.completed !== action.payload.completed ? { ...todo, completed: action.payload.completed } : todo));\n        case \"REMOVE_COMPLETED_ITEMS\":\n            return state.filter((todo) => !todo.completed);\n        default:\n            return [...state];\n    }\n};\n","import { useReducer } from \"preact/hooks\";\n\nimport { Header } from \"./components/header\";\nimport { Main } from \"./components/main\";\nimport { Footer } from \"./components/footer\";\nimport { todoReducer } from \"./reducer\";\n\nimport \"./app.css\";\n\nexport function App() {\n    const [todos, dispatch] = useReducer(todoReducer, []);\n\n    return (\n        <>\n            <Header dispatch={dispatch} />\n            <Main todos={todos} dispatch={dispatch} />\n            <Footer todos={todos} dispatch={dispatch} />\n        </>\n    );\n}\n","import { render } from \"preact\";\nimport Router from 'preact-router';\nimport { createHashHistory  } from 'history';\n\n// import \"preact/debug\";\n\nimport { App } from \"./todo/app\";\n\nimport \"todomvc-app-css/index.css\";\n\nrender((\n    <Router history={createHashHistory()}>\n        <App path=\"/\" />\n    </Router>\n), document.getElementById(\"root\"));\n"],"names":["n","l","u","t","r","o","f","c","s","a","h","v","parentNode","removeChild","y","i","arguments","length","children","call","defaultProps","p","type","props","key","ref","__k","__","__b","__e","__d","__c","__h","constructor","__v","vnode","_","k","this","context","b","indexOf","g","base","m","push","w","__r","debounceRendering","e","sort","shift","__P","L","__n","ownerSVGElement","M","x","d","Array","isArray","A","C","$","nextSibling","S","O","P","some","appendChild","insertBefore","I","setProperty","test","T","style","cssText","replace","toLowerCase","slice","addEventListener","z","j","removeEventListener","removeAttribute","setAttribute","event","H","contextType","value","__E","prototype","render","q","sub","state","_sb","__s","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","forEach","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","N","diffed","localName","nodeType","document","createTextNode","createElementNS","createElement","is","data","childNodes","dangerouslySetInnerHTML","attributes","name","__html","innerHTML","checked","current","unmount","componentWillUnmount","B","firstChild","E","getDerivedStateFromError","setState","componentDidCatch","forceUpdate","Promise","then","bind","resolve","setTimeout","EMPTY$1","assign","obj","exec","url","route","opts","ret","reg","match","matches","split","decodeURIComponent","join","segmentize","max","Math","i$1","charAt","param","flags","plus","star","val","map","default","pathRankSort","rank","index","prepareVNodeForRanking","path","rankSegment","rankChild","segment","customHistory","ROUTERS","subscribers","EMPTY","getCurrentUrl","location","getCurrentLocation","pathname","search","canRoute","history","setUrl","routeTo","didRoute","routeFromLink","node","getAttribute","href","target","handleLinkClick","ctrlKey","metaKey","altKey","shiftKey","button","currentTarget","prevent","stopImmediatePropagation","stopPropagation","preventDefault","delegateLinkHandler","String","nodeName","toUpperCase","hasAttribute","eventListenersInitialized","Router","Component$$1","static","onChange","toChildArray","getMatchingChildren","updating","unlisten","listen","this$1","splice","invoke","filter","newProps","cloneElement","Boolean","ref$1","active","previous","previousUrl","router","Component","Route","component","Link","onClick","_extends","Object","source","hasOwnProperty","apply","__H","__V","__N","every","F","requestAnimationFrame","clearTimeout","cancelAnimationFrame","displayName","isReactComponent","__f","isPureReactComponent","R","Symbol","for","U","D","__u","__a","V","__R","__O","pop","fallback","W","delete","revealOrder","size","get","Map","reverse","set","Z","Y","defineProperty","configurable","writable","K","Q","X","cancelBubble","nn","defaultPrevented","persist","isPropagationStopped","isDefaultPrevented","nativeEvent","en","class","rn","multiple","selected","defaultValue","className","enumerable","$$typeof","un","on","__source","__self","sanitize","string","hasValidMin","min","Input","_ref","onSubmit","placeholder","label","onBlur","inputRef","useRef","useEffect","end","setSelectionRange","focus","handleBlur","useCallback","handleKeyDown","keyCode","trim","_jsxs","_jsx","id","onKeyDown","htmlFor","Header","dispatch","addItem","title","payload","Item","memo","todo","isWritable","setIsWritable","useState","completed","toggleItem","removeItem","updateItem","handleDoubleClick","handleUpdate","_Fragment","onDoubleClick","Main","todos","visibleTodos","useMemo","toggleAll","Footer","activeTodos","removeCompleted","disabled","todoReducer","action","crypto","randomUUID","App","useReducer","createHashHistory","getElementById"],"sourceRoot":""}